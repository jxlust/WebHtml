题目：[https://blog.csdn.net/HanXiaoXi_yeal/article/details/112306277](https://blog.csdn.net/HanXiaoXi_yeal/article/details/112306277)


### v-router实现原理
[https://juejin.cn/post/6844903759458336776](https://juejin.cn/post/6844903759458336776)
1. hash模式
通过 hashchange 事件来监听浏览器的 hash值的改变, 渲染响应路由页面
2. history模式
每当同一个文档的浏览历史（即history）出现变化时，就会触发popState事件

### GC
1.引用计数
循环引用，引用是否有，导致内存泄露
2.标记清除
这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。
这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

### Https
1. 请求内容加密
2. 客户端：（内容+对称密钥+对称加密算法）公钥加密
3. 服务器：私钥解密
4. 后面数据通信都用对称加密通信了
5. 证书SSL/TLS客户端下载，获取公钥
6. 浏览器校验证书是否合法，签名、时间、签发机构等等

### 事件循环
1. 同步、异步
2. 异步任务，任务队列，宏任务（i/o、setTimeout,setInterval、UI、setImedi）、微任务(promise、muationOberser、process.nextTick)
3. 先执行同步代码，然后执行完毕，读取任务队列，清空微任务，执行宏任务
4. 循环

### 浏览器渲染原理和过程
[https://www.cnblogs.com/slly/p/6640761.html](https://www.cnblogs.com/slly/p/6640761.html)
[https://www.jianshu.com/p/e6252dc9be32](https://www.jianshu.com/p/e6252dc9be32)
1. DOM Tree：浏览器将HTML解析成树形的数据结构。
2. CSS Rule Tree：浏览器将CSS解析成树形的数据结构。
3. Render Tree: DOM和CSSOM合并后生成Render Tree。
4. layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。
5. painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。
6. reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。
7. repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。