(function (St, It) {
  typeof exports == "object" && typeof module < "u"
    ? It(exports)
    : typeof define == "function" && define.amd
    ? define(["exports"], It)
    : It(
        ((St = typeof globalThis < "u" ? globalThis : St || self).dhtmlxgantt =
          {})
      );
})(this, function (St) {
  "use strict";
  function It(t) {
    (t.config.auto_scheduling_use_progress = !1),
      (t.config.auto_scheduling_project_constraint = !1);
  }
  function tn(t) {
    (t._get_linked_task = function (o, l) {
      var d = null,
        c = l ? o.target : o.source;
      return t.isTaskExists(c) && (d = t.getTask(c)), d;
    }),
      (t._get_link_target = function (o) {
        return t._get_linked_task(o, !0);
      }),
      (t._get_link_source = function (o) {
        return t._get_linked_task(o, !1);
      });
    var n = !1,
      e = {},
      i = {},
      a = {},
      r = {};
    function s(o) {
      return t.isSummaryTask(o) && o.auto_scheduling === !1;
    }
    (t._isLinksCacheEnabled = function () {
      return n;
    }),
      (t._startLinksCache = function () {
        (e = {}), (i = {}), (a = {}), (r = {}), (n = !0);
      }),
      (t._endLinksCache = function () {
        (e = {}), (i = {}), (a = {}), (r = {}), (n = !1);
      }),
      (t._formatLink = function (o, l, d) {
        if (n && e[o.id]) return e[o.id];
        var c = [],
          u = this._get_link_target(o),
          h = this._get_link_source(o);
        if (
          !h ||
          !u ||
          (t.isSummaryTask(u) && t.isChildOf(h.id, u.id)) ||
          (t.isSummaryTask(h) && t.isChildOf(u.id, h.id))
        )
          return c;
        var _ = t.config.schedule_from_end && t.config.project_end,
          f = t.config.auto_scheduling_move_projects;
        !t.config.auto_scheduling_compatibility &&
          t.config.auto_scheduling_strict &&
          (f = !1),
          (l =
            l || (this.isSummaryTask(h) && !s(h))
              ? this.getSubtaskDates(h.id)
              : { start_date: h.start_date, end_date: h.end_date });
        var y = this._getImplicitLinks(
          o,
          h,
          function (S) {
            return f && _
              ? S.$source.length || t.getState("tasksDnd").drag_id == S.id
                ? 0
                : t.calculateDuration({
                    start_date: S.end_date,
                    end_date: l.end_date,
                    task: h,
                  })
              : 0;
          },
          !0
        );
        d ||
          ((d = { start_date: u.start_date, end_date: u.end_date }),
          this.isSummaryTask(u) &&
            !s(u) &&
            (((d = this.getSubtaskDates(u.id)).start_date = d.end_date),
            this.eachTask(function (S) {
              S.type !== this.config.types.project &&
                !S.$target.length &&
                S.start_date < d.start_date &&
                (d.start_date = S.start_date);
            }, u.id)));
        for (
          var v = this._getImplicitLinks(o, u, function (S) {
              return !f ||
                _ ||
                S.$target.length ||
                t.getState("tasksDnd").drag_id == S.id
                ? 0
                : t.calculateDuration({
                    start_date: d.start_date,
                    end_date: S.start_date,
                    task: u,
                  });
            }),
            b = 0,
            g = y.length;
          b < g;
          b++
        )
          for (var m = y[b], p = 0, k = v.length; p < k; p++) {
            var w = v[p],
              x = 1 * m.lag + 1 * w.lag,
              $ = {
                id: o.id,
                type: o.type,
                source: m.task,
                target: w.task,
                subtaskLink: m.subtaskLink,
                lag: (1 * o.lag || 0) + x,
              };
            (t._linkedTasks[$.target] = t._linkedTasks[$.target] || {}),
              (t._linkedTasks[$.target][$.source] = !0),
              c.push(
                t._convertToFinishToStartLink(
                  w.task,
                  $,
                  h,
                  u,
                  m.taskParent,
                  w.taskParent
                )
              );
          }
        return n && (e[o.id] = c), c;
      }),
      (t._isAutoSchedulable = function (o) {
        if (!(o.auto_scheduling !== !1 && o.unscheduled !== !0)) return !1;
        if (this.isSummaryTask(o)) {
          let l = !0;
          if (
            (this.eachTask(function (d) {
              l && t._isAutoSchedulable(d) && (l = !1);
            }, o.id),
            l)
          )
            return !1;
        }
        return !0;
      }),
      (t._getImplicitLinks = function (o, l, d, c) {
        var u = [];
        if (this.isSummaryTask(l) && !s(l)) {
          var h,
            _ = {};
          for (var f in (this.eachTask(function (k) {
            (this.isSummaryTask(k) && !s(k)) || (_[k.id] = k);
          }, l.id),
          _)) {
            var y = _[f];
            if (t._isAutoSchedulable(y)) {
              var v = c ? y.$source : y.$target;
              h = !1;
              for (
                var b = 0;
                b < v.length &&
                o.type != t.config.links.start_to_start &&
                o.type != t.config.links.start_to_finish;
                b++
              ) {
                var g = t.getLink(v[b]),
                  m = c ? g.target : g.source,
                  p = _[m];
                if (p && t._isAutoSchedulable(y) && t._isAutoSchedulable(p)) {
                  let k = 0;
                  if (
                    (g.lag && (k = Math.abs(g.lag)),
                    g.type != t.config.links.finish_to_start)
                  ) {
                    k += t._convertToFinishToStartLink(
                      null,
                      {},
                      y,
                      p
                    ).additionalLag;
                    continue;
                  }
                  const w = g.target == p.id && k && k <= p.duration,
                    x = g.target == y.id && k && k <= y.duration;
                  if (w || x) {
                    h = !0;
                    break;
                  }
                }
              }
              if (!h) {
                let k = !0;
                for (const x in t._linkedTasks[y.id])
                  if (t.isChildOf(x, o.target)) {
                    k = !1;
                    break;
                  }
                let w = 0;
                k && (w = d(y)),
                  u.push({
                    task: y.id,
                    taskParent: y.parent,
                    lag: w,
                    subtaskLink: !0,
                  });
              }
            }
          }
        } else u.push({ task: l.id, taskParent: l.parent, lag: 0 });
        return u;
      }),
      (t._getDirectDependencies = function (o, l) {
        t._linkedTasks = t._linkedTasks || {};
        for (
          var d = [], c = [], u = l ? o.$source : o.$target, h = 0;
          h < u.length;
          h++
        ) {
          var _ = this.getLink(u[h]);
          if (this.isTaskExists(_.source) && this.isTaskExists(_.target)) {
            var f = this.getTask(_.target);
            if (!this._isAutoSchedulable(f) || !this._isAutoSchedulable(o))
              continue;
            if (t.config.auto_scheduling_use_progress) {
              if (f.progress == 1) continue;
              d.push(_);
            } else d.push(_);
          }
        }
        for (h = 0; h < d.length; h++) c = c.concat(this._formatLink(d[h]));
        return c;
      }),
      (t._getInheritedDependencies = function (o, l) {
        var d,
          c = !1,
          u = [];
        return (
          this.isTaskExists(o.id) &&
            this.eachParent(
              function (h) {
                var _;
                c ||
                  (n && (d = l ? i : a)[h.id]
                    ? (u = u.concat(d[h.id]))
                    : this.isSummaryTask(h) &&
                      (this._isAutoSchedulable(h)
                        ? ((_ = this._getDirectDependencies(h, l)),
                          n && (d[h.id] = _),
                          (u = u.concat(_)))
                        : (c = !0)));
              },
              o.id,
              this
            ),
          u
        );
      }),
      (t._getDirectSuccessors = function (o) {
        return this._getDirectDependencies(o, !0);
      }),
      (t._getInheritedSuccessors = function (o) {
        return this._getInheritedDependencies(o, !0);
      }),
      (t._getDirectPredecessors = function (o) {
        return this._getDirectDependencies(o, !1);
      }),
      (t._getInheritedPredecessors = function (o) {
        return this._getInheritedDependencies(o, !1);
      }),
      (t._getSuccessors = function (o, l) {
        var d = this._getDirectSuccessors(o);
        return l ? d : d.concat(this._getInheritedSuccessors(o));
      }),
      (t._getPredecessors = function (o, l) {
        var d,
          c = String(o.id) + "-" + String(l);
        if (n && r[c]) return r[c];
        var u = this._getDirectPredecessors(o);
        return (
          (d = l ? u : u.concat(this._getInheritedPredecessors(o))),
          n && (r[c] = d),
          d
        );
      }),
      (t._convertToFinishToStartLink = function (o, l, d, c, u, h) {
        var _ = {
            target: o,
            link: t.config.links.finish_to_start,
            id: l.id,
            lag: l.lag || 0,
            sourceLag: 0,
            targetLag: 0,
            trueLag: l.lag || 0,
            source: l.source,
            preferredStart: null,
            sourceParent: u,
            targetParent: h,
            hashSum: null,
            subtaskLink: l.subtaskLink,
          },
          f = 0;
        switch (String(l.type)) {
          case String(t.config.links.start_to_start):
            (f = -d.duration), (_.sourceLag = f);
            break;
          case String(t.config.links.finish_to_finish):
            (f = -c.duration), (_.targetLag = f);
            break;
          case String(t.config.links.start_to_finish):
            (f = -d.duration - c.duration),
              (_.sourceLag = -d.duration),
              (_.targetLag = -c.duration);
            break;
          default:
            f = 0;
        }
        return (
          (_.lag += f),
          (_.hashSum = _.lag + "_" + _.link + "_" + _.source + "_" + _.target),
          _
        );
      });
  }
  var en = {
    second: 1,
    minute: 60,
    hour: 3600,
    day: 86400,
    week: 604800,
    month: 2592e3,
    quarter: 7776e3,
    year: 31536e3,
  };
  function Jt(t) {
    return en[t] || en.hour;
  }
  function st(t, n) {
    if (t.forEach) t.forEach(n);
    else for (var e = t.slice(), i = 0; i < e.length; i++) n(e[i], i);
  }
  function fe(t, n) {
    if (t.find) return t.find(n);
    for (var e = 0; e < t.length; e++) if (n(t[e], e)) return t[e];
  }
  function Kt(t, n) {
    if (t.includes) return t.includes(n);
    for (var e = 0; e < t.length; e++) if (t[e] === n) return !0;
    return !1;
  }
  function Lt(t) {
    return Array.isArray
      ? Array.isArray(t)
      : t && t.length !== void 0 && t.pop && t.push;
  }
  function nt(t) {
    return (
      !(!t || typeof t != "object") &&
      !!(t.getFullYear && t.getMonth && t.getDate)
    );
  }
  function Tt(t) {
    return nt(t) && !isNaN(t.getTime());
  }
  function Xt(t, n) {
    var e,
      i = function () {
        i.$cancelTimeout(), (i.$pending = !0);
        var a = Array.prototype.slice.call(arguments);
        e = setTimeout(function () {
          t.apply(this, a), (i.$pending = !1);
        }, n);
      };
    return (
      (i.$pending = !1),
      (i.$cancelTimeout = function () {
        clearTimeout(e), (i.$pending = !1);
      }),
      (i.$execute = function () {
        var a = Array.prototype.slice.call(arguments);
        t.apply(this, a), i.$cancelTimeout();
      }),
      i
    );
  }
  function ot(t, n) {
    return nn(t) && !nn(n) && (t = "0"), t;
  }
  function nn(t) {
    return t === 0;
  }
  function Bt(t, n) {
    for (var e, i, a, r = 0, s = t.length - 1; r <= s; )
      if (((i = +t[(e = Math.floor((r + s) / 2))]), (a = +t[e - 1]), i < n))
        r = e + 1;
      else {
        if (!(i > n)) {
          for (; +t[e] == +t[e + 1]; ) e++;
          return e;
        }
        if (!isNaN(a) && a < n) return e - 1;
        s = e - 1;
      }
    return t.length - 1;
  }
  function an() {
    return {
      getVertices: function (t) {
        for (var n, e = {}, i = 0, a = t.length; i < a; i++)
          (e[(n = t[i]).target] = n.target), (e[n.source] = n.source);
        var r,
          s = [];
        for (var i in e) (r = e[i]), s.push(r);
        return s;
      },
      topologicalSort: function (t) {
        for (
          var n = this.getVertices(t), e = {}, i = 0, a = n.length;
          i < a;
          i++
        )
          e[n[i]] = { id: n[i], $source: [], $target: [], $incoming: 0 };
        for (i = 0, a = t.length; i < a; i++) {
          var r = e[t[i].target];
          r.$target.push(i),
            (r.$incoming = r.$target.length),
            e[t[i].source].$source.push(i);
        }
        for (
          var s = n.filter(function (u) {
              return !e[u].$incoming;
            }),
            o = [];
          s.length;

        ) {
          var l = s.pop();
          o.push(l);
          var d = e[l];
          for (i = 0; i < d.$source.length; i++) {
            var c = e[t[d.$source[i]].target];
            c.$incoming--, c.$incoming || s.push(c.id);
          }
        }
        return o;
      },
      groupAdjacentEdges: function (t) {
        for (var n, e = {}, i = 0, a = t.length; i < a; i++)
          e[(n = t[i]).source] || (e[n.source] = []), e[n.source].push(n);
        return e;
      },
      tarjanStronglyConnectedComponents: function (t, n) {
        for (
          var e = {},
            i = [],
            a = this.groupAdjacentEdges(n),
            r = !1,
            s = [],
            o = 0;
          o < t.length;
          o++
        ) {
          var l = y(t[o]);
          if (!l.visited)
            for (var d = [l], c = 0; d.length; ) {
              var u = d.pop();
              u.visited ||
                ((u.index = c),
                (u.lowLink = c),
                c++,
                i.push(u),
                (u.onStack = !0),
                (u.visited = !0)),
                (r = !1),
                (n = a[u.id] || []);
              for (var h = 0; h < n.length; h++) {
                var _ = y(n[h].target);
                if (((_.edge = n[h]), _.index === void 0)) {
                  d.push(u), d.push(_), (r = !0);
                  break;
                }
                _.onStack && (u.lowLink = Math.min(u.lowLink, _.index));
              }
              if (!r) {
                if (u.index == u.lowLink) {
                  for (
                    var f = { tasks: [], links: [], linkKeys: [] };
                    ((_ = i.pop()).onStack = !1),
                      f.tasks.push(_.id),
                      _.edge &&
                        (f.links.push(_.edge.id),
                        f.linkKeys.push(_.edge.hashSum)),
                      _ != u;

                  );
                  s.push(f);
                }
                d.length &&
                  ((_ = u),
                  ((u = d[d.length - 1]).lowLink = Math.min(
                    u.lowLink,
                    _.lowLink
                  )));
              }
            }
        }
        return s;
        function y(v) {
          return (
            e[v] ||
              (e[v] = {
                id: v,
                onStack: !1,
                index: void 0,
                lowLink: void 0,
                edge: void 0,
              }),
            e[v]
          );
        }
      },
      findLoops: function (t) {
        var n = [];
        st(t, function (i) {
          i.target == i.source && n.push({ tasks: [i.source], links: [i.id] });
        });
        var e = this.getVertices(t);
        return (
          st(this.tarjanStronglyConnectedComponents(e, t), function (i) {
            i.tasks.length > 1 && n.push(i);
          }),
          n
        );
      },
    };
  }
  function rn(t) {
    return {
      getVirtualRoot: function () {
        return t.mixin(t.getSubtaskDates(), {
          id: t.config.root_id,
          type: t.config.types.project,
          $source: [],
          $target: [],
          $virtual: !0,
        });
      },
      getLinkedTasks: function (n, e) {
        var i = [n],
          a = !1;
        t._isLinksCacheEnabled() || (t._startLinksCache(), (a = !0));
        for (var r = [], s = {}, o = {}, l = 0; l < i.length; l++)
          this._getLinkedTasks(i[l], s, e, o);
        for (var l in o) r.push(o[l]);
        return a && t._endLinksCache(), r;
      },
      _collectRelations: function (n, e, i, a) {
        var r,
          s = t._getSuccessors(n, e),
          o = [];
        i && (o = t._getPredecessors(n, e));
        for (var l = [], d = 0; d < s.length; d++)
          a[(r = s[d].hashSum)] || ((a[r] = !0), l.push(s[d]));
        for (d = 0; d < o.length; d++)
          a[(r = o[d].hashSum)] || ((a[r] = !0), l.push(o[d]));
        return l;
      },
      _getLinkedTasks: function (n, e, i, a) {
        for (
          var r,
            s = n === void 0 ? t.config.root_id : n,
            o = ((e = {}), {}),
            l = [{ from: s, includePredecessors: i, isChild: !1 }];
          l.length;

        ) {
          var d = l.pop(),
            c = d.isChild;
          if (!e[(s = d.from)]) {
            (r = t.isTaskExists(s) ? t.getTask(s) : this.getVirtualRoot()),
              (e[s] = !0);
            for (
              var u = this._collectRelations(r, c, i, o), h = 0;
              h < u.length;
              h++
            ) {
              var _ = u[h];
              let v = !0;
              t.config.auto_scheduling_use_progress &&
                t.getTask(_.target).progress == 1 &&
                (v = !1);
              const b = t.getTask(_.target),
                g = t.getTask(_.source);
              (b.unscheduled || g.unscheduled) && (v = !1),
                v && (a[_.hashSum] = _);
              var f = _.sourceParent == _.targetParent;
              e[_.target] ||
                l.push({ from: _.target, includePredecessors: !0, isChild: f });
            }
            if (t.hasChild(r.id)) {
              var y = t.getChildren(r.id);
              for (h = 0; h < y.length; h++)
                e[y[h]] ||
                  l.push({ from: y[h], includePredecessors: !0, isChild: !0 });
            }
          }
        }
        return a;
      },
    };
  }
  var Zt,
    V = ((t) => (
      (t.ASAP = "asap"),
      (t.ALAP = "alap"),
      (t.SNET = "snet"),
      (t.SNLT = "snlt"),
      (t.FNET = "fnet"),
      (t.FNLT = "fnlt"),
      (t.MSO = "mso"),
      (t.MFO = "mfo"),
      t
    ))(V || {});
  class Nt {
    static Create(n) {
      const e = new Nt();
      if (n) for (const i in e) n[i] !== void 0 && (e[i] = n[i]);
      return e;
    }
    constructor() {
      (this.link = null),
        (this.task = null),
        (this.start_date = null),
        (this.end_date = null),
        (this.latestStart = null),
        (this.earliestStart = null),
        (this.earliestEnd = null),
        (this.latestEnd = null),
        (this.latestSchedulingStart = null),
        (this.earliestSchedulingStart = null),
        (this.latestSchedulingEnd = null),
        (this.earliestSchedulingEnd = null),
        (this.kind = "asap"),
        (this.conflict = !1);
    }
  }
  class pe {
    constructor(n) {
      (this.isAsapTask = (e) => {
        const i = this.getConstraintType(e);
        return this._gantt.config.schedule_from_end
          ? i === V.ASAP
          : i !== V.ALAP;
      }),
        (this.isAlapTask = (e) => !this.isAsapTask(e)),
        (this.getConstraintType = (e) => {
          if (!this._gantt._isAutoSchedulable(e)) return;
          const i = this._getTaskConstraint(e);
          return i.constraint_type
            ? i.constraint_type
            : this._gantt.config.schedule_from_end
            ? V.ALAP
            : V.ASAP;
        }),
        (this._getTaskConstraint = (e) => {
          let i = this._getOwnConstraint(e);
          if (
            this._gantt.config.auto_scheduling_project_constraint &&
            !this._gantt.getState().group_mode
          ) {
            let a = V.ASAP;
            this._gantt.config.schedule_from_end && (a = V.ALAP),
              ((i && i.constraint_type) !== a && i) ||
                (i = this._getParentConstraint(e));
          }
          return i;
        }),
        (this._getOwnConstraint = (e) => ({
          constraint_type: e.constraint_type,
          constraint_date: e.constraint_date,
        })),
        (this._getParentConstraint = (e) => {
          let i = V.ASAP;
          this._gantt.config.schedule_from_end && (i = V.ALAP);
          let a = { constraint_type: i, constraint_date: null };
          return (
            this._gantt.eachParent((r) => {
              a.constraint_type === i &&
                r.constraint_type &&
                r.constraint_type !== i &&
                (a = {
                  constraint_type: r.constraint_type,
                  constraint_date: r.constraint_date,
                });
            }, e.id),
            a
          );
        }),
        (this.hasConstraint = (e) => !!this.getConstraintType(e)),
        (this.processConstraint = (e, i) => {
          const a = this._getTaskConstraint(e);
          if (
            a &&
            !(a.constraint_type === V.ALAP || a.constraint_type === V.ASAP)
          ) {
            if (Tt(a.constraint_date)) {
              const r = a.constraint_date,
                s = Nt.Create(i);
              switch (((s.task = e.id), a.constraint_type)) {
                case V.SNET:
                  (s.earliestStart = new Date(r)),
                    (s.earliestEnd = this._gantt.calculateEndDate({
                      start_date: s.earliestStart,
                      duration: e.duration,
                      task: e,
                    })),
                    (s.link = null);
                  break;
                case V.SNLT:
                  (s.latestStart = new Date(r)),
                    (s.latestEnd = this._gantt.calculateEndDate({
                      start_date: s.latestStart,
                      duration: e.duration,
                      task: e,
                    })),
                    (s.link = null);
                  break;
                case V.FNET:
                  (s.earliestStart = this._gantt.calculateEndDate({
                    start_date: r,
                    duration: -e.duration,
                    task: e,
                  })),
                    (s.earliestEnd = new Date(r)),
                    (s.link = null);
                  break;
                case V.FNLT:
                  (s.latestStart = this._gantt.calculateEndDate({
                    start_date: r,
                    duration: -e.duration,
                    task: e,
                  })),
                    (s.latestEnd = new Date(r)),
                    (s.link = null);
                  break;
                case V.MSO:
                  (s.earliestStart = new Date(r)),
                    (s.earliestEnd = this._gantt.calculateEndDate({
                      start_date: s.earliestStart,
                      duration: e.duration,
                      task: e,
                    })),
                    (s.latestStart = s.earliestStart),
                    (s.latestEnd = s.earliestEnd),
                    (s.link = null);
                  break;
                case V.MFO:
                  (s.earliestStart = this._gantt.calculateEndDate({
                    start_date: r,
                    duration: -e.duration,
                    task: e,
                  })),
                    (s.earliestEnd = this._gantt.calculateEndDate({
                      start_date: s.earliestStart,
                      duration: e.duration,
                      task: e,
                    })),
                    (s.latestStart = s.earliestStart),
                    (s.latestEnd = s.earliestEnd),
                    (s.link = null);
              }
              return s;
            }
          }
          return i;
        }),
        (this.getConstraints = (e, i) => {
          const a = [],
            r = {},
            s = (l) => {
              r[l.id] ||
                (this.hasConstraint(l) &&
                  !this._gantt.isSummaryTask(l) &&
                  (r[l.id] = l));
            };
          if (this._gantt.isTaskExists(e)) {
            const l = this._gantt.getTask(e);
            s(l);
          }
          let o;
          if ((this._gantt.eachTask((l) => s(l), e), i))
            for (let l = 0; l < i.length; l++) {
              const d = i[l];
              r[d.target] || ((o = this._gantt.getTask(d.target)), s(o)),
                r[d.source] || ((o = this._gantt.getTask(d.source)), s(o));
            }
          for (const l in r)
            r[l].type !== this._gantt.config.types.placeholder && a.push(r[l]);
          return a;
        }),
        (this._gantt = n);
    }
    static Create(n) {
      return new pe(n);
    }
  }
  class sn {
    constructor(n) {
      this._gantt = n;
    }
    isEqual(n, e, i) {
      return !this._gantt._hasDuration(n, e, i);
    }
    isFirstSmaller(n, e, i) {
      return n.valueOf() < e.valueOf() && !this.isEqual(n, e, i);
    }
    isSmallerOrDefault(n, e, i) {
      return !(n && !this.isFirstSmaller(n, e, i));
    }
    isGreaterOrDefault(n, e, i) {
      return !(n && !this.isFirstSmaller(e, n, i));
    }
  }
  class me {
    static Create(n) {
      const e = new me();
      return (e._gantt = n), (e._comparator = new sn(n)), e;
    }
    resolveRelationDate(n, e, i) {
      let a = null,
        r = null,
        s = null,
        o = null;
      const l = this._gantt.getTask(n),
        d = e.successors;
      let c = null;
      const u = i[n];
      for (let _ = 0; _ < d.length; _++) {
        const f = d[_];
        o = f.preferredStart;
        const y = this.getLatestEndDate(f, i, l),
          v = this._gantt.calculateEndDate({
            start_date: y,
            duration: -l.duration,
            task: l,
          });
        this._comparator.isGreaterOrDefault(c, y, l) && (c = y),
          this._comparator.isGreaterOrDefault(o, v, l) &&
            this._comparator.isGreaterOrDefault(a, y, l) &&
            ((a = y), (s = v), (r = f.id));
      }
      !d.length &&
        this._gantt.config.project_end &&
        (this._comparator.isGreaterOrDefault(
          this._gantt.config.project_end,
          l.end_date,
          l
        ) && (a = this._gantt.config.project_end),
        this._gantt.callEvent("onBeforeTaskAutoSchedule", [l, l.end_date]) ===
          !1 && (a = l.end_date)),
        a &&
          (l.duration
            ? ((a = this._gantt.getClosestWorkTime({
                date: a,
                dir: "future",
                task: l,
              })),
              (s = this._gantt.calculateEndDate({
                start_date: a,
                duration: -l.duration,
                task: l,
              })))
            : (s = a =
                this._gantt.getClosestWorkTime({
                  date: a,
                  dir: "past",
                  task: l,
                })));
      const h = Nt.Create(u);
      return (
        (h.link = r),
        (h.task = n),
        (h.end_date = a),
        (h.start_date = s),
        (h.kind = "alap"),
        c &&
          ((h.latestSchedulingStart = this._gantt.calculateEndDate({
            start_date: c,
            duration: -l.duration,
            task: l,
          })),
          (h.latestSchedulingEnd = c)),
        h
      );
    }
    getSuccessorStartDate(n, e) {
      const i = e[n],
        a = this._gantt.getTask(n);
      let r;
      return (
        (r =
          i && (i.start_date || i.end_date)
            ? i.start_date
              ? i.start_date
              : this._gantt.calculateEndDate({
                  start_date: i.end_date,
                  duration: -a.duration,
                  task: a,
                })
            : a.start_date),
        r
      );
    }
    getLatestEndDate(n, e, i) {
      const a = this.getSuccessorStartDate(n.target, e),
        r = i;
      let s = this._gantt.getClosestWorkTime({ date: a, dir: "past", task: r });
      return (
        s &&
          n.lag &&
          1 * n.lag == 1 * n.lag &&
          (s = this._gantt.calculateEndDate({
            start_date: s,
            duration: 1 * -n.lag,
            task: r,
          })),
        s
      );
    }
  }
  class ve {
    static Create(n) {
      const e = new ve();
      return (e._gantt = n), (e._comparator = new sn(n)), e;
    }
    resolveRelationDate(n, e, i) {
      let a = null,
        r = null,
        s = null;
      const o = this._gantt.getTask(n),
        l = e.predecessors,
        d = {};
      let c = null;
      for (let f = 0; f < l.length; f++) {
        const y = l[f];
        s = y.preferredStart;
        const v = this.getEarliestStartDate(y, i, o);
        if (
          (this._comparator.isSmallerOrDefault(c, v, o) && (c = v),
          this._comparator.isSmallerOrDefault(s, v, o) &&
            this._comparator.isSmallerOrDefault(a, v, o) &&
            ((a = v), (r = y.id)),
          !o.duration)
        ) {
          const b = this._gantt.getLink(y.id);
          (d[b.type] === void 0 || d[b.type] < +v) && (d[b.type] = +v);
        }
      }
      !l.length &&
        this._gantt.config.project_start &&
        ((this._comparator.isSmallerOrDefault(
          o.start_date,
          this._gantt.config.project_start,
          o
        ) ||
          (this._gantt.config.auto_scheduling_strict &&
            this._comparator.isGreaterOrDefault(
              o.start_date,
              this._gantt.config.project_start,
              o
            ))) &&
          (a = this._gantt.config.project_start),
        this._gantt.callEvent("onBeforeTaskAutoSchedule", [o, o.start_date]) ===
          !1 && (a = o.start_date));
      let u = null;
      if (a)
        if (o.duration)
          (a = this._gantt.getClosestWorkTime({
            date: a,
            dir: "future",
            task: o,
          })),
            (u = this._gantt.calculateEndDate({
              start_date: a,
              duration: o.duration,
              task: o,
            }));
        else {
          let f = "future";
          const y = this._gantt.config.links;
          if (d[y.finish_to_finish] !== void 0) {
            const v = l.length === 1;
            let b = !0;
            for (const g in d)
              if (g != y.finish_to_finish && d[y.finish_to_finish] < d[g]) {
                b = !1;
                break;
              }
            (v || b) && (f = "past");
          }
          a = u = this._gantt.getClosestWorkTime({ date: a, dir: f, task: o });
        }
      const h = i[n],
        _ = Nt.Create(h);
      return (
        (_.link = r),
        (_.task = n),
        (_.start_date = a),
        (_.end_date = u),
        (_.kind = "asap"),
        c &&
          ((_.earliestSchedulingStart = c),
          (_.earliestSchedulingEnd = this._gantt.calculateEndDate({
            start_date: c,
            duration: o.duration,
            task: o,
          }))),
        _
      );
    }
    getPredecessorEndDate(n, e) {
      const i = e[n],
        a = this._gantt.getTask(n);
      let r;
      return (
        (r =
          i && (i.start_date || i.end_date)
            ? i.end_date
              ? i.end_date
              : this._gantt.calculateEndDate({
                  start_date: i.start_date,
                  duration: a.duration,
                  task: a,
                })
            : a.end_date),
        r
      );
    }
    getEarliestStartDate(n, e, i) {
      const a = this.getPredecessorEndDate(n.source, e),
        r = i,
        s = this._gantt.getTask(n.source);
      let o;
      if (a && n.lag && 1 * n.lag == 1 * n.lag) {
        let l = r;
        this._gantt.config.auto_scheduling_move_projects &&
          n.subtaskLink &&
          this._gantt.isTaskExists(n.targetParent) &&
          (l = this._gantt.getTask(n.targetParent)),
          (o = this._gantt.getClosestWorkTime({
            date: a,
            dir: "future",
            task: s,
          })),
          n.sourceLag &&
            (o = this._gantt.calculateEndDate({
              start_date: o,
              duration: 1 * n.sourceLag,
              task: s,
            })),
          n.targetLag &&
            (o = this._gantt.calculateEndDate({
              start_date: o,
              duration: 1 * n.targetLag,
              task: l,
            })),
          (o = this._gantt.calculateEndDate({
            start_date: o,
            duration: 1 * n.trueLag,
            task: l,
          }));
      } else {
        const l =
          this._gantt.getLink(n.id).type ===
          this._gantt.config.links.finish_to_finish;
        o =
          !r.duration && l
            ? this._gantt.getClosestWorkTime({ date: a, dir: "past", task: r })
            : this._gantt.getClosestWorkTime({
                date: a,
                dir: "future",
                task: r,
              });
      }
      return o;
    }
  }
  class ai {
    constructor(n, e, i) {
      (this._secondIteration = !1),
        (this._gantt = n),
        (this._constraintsHelper = i),
        (this._graphHelper = e),
        (this._asapStrategy = ve.Create(n)),
        (this._alapStrategy = me.Create(n)),
        (this._secondIterationRequired = !1);
    }
    generatePlan(n, e) {
      const i = this._graphHelper,
        a = this._gantt,
        r = this._constraintsHelper,
        s = this._alapStrategy,
        o = this._asapStrategy,
        {
          orderedIds: l,
          reversedIds: d,
          relationsMap: c,
          plansHash: u,
        } = this.buildWorkCollections(n, e, i);
      let h;
      return (
        this.processConstraints(l, u, a, r),
        (h = a.config.schedule_from_end
          ? this.iterateTasks(d, l, r.isAlapTask, s, o, c, u)
          : this.iterateTasks(l, d, r.isAsapTask, o, s, c, u)),
        h
      );
    }
    applyProjectPlan(n) {
      const e = this._gantt;
      let i, a, r, s;
      const o = [];
      for (let l = 0; l < n.length; l++) {
        if (((r = null), (s = null), (i = n[l]), !e.isTaskExists(i.task)))
          continue;
        (a = e.getTask(i.task)),
          i.link &&
            ((r = e.getLink(i.link)),
            (s =
              i.kind === "asap"
                ? this._gantt.getTask(r.source)
                : this._gantt.getTask(r.target)));
        let d = null;
        i.start_date &&
          a.start_date.valueOf() !== i.start_date.valueOf() &&
          (d = i.start_date),
          d &&
            ((a.start_date = d),
            (a.end_date = e.calculateEndDate(a)),
            o.push(a.id),
            e.callEvent("onAfterTaskAutoSchedule", [a, d, r, s]));
      }
      return o;
    }
    iterateTasks(n, e, i, a, r, s, o) {
      const l = this._gantt,
        d = [];
      for (let c = 0; c < n.length; c++) {
        const u = n[c],
          h = l.getTask(u);
        if (!l._isAutoSchedulable(h)) continue;
        const _ = a.resolveRelationDate(u, s[u], o);
        this.limitPlanDates(h, _),
          i(h) ? this.processResolvedDate(h, _, d, o) : (o[h.id] = _);
      }
      for (let c = 0; c < e.length; c++) {
        const u = e[c],
          h = l.getTask(u);
        if (l._isAutoSchedulable(h) && !i(h)) {
          const _ = r.resolveRelationDate(u, s[u], o);
          this.limitPlanDates(h, _), this.processResolvedDate(h, _, d, o);
        }
      }
      if (this._secondIterationRequired) {
        if (this._secondIteration) this._secondIteration = !1;
        else if (
          ((this._secondIteration = !0), this.summaryLagChanged(l, s, o))
        )
          return this.iterateTasks(n, e, i, a, r, s, o);
      }
      return d;
    }
    summaryLagChanged(n, e, i) {
      const a = {},
        r = {};
      for (const o in e)
        e[o].predecessors.forEach((l) => {
          if (l.subtaskLink) {
            const d = n.getLink(l.id);
            this.getProjectUpdates(n, i, l, d, "source", a, r),
              this.getProjectUpdates(n, i, l, d, "target", a, r);
          }
        });
      let s = !1;
      for (const o in a) {
        const l = a[o];
        if (!l.min || !l.max) continue;
        const d = n.getTask(o),
          c = n.calculateDuration({
            start_date: d.start_date,
            end_date: d.end_date,
            task: d,
          }),
          u = n.calculateDuration({
            start_date: l.min,
            end_date: l.max,
            task: d,
          });
        u !== c &&
          ((d.start_date = l.min), (d.end_date = l.max), (d.duration = u));
      }
      for (const o in r) {
        const l = r[o];
        let d, c;
        const u = a[l.source],
          h = a[l.target];
        u && (d = { start_date: u.start_date, end_date: u.end_date }),
          h && (d = { start_date: h.start_date, end_date: h.end_date }),
          n._formatLink(l, d, c).forEach(function (_) {
            for (const f in e)
              e[f].predecessors.forEach(function (y) {
                const v = y.id === _.id,
                  b = y.target === _.target,
                  g = y.source === _.source;
                v &&
                  b &&
                  g &&
                  ((y.lag = _.lag),
                  (y.sourceLag = _.sourceLag),
                  (y.targetLag = _.targetLag),
                  (y.hashSum = _.hashSum));
              });
          }),
          (s = !0);
      }
      return s;
    }
    getProjectUpdates(n, e, i, a, r, s, o) {
      if (n.getTask(a[r]).type === n.config.types.project) {
        s[a[r]] = s[a[r]] || { id: a[r], link: a };
        const l = s[a[r]];
        let d = e[i[r]];
        d &&
          (r != "source" ||
            (d.start_date && d.end_date) ||
            (d = n.getTask(d.task)),
          (l.min = l.min || d.start_date),
          l.min > d.start_date && (l.min = d.start_date),
          (l.max = l.max || d.end_date),
          l.max < d.end_date && (l.max = d.end_date),
          (o[a.id] = a));
      }
    }
    processResolvedDate(n, e, i, a) {
      if (e.start_date && this._gantt.isLinkExists(e.link)) {
        let r = null,
          s = null;
        if (
          (e.link &&
            ((r = this._gantt.getLink(e.link)),
            (s =
              e.kind === "asap"
                ? this._gantt.getTask(r.source)
                : this._gantt.getTask(r.target))),
          n.start_date.valueOf() !== e.start_date.valueOf() &&
            this._gantt.callEvent("onBeforeTaskAutoSchedule", [
              n,
              e.start_date,
              r,
              s,
            ]) === !1)
        )
          return;
      }
      (a[n.id] = e), e.start_date && i.push(e);
    }
    limitPlanDates(n, e) {
      const i = e.start_date || n.start_date;
      return (
        e.earliestStart &&
          i < e.earliestStart &&
          ((e.start_date = e.earliestStart), (e.end_date = e.earliestEnd)),
        e.latestStart &&
          i > e.latestStart &&
          ((e.start_date = e.latestStart), (e.end_date = e.latestEnd)),
        e.latestSchedulingStart &&
          i > e.latestSchedulingStart &&
          ((e.start_date = e.latestSchedulingStart),
          (e.end_date = e.latestSchedulingEnd)),
        e.earliestSchedulingStart &&
          i < e.earliestSchedulingStart &&
          ((e.start_date = e.earliestSchedulingStart),
          (e.end_date = e.earliestSchedulingEnd)),
        e.start_date &&
          (e.start_date > e.latestSchedulingStart ||
            e.start_date < e.earliestSchedulingStart ||
            e.start_date > e.latestStart ||
            e.start_date < e.earliestStart ||
            e.end_date > e.latestSchedulingEnd ||
            e.end_date < e.earliestSchedulingEnd ||
            e.end_date > e.latestEnd ||
            e.end_date < e.earliestEnd) &&
          (e.conflict = !0),
        e
      );
    }
    buildWorkCollections(n, e, i) {
      const a = this._gantt,
        r = i.topologicalSort(n),
        s = r.slice().reverse(),
        o = {},
        l = {};
      for (let d = 0, c = r.length; d < c; d++) {
        const u = r[d],
          h = a.getTask(u);
        a._isAutoSchedulable(h) &&
          ((l[u] = { successors: [], predecessors: [] }), (o[u] = null));
      }
      for (let d = 0, c = e.length; d < c; d++) {
        const u = e[d];
        o[u.id] === void 0 &&
          (s.unshift(u.id),
          r.unshift(u.id),
          (o[u.id] = null),
          (l[u.id] = { successors: [], predecessors: [] }));
      }
      for (let d = 0, c = n.length; d < c; d++) {
        const u = n[d];
        l[u.source] && l[u.source].successors.push(u),
          l[u.target] && l[u.target].predecessors.push(u);
      }
      return { orderedIds: r, reversedIds: s, relationsMap: l, plansHash: o };
    }
    processConstraints(n, e, i, a) {
      for (let r = 0; r < n.length; r++) {
        const s = n[r],
          o = i.getTask(s),
          l = a.getConstraintType(o);
        if (l && l !== V.ASAP && l !== V.ALAP) {
          const d = a.processConstraint(o, Nt.Create());
          e[o.id] = d;
        }
      }
    }
  }
  function ke(t, n, e) {
    const i = [t],
      a = [],
      r = {},
      s = {};
    let o;
    for (; i.length > 0; )
      if (((o = i.shift()), !e[o])) {
        (e[o] = !0), a.push(o);
        for (let c = 0; c < n.length; c++) {
          const u = n[c];
          u.source == o || u.sourceParent == o
            ? (e[u.target] ||
                (i.push(u.target), (s[u.id] = !0), n.splice(c, 1), c--),
              (r[u.hashSum] = u))
            : (u.target != o && u.targetParent != o) ||
              (e[u.source] ||
                (i.push(u.source), (s[u.id] = !0), n.splice(c, 1), c--),
              (r[u.hashSum] = u));
        }
      }
    const l = [];
    let d = [];
    for (const c in s) l.push(c);
    for (const c in r) d.push(r[c]);
    return d.length || (d = n), { tasks: a, links: l, processedLinks: d };
  }
  class ri {
    constructor(n, e) {
      (this.getConnectedGroupRelations = (i) =>
        ke(i, this._linksBuilder.getLinkedTasks(), {}).processedLinks),
        (this.getConnectedGroup = (i) => {
          const a = this._linksBuilder.getLinkedTasks();
          if (i !== void 0) {
            if (
              this._gantt.getTask(i).type === this._gantt.config.types.project
            )
              return { tasks: [], links: [] };
            const r = ke(i, a, {});
            return { tasks: r.tasks, links: r.links };
          }
          return (function (r) {
            const s = {},
              o = [];
            let l, d, c;
            for (let u = 0; u < r.length; u++)
              if (
                ((l = r[u].source),
                (d = r[u].target),
                (c = null),
                s[l] ? s[d] || (c = d) : (c = l),
                c)
              ) {
                const h = r.length;
                o.push(ke(c, r, s)), h !== r.length && (u = -1);
              }
            return o;
          })(a).map((r) => ({ tasks: r.tasks, links: r.links }));
        }),
        (this._linksBuilder = e),
        (this._gantt = n);
    }
  }
  class si {
    constructor(n, e, i) {
      (this.isCircularLink = (a) => !!this.getLoopContainingLink(a)),
        (this.getLoopContainingLink = (a) => {
          const r = this._graphHelper,
            s = this._linksBuilder,
            o = this._gantt;
          let l = s.getLinkedTasks();
          o.isLinkExists(a.id) || (l = l.concat(o._formatLink(a)));
          const d = r.findLoops(l);
          for (let c = 0; c < d.length; c++) {
            const u = d[c].links;
            for (let h = 0; h < u.length; h++) if (u[h] == a.id) return d[c];
          }
          return null;
        }),
        (this.findCycles = () => {
          const a = this._graphHelper,
            r = this._linksBuilder.getLinkedTasks();
          return a.findLoops(r);
        }),
        (this._linksBuilder = i),
        (this._graphHelper = e),
        (this._gantt = n);
    }
  }
  function oi(t, n, e, i) {
    const a = function () {
      let r,
        s,
        o = !1;
      function l(x, $) {
        t.config.auto_scheduling &&
          !t._autoscheduling_in_progress &&
          (t.getState().batch_update ? (o = !0) : t.autoSchedule($.source));
      }
      function d(x, $) {
        const S = t.config.auto_scheduling_use_progress;
        return (
          (t.config.auto_scheduling_use_progress = !1),
          t.isCircularLink($)
            ? (t.callEvent("onCircularLinkError", [
                $,
                e.getLoopContainingLink($),
              ]),
              (t.config.auto_scheduling_use_progress = S),
              !1)
            : ((t.config.auto_scheduling_use_progress = S), !0)
        );
      }
      function c(x, $) {
        const S = t.getTask($.source),
          T = t.getTask($.target);
        return !(
          !t.config.auto_scheduling_descendant_links &&
          ((t.isChildOf(S.id, T.id) && t.isSummaryTask(T)) ||
            (t.isChildOf(T.id, S.id) && t.isSummaryTask(S)))
        );
      }
      function u(x, $, S, T) {
        return (
          !!x != !!$ ||
          (!(!x && !$) &&
            (x.valueOf() > $.valueOf()
              ? t._hasDuration({ start_date: $, end_date: x, task: T })
              : t._hasDuration({ start_date: x, end_date: $, task: S })))
        );
      }
      function h(x, $) {
        return (
          !!u(x.start_date, $.start_date, x, $) ||
          t.getConstraintType(x) !== t.getConstraintType($) ||
          !!u(x.constraint_date, $.constraint_date, x, $) ||
          !(
            !u(x.start_date, $.start_date, x, $) &&
            ((!u(x.end_date, $.end_date, x, $) && x.duration === $.duration) ||
              x.type === t.config.types.milestone)
          ) ||
          void 0
        );
      }
      function _(x) {
        return t.config.auto_scheduling_compatibility
          ? n.getLinkedTasks(x, !0)
          : i.getConnectedGroupRelations(x);
      }
      function f(x, $) {
        let S = !1;
        for (let T = 0; T < r.length; T++) {
          const E = t.getLink($[T].id);
          !E ||
            (E.type !== t.config.links.start_to_start &&
              E.type !== t.config.links.start_to_finish) ||
            ($.splice(T, 1), T--, (S = !0));
        }
        if (S) {
          const T = {};
          for (let C = 0; C < $.length; C++) T[$[C].id] = !0;
          const E = _(x);
          for (let C = 0; C < E.length; C++) T[E[C].id] || $.push(E[C]);
        }
      }
      function y(x, $) {
        if (t.config.schedule_from_end) {
          if (
            $.end_date &&
            x.end_date &&
            x.end_date.valueOf() === $.end_date.valueOf()
          )
            return !0;
        } else if (
          $.start_date &&
          x.start_date &&
          x.start_date.valueOf() === $.start_date.valueOf()
        )
          return !0;
      }
      function v(x) {
        if (x.auto_scheduling === !1) return;
        const $ = t.config.constraint_types,
          S = [$.SNLT, $.FNLT, $.MSO, $.MFO],
          T = [$.SNET, $.FNET, $.MSO, $.MFO];
        t.config.schedule_from_end
          ? S.indexOf(x.constraint_type) > -1
            ? x.constraint_type == $.SNLT || x.constraint_type == $.MSO
              ? (x.constraint_date = new Date(x.start_date))
              : (x.constraint_date = new Date(x.end_date))
            : ((x.constraint_type = $.FNLT),
              (x.constraint_date = new Date(x.end_date)))
          : T.indexOf(x.constraint_type) > -1
          ? x.constraint_type == $.SNET || x.constraint_type == $.MSO
            ? (x.constraint_date = new Date(x.start_date))
            : (x.constraint_date = new Date(x.end_date))
          : ((x.constraint_type = $.SNET),
            (x.constraint_date = new Date(x.start_date)));
      }
      function b(x) {
        t.config.auto_scheduling_compatibility &&
          ((x.constraint_type !== t.config.constraint_types.SNET &&
            x.constraint_type !== t.config.constraint_types.FNLT) ||
            ((x.constraint_type = null), (x.constraint_date = null)));
      }
      t.attachEvent("onAfterBatchUpdate", function () {
        o && t.autoSchedule(), (o = !1);
      }),
        t.attachEvent("onAfterLinkUpdate", l),
        t.attachEvent("onAfterLinkAdd", l),
        t.attachEvent("onAfterLinkDelete", function (x, $) {
          if (
            t.config.auto_scheduling &&
            !t._autoscheduling_in_progress &&
            t.isTaskExists($.target)
          ) {
            const S = t.getTask($.target),
              T = t._getPredecessors(S);
            T.length &&
              (t.getState().batch_update
                ? (o = !0)
                : t.autoSchedule(T[0].source, !1));
          }
        }),
        t.attachEvent("onParse", function () {
          t.config.auto_scheduling &&
            t.config.auto_scheduling_initial &&
            t.autoSchedule();
        }),
        t.attachEvent("onBeforeLinkAdd", d),
        t.attachEvent("onBeforeLinkAdd", c),
        t.attachEvent("onBeforeLinkUpdate", d),
        t.attachEvent("onBeforeLinkUpdate", c),
        t.attachEvent("onBeforeTaskDrag", function (x, $, S) {
          return (
            t.config.auto_scheduling &&
              (t.getState().drag_mode !== "progress" && (r = _(x)), (s = x)),
            !0
          );
        });
      const g = function (x, $) {
        const S = t.getTask(x);
        y(S, $) || v(S);
      };
      let m,
        p = null;
      if (t.ext && t.ext.inlineEditors) {
        const x = t.ext.inlineEditors,
          $ = {
            start_date: !0,
            end_date: !0,
            duration: !0,
            constraint_type: !0,
            constraint_date: !0,
          };
        x.attachEvent("onBeforeSave", function (S) {
          if ($[S.columnName]) {
            (p = S.id), S.columnName === "constraint_type" && (m = !0);
            const T = S.columnName === "duration",
              E = t.config.schedule_from_end && S.columnName === "start_date",
              C = !t.config.schedule_from_end && S.columnName === "end_date",
              D =
                t.config.inline_editors_date_processing !== "keepDuration" &&
                (E || C),
              A = S.columnName === "constraint_date";
            (T || D || A) && (t.getTask(S.id).$keep_constraints = !0);
          }
          return !0;
        });
      }
      const k = {};
      let w;
      t.attachEvent("onBeforeTaskChanged", function (x, $, S) {
        return g(x, S), (k[x] = S), !0;
      }),
        t.attachEvent("onAfterTaskDrag", function (x, $, S) {
          x === s &&
            (clearTimeout(w),
            (w = setTimeout(function () {
              (function (T, E) {
                if (
                  t.config.auto_scheduling &&
                  !t._autoscheduling_in_progress
                ) {
                  const C = t.getTask(T),
                    D =
                      t.config.auto_scheduling_use_progress &&
                      (E.progress === 1) != (C.progress === 1);
                  if (h(E, C)) {
                    if (
                      (g(T, E),
                      t.config.auto_scheduling_move_projects && s == T)
                    ) {
                      let A = !0;
                      t.calculateDuration(E) !== t.calculateDuration(C) &&
                        (f(T, r), (A = !1)),
                        D
                          ? t.autoSchedule()
                          : (A && f(T, r), t._autoSchedule(T, r));
                    } else t.autoSchedule(C.id);
                    b(C);
                  }
                }
                (r = null), (s = null);
              })(x, k[x]);
            })));
        }),
        t.ext.inlineEditors &&
          t.ext.inlineEditors.attachEvent("onBeforeSave", function (x) {
            if (t.config.auto_scheduling && !t._autoscheduling_in_progress) {
              const $ = t.ext.inlineEditors.getEditorConfig(x.columnName);
              ($.map_to !== "start_date" &&
                $.map_to !== "end_date" &&
                $.map_to !== "duration") ||
                (p = x.id);
            }
            return !0;
          }),
        t.attachEvent("onLightboxSave", function (x, $) {
          if (t.config.auto_scheduling && !t._autoscheduling_in_progress) {
            m = !1;
            const S = t.getTask(x);
            h($, S) &&
              ((p = x),
              y($, S) && ($.$keep_constraints = !0),
              (t.getConstraintType($) === t.getConstraintType(S) &&
                +$.constraint_date == +S.constraint_date) ||
                (m = !0));
          }
          return !0;
        }),
        t.attachEvent("onAfterTaskUpdate", function (x, $) {
          return (
            t.config.auto_scheduling &&
              !t._autoscheduling_in_progress &&
              p !== null &&
              p == x &&
              ((p = null),
              $.$keep_constraints ? delete $.$keep_constraints : m || v($),
              t.autoSchedule($.id),
              m || b($)),
            !0
          );
        });
    };
    t.attachEvent(
      "onGanttReady",
      function () {
        a();
      },
      { once: !0 }
    );
  }
  function Y(t) {
    var n = 0,
      e = 0,
      i = 0,
      a = 0;
    if (t.getBoundingClientRect) {
      var r = t.getBoundingClientRect(),
        s = document.body,
        o =
          document.documentElement || document.body.parentNode || document.body,
        l = window.pageYOffset || o.scrollTop || s.scrollTop,
        d = window.pageXOffset || o.scrollLeft || s.scrollLeft,
        c = o.clientTop || s.clientTop || 0,
        u = o.clientLeft || s.clientLeft || 0;
      (n = r.top + l - c),
        (e = r.left + d - u),
        (i = document.body.offsetWidth - r.right),
        (a = document.body.offsetHeight - r.bottom);
    } else {
      for (; t; )
        (n += parseInt(t.offsetTop, 10)),
          (e += parseInt(t.offsetLeft, 10)),
          (t = t.offsetParent);
      (i = document.body.offsetWidth - t.offsetWidth - e),
        (a = document.body.offsetHeight - t.offsetHeight - n);
    }
    return {
      y: Math.round(n),
      x: Math.round(e),
      width: t.offsetWidth,
      height: t.offsetHeight,
      right: Math.round(i),
      bottom: Math.round(a),
    };
  }
  function li(t) {
    var n = !1,
      e = !1;
    if (window.getComputedStyle) {
      var i = window.getComputedStyle(t, null);
      (n = i.display), (e = i.visibility);
    } else t.currentStyle && ((n = t.currentStyle.display), (e = t.currentStyle.visibility));
    return n != "none" && e != "hidden";
  }
  function di(t) {
    return (
      !isNaN(t.getAttribute("tabindex")) && 1 * t.getAttribute("tabindex") >= 0
    );
  }
  function ci(t) {
    return (
      !{ a: !0, area: !0 }[t.nodeName.loLowerCase()] || !!t.getAttribute("href")
    );
  }
  function ui(t) {
    return (
      !{ input: !0, select: !0, textarea: !0, button: !0, object: !0 }[
        t.nodeName.toLowerCase()
      ] || !t.hasAttribute("disabled")
    );
  }
  function zt(t) {
    for (
      var n = t.querySelectorAll(
          [
            "a[href]",
            "area[href]",
            "input",
            "select",
            "textarea",
            "button",
            "iframe",
            "object",
            "embed",
            "[tabindex]",
            "[contenteditable]",
          ].join(", ")
        ),
        e = Array.prototype.slice.call(n, 0),
        i = 0;
      i < e.length;
      i++
    )
      e[i].$position = i;
    for (
      e.sort(function (r, s) {
        return r.tabIndex === 0 && s.tabIndex !== 0
          ? 1
          : r.tabIndex !== 0 && s.tabIndex === 0
          ? -1
          : r.tabIndex === s.tabIndex
          ? r.$position - s.$position
          : r.tabIndex < s.tabIndex
          ? -1
          : 1;
      }),
        i = 0;
      i < e.length;
      i++
    ) {
      var a = e[i];
      ((di(a) || ui(a) || ci(a)) && li(a)) || (e.splice(i, 1), i--);
    }
    return e;
  }
  function on() {
    var t = document.createElement("div");
    (t.style.cssText =
      "visibility:hidden;position:absolute;left:-1000px;width:100px;padding:0px;margin:0px;height:110px;min-height:100px;overflow-y:scroll;"),
      document.body.appendChild(t);
    var n = t.offsetWidth - t.clientWidth;
    return document.body.removeChild(t), Math.max(n, 15);
  }
  function it(t) {
    if (!t) return "";
    var n = t.className || "";
    return n.baseVal && (n = n.baseVal), n.indexOf || (n = ""), be(n);
  }
  function $t(t, n) {
    n && t.className.indexOf(n) === -1 && (t.className += " " + n);
  }
  function Pt(t, n) {
    n = n.split(" ");
    for (var e = 0; e < n.length; e++) {
      var i = new RegExp("\\s?\\b" + n[e] + "\\b(?![-_.])", "");
      t.className = t.className.replace(i, "");
    }
  }
  function ye(t) {
    return typeof t == "string"
      ? document.getElementById(t) || document.querySelector(t) || document.body
      : t || document.body;
  }
  function ln(t, n) {
    Zt || (Zt = document.createElement("div")), (Zt.innerHTML = n);
    var e = Zt.firstChild;
    return t.appendChild(e), e;
  }
  function dn(t) {
    t && t.parentNode && t.parentNode.removeChild(t);
  }
  function cn(t, n) {
    for (var e = t.childNodes, i = e.length, a = [], r = 0; r < i; r++) {
      var s = e[r];
      s.className && s.className.indexOf(n) !== -1 && a.push(s);
    }
    return a;
  }
  function Et(t) {
    var n;
    return (
      t.tagName
        ? (n = t)
        : (n = (t = t || window.event).target || t.srcElement).shadowRoot &&
          t.composedPath &&
          (n = t.composedPath()[0]),
      n
    );
  }
  function Q(t, n) {
    if (n) {
      for (var e = Et(t); e; ) {
        if (e.getAttribute && e.getAttribute(n)) return e;
        e = e.parentNode || e.host;
      }
      return null;
    }
  }
  function be(t) {
    return (
      String.prototype.trim ||
      function () {
        return this.replace(/^\s+|\s+$/g, "");
      }
    ).apply(t);
  }
  function mt(t, n, e) {
    var i = Et(t),
      a = "";
    for (e === void 0 && (e = !0); i; ) {
      if ((a = it(i))) {
        var r = a.indexOf(n);
        if (r >= 0) {
          if (!e) return i;
          var s = r === 0 || !be(a.charAt(r - 1)),
            o = r + n.length >= a.length || !be(a.charAt(r + n.length));
          if (s && o) return i;
        }
      }
      i = i.parentNode;
    }
    return null;
  }
  function lt(t, n) {
    var s;
    const e = document.documentElement,
      i = Y(n),
      { clientX: a, clientY: r } =
        ((s = t.touches) == null ? void 0 : s[0]) ?? t;
    return {
      x: a + e.scrollLeft - e.clientLeft - i.x + n.scrollLeft,
      y: r + e.scrollTop - e.clientTop - i.y + n.scrollTop,
    };
  }
  function un(t, n) {
    const e = Y(t),
      i = Y(n);
    return { x: e.x - i.x, y: e.y - i.y };
  }
  function tt(t, n) {
    if (!t || !n) return !1;
    for (; t && t != n; ) t = t.parentNode;
    return t === n;
  }
  function dt(t, n) {
    if (t.closest) return t.closest(n);
    if (t.matches || t.msMatchesSelector || t.webkitMatchesSelector) {
      var e = t;
      if (!document.documentElement.contains(e)) return null;
      do {
        if (
          (e.matches || e.msMatchesSelector || e.webkitMatchesSelector).call(
            e,
            n
          )
        )
          return e;
        e = e.parentElement || e.parentNode;
      } while (e !== null && e.nodeType === 1);
      return null;
    }
    return console.error("Your browser is not supported"), null;
  }
  function hn(t) {
    for (; t; ) {
      if (t.offsetWidth > 0 && t.offsetHeight > 0) return t;
      t = t.parentElement;
    }
    return null;
  }
  function _n() {
    return document.head.createShadowRoot || document.head.attachShadow;
  }
  function $e() {
    var t = document.activeElement;
    return (
      t.shadowRoot && (t = t.shadowRoot.activeElement),
      t === document.body &&
        document.getSelection &&
        (t = document.getSelection().focusNode || document.body),
      t
    );
  }
  function Ct(t) {
    if (!t || !_n()) return document.body;
    for (; t.parentNode && (t = t.parentNode); )
      if (t instanceof ShadowRoot) return t.host;
    return document.body;
  }
  const gn = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          addClassName: $t,
          closest: dt,
          getActiveElement: $e,
          getChildNodes: cn,
          getClassName: it,
          getClosestSizedElement: hn,
          getFocusableNodes: zt,
          getNodePosition: Y,
          getRelativeEventPosition: lt,
          getRelativeNodePosition: un,
          getRootNode: Ct,
          getScrollSize: on,
          getTargetNode: Et,
          hasClass: function (t, n) {
            return "classList" in t
              ? t.classList.contains(n)
              : new RegExp("\\b" + n + "\\b").test(t.className);
          },
          hasShadowParent: function (t) {
            return !!Ct(t);
          },
          insertNode: ln,
          isChildOf: tt,
          isShadowDomSupported: _n,
          locateAttribute: Q,
          locateClassName: mt,
          removeClassName: Pt,
          removeNode: dn,
          toNode: ye,
        },
        Symbol.toStringTag,
        { value: "Module" }
      )
    ),
    J = typeof window < "u" ? window : global;
  let hi = class {
    constructor(t) {
      (this._mouseDown = !1),
        (this._touchStarts = !1),
        (this._touchActive = !1),
        (this._longTapTimer = !1),
        (this._gantt = t),
        (this._domEvents = t._createDomEventScope());
    }
    attach(t, n, e) {
      const i = this._gantt,
        a = t.getViewPort();
      (this._originPosition = J.getComputedStyle(a).display),
        (this._restoreOriginPosition = () => {
          a.style.position = this._originPosition;
        }),
        this._originPosition === "static" && (a.style.position = "relative");
      const r = i.$services.getService("state");
      r.registerProvider("clickDrag", () => ({ autoscroll: !1 }));
      let s = null;
      const o = () => {
        s &&
          ((this._mouseDown = !0),
          t.setStart(i.copy(s)),
          t.setPosition(i.copy(s)),
          t.setEnd(i.copy(s)),
          (s = null));
      };
      this._domEvents.attach(a, "mousedown", (f) => {
        u(f);
      });
      const l = Ct(i.$root) || document.body;
      function d(f) {
        return (f.changedTouches && f.changedTouches[0]) || f;
      }
      this._domEvents.attach(l, "mouseup", (f) => {
        h(f);
      }),
        this._domEvents.attach(a, "mousemove", (f) => {
          _(f);
        }),
        this._domEvents.attach(a, "touchstart", (f) => {
          (this._touchStarts = !0),
            (this._longTapTimer = setTimeout(() => {
              this._touchStarts &&
                (u(d(f)), (this._touchStarts = !1), (this._touchActive = !0));
            }, this._gantt.config.touch_drag));
        }),
        this._domEvents.attach(l, "touchend", (f) => {
          (this._touchStarts = !1),
            (this._touchActive = !1),
            clearTimeout(this._longTapTimer),
            h(d(f));
        }),
        this._domEvents.attach(a, "touchmove", (f) => {
          if (this._touchActive) {
            let y = c();
            if (y && i.utils.dom.closest(f.target, y)) return;
            _(d(f)), f.preventDefault();
          } else (this._touchStarts = !1), clearTimeout(this._longTapTimer);
        });
      const c = () => {
          let f = ".gantt_task_line, .gantt_task_link";
          return e !== void 0 && (f = e instanceof Array ? e.join(", ") : e), f;
        },
        u = (f) => {
          s = null;
          let y = c();
          (y && i.utils.dom.closest(f.target, y)) ||
            (r.registerProvider("clickDrag", () => ({
              autoscroll: this._mouseDown,
            })),
            (n && f[n] !== !0) || (s = this._getCoordinates(f, t)));
        },
        h = (f) => {
          if (((s = null), (!n || f[n] === !0) && this._mouseDown === !0)) {
            this._mouseDown = !1;
            const y = this._getCoordinates(f, t);
            t.dragEnd(y);
          }
        },
        _ = (f) => {
          if (n && f[n] !== !0) return;
          const y = this._gantt.ext.clickDrag,
            v = (this._gantt.config.drag_timeline || {}).useKey;
          if (y && v && !n && f[v]) return;
          let b = null;
          if (!this._mouseDown && s)
            return (
              (b = this._getCoordinates(f, t)),
              void (Math.abs(s.relative.left - b.relative.left) > 5 && o())
            );
          this._mouseDown === !0 &&
            ((b = this._getCoordinates(f, t)), t.setEnd(b), t.render());
        };
    }
    detach() {
      const t = this._gantt;
      this._domEvents.detachAll(),
        this._restoreOriginPosition && this._restoreOriginPosition(),
        t.$services.getService("state").unregisterProvider("clickDrag");
    }
    destructor() {
      this.detach();
    }
    _getCoordinates(t, n) {
      const e = n.getViewPort(),
        i = e.getBoundingClientRect(),
        { clientX: a, clientY: r } = t;
      return {
        absolute: { left: a, top: r },
        relative: {
          left: a - i.left + e.scrollLeft,
          top: r - i.top + e.scrollTop,
        },
      };
    }
  };
  var fn = function () {
    (this._silent_mode = !1), (this.listeners = {});
  };
  fn.prototype = {
    _silentStart: function () {
      this._silent_mode = !0;
    },
    _silentEnd: function () {
      this._silent_mode = !1;
    },
  };
  function ct(t) {
    var n = new fn();
    (t.attachEvent = function (e, i, a) {
      (e = "ev_" + e.toLowerCase()),
        n.listeners[e] ||
          (n.listeners[e] = (function (s) {
            var o = {},
              l = 0,
              d = function () {
                var c = !0;
                for (var u in o) {
                  var h = o[u].apply(s, arguments);
                  c = c && h;
                }
                return c;
              };
            return (
              (d.addEvent = function (c, u) {
                if (typeof c == "function") {
                  var h;
                  if ((u && u.id ? (h = u.id) : ((h = l), l++), u && u.once)) {
                    var _ = c;
                    c = function () {
                      _(), d.removeEvent(h);
                    };
                  }
                  return (o[h] = c), h;
                }
                return !1;
              }),
              (d.removeEvent = function (c) {
                delete o[c];
              }),
              (d.clear = function () {
                o = {};
              }),
              d
            );
          })(this)),
        a && a.thisObject && (i = i.bind(a.thisObject));
      var r = e + ":" + n.listeners[e].addEvent(i, a);
      return a && a.id && (r = a.id), r;
    }),
      (t.attachAll = function (e) {
        this.attachEvent("listen_all", e);
      }),
      (t.callEvent = function (e, i) {
        if (n._silent_mode) return !0;
        var a = "ev_" + e.toLowerCase(),
          r = n.listeners;
        return (
          r.ev_listen_all && r.ev_listen_all.apply(this, [e].concat(i)),
          !r[a] || r[a].apply(this, i)
        );
      }),
      (t.checkEvent = function (e) {
        return !!n.listeners["ev_" + e.toLowerCase()];
      }),
      (t.detachEvent = function (e) {
        if (e) {
          var i = n.listeners;
          for (var a in i) i[a].removeEvent(e);
          var r = e.split(":");
          if (((i = n.listeners), r.length === 2)) {
            var s = r[0],
              o = r[1];
            i[s] && i[s].removeEvent(o);
          }
        }
      }),
      (t.detachAllEvents = function () {
        for (var e in n.listeners) n.listeners[e].clear();
      });
  }
  class _i {
    constructor(n, e, i) {
      var a;
      (this._el = document.createElement("div")),
        (this.defaultRender = (r, s) => {
          this._el || (this._el = document.createElement("div"));
          const o = this._el,
            l = Math.min(r.relative.top, s.relative.top),
            d = Math.max(r.relative.top, s.relative.top),
            c = Math.min(r.relative.left, s.relative.left),
            u = Math.max(r.relative.left, s.relative.left);
          if (this._singleRow) {
            const h = this._getTaskPositionByTop(this._startPoint.relative.top);
            (o.style.height = h.height + "px"), (o.style.top = h.top + "px");
          } else
            (o.style.height = Math.abs(d - l) + "px"), (o.style.top = l + "px");
          return (
            (o.style.width = Math.abs(u - c) + "px"),
            (o.style.left = c + "px"),
            o
          );
        }),
        (this._gantt = e),
        (this._view = i),
        (this._viewPort = n.viewPort),
        this._el.classList.add(n.className),
        typeof n.callback == "function" && (this._callback = n.callback),
        (this.render = () => {
          let r;
          (r = n.render
            ? n.render(this._startPoint, this._endPoint)
            : this.defaultRender(this._startPoint, this._endPoint)),
            r !== this._el &&
              (this._el &&
                this._el.parentNode &&
                this._el.parentNode.removeChild(this._el),
              (this._el = r)),
            n.className !== "" && this._el.classList.add(n.className),
            this.draw();
        }),
        ((a = this._viewPort).attachEvent && a.detachEvent) ||
          ct(this._viewPort),
        (this._singleRow = n.singleRow),
        (this._useRequestAnimationFrame = n.useRequestAnimationFrame);
    }
    draw() {
      if (this._useRequestAnimationFrame)
        return requestAnimationFrame(() => {
          this._viewPort.appendChild(this.getElement());
        });
      this._viewPort.appendChild(this.getElement());
    }
    clear() {
      if (this._useRequestAnimationFrame)
        return requestAnimationFrame(() => {
          this._el.parentNode && this._viewPort.removeChild(this._el);
        });
      this._el.parentNode && this._viewPort.removeChild(this._el);
    }
    getElement() {
      return this._el;
    }
    getViewPort() {
      return this._viewPort;
    }
    setStart(n) {
      const e = this._gantt;
      (this._startPoint = n),
        (this._startDate = e.dateFromPos(this._startPoint.relative.left)),
        this._viewPort.callEvent("onBeforeDrag", [this._startPoint]);
    }
    setEnd(n) {
      const e = this._gantt;
      if (((this._endPoint = n), this._singleRow)) {
        const i = this._getTaskPositionByTop(this._startPoint.relative.top);
        this._endPoint.relative.top = i.top;
      }
      (this._endDate = e.dateFromPos(this._endPoint.relative.left)),
        this._startPoint.relative.left > this._endPoint.relative.left &&
          (this._positionPoint = {
            relative: {
              left: this._endPoint.relative.left,
              top: this._positionPoint.relative.top,
            },
            absolute: {
              left: this._endPoint.absolute.left,
              top: this._positionPoint.absolute.top,
            },
          }),
        this._startPoint.relative.top > this._endPoint.relative.top &&
          (this._positionPoint = {
            relative: {
              left: this._positionPoint.relative.left,
              top: this._endPoint.relative.top,
            },
            absolute: {
              left: this._positionPoint.absolute.left,
              top: this._endPoint.absolute.top,
            },
          }),
        this._viewPort.callEvent("onDrag", [this._startPoint, this._endPoint]);
    }
    setPosition(n) {
      this._positionPoint = n;
    }
    dragEnd(n) {
      const e = this._gantt;
      n.relative.left < 0 && (n.relative.left = 0),
        this._viewPort.callEvent("onBeforeDragEnd", [this._startPoint, n]),
        this.setEnd(n),
        (this._endDate = this._endDate || e.getState().max_date),
        this._startDate.valueOf() > this._endDate.valueOf() &&
          ([this._startDate, this._endDate] = [this._endDate, this._startDate]),
        this.clear();
      const i = e.getTaskByTime(this._startDate, this._endDate),
        a = this._getTasksByTop(
          this._startPoint.relative.top,
          this._endPoint.relative.top
        );
      this._viewPort.callEvent("onDragEnd", [this._startPoint, this._endPoint]),
        this._callback &&
          this._callback(
            this._startPoint,
            this._endPoint,
            this._startDate,
            this._endDate,
            i,
            a
          );
    }
    getInBounds() {
      return this._singleRow;
    }
    _getTasksByTop(n, e) {
      const i = this._gantt;
      let a = n,
        r = e;
      n > e && ((a = e), (r = n));
      const s = this._getTaskPositionByTop(a).index,
        o = this._getTaskPositionByTop(r).index,
        l = [];
      for (let d = s; d <= o; d++)
        i.getTaskByIndex(d) && l.push(i.getTaskByIndex(d));
      return l;
    }
    _getTaskPositionByTop(n) {
      const e = this._gantt,
        i = this._view,
        a = i.getItemIndexByTopPosition(n),
        r = e.getTaskByIndex(a);
      if (r) {
        const s = i.getItemHeight(r.id);
        return { top: i.getItemTop(r.id) || 0, height: s || 0, index: a };
      }
      {
        const s = i.getTotalHeight();
        return {
          top: n > s ? s : 0,
          height: e.config.row_height,
          index: n > s ? e.getTaskCount() : 0,
        };
      }
    }
  }
  let xe = !1;
  class Qt {
    constructor(n) {
      (this._mouseDown = !1),
        (this._calculateDirectionVector = () => {
          if (this._trace.length >= 10) {
            const e = this._trace.slice(this._trace.length - 10),
              i = [];
            for (let r = 1; r < e.length; r++)
              i.push({ x: e[r].x - e[r - 1].x, y: e[r].y - e[r - 1].y });
            const a = { x: 0, y: 0 };
            return (
              i.forEach((r) => {
                (a.x += r.x), (a.y += r.y);
              }),
              {
                magnitude: Math.sqrt(a.x * a.x + a.y * a.y),
                angleDegrees:
                  (180 * Math.atan2(Math.abs(a.y), Math.abs(a.x))) / Math.PI,
              }
            );
          }
          return null;
        }),
        (this._applyDndReadyStyles = () => {
          this._timeline.$task.classList.add("gantt_timeline_move_available");
        }),
        (this._clearDndReadyStyles = () => {
          this._timeline.$task.classList.remove(
            "gantt_timeline_move_available"
          );
        }),
        (this._getScrollPosition = (e) => {
          const i = this._gantt;
          return {
            x: i.$ui.getView(e.$config.scrollX).getScrollState().position,
            y: i.$ui.getView(e.$config.scrollY).getScrollState().position,
          };
        }),
        (this._countNewScrollPosition = (e) => {
          const i = this._calculateDirectionVector();
          let a = this._startPoint.x - e.x,
            r = this._startPoint.y - e.y;
          return (
            i &&
              (i.angleDegrees < 15 ? (r = 0) : i.angleDegrees > 75 && (a = 0)),
            { x: this._scrollState.x + a, y: this._scrollState.y + r }
          );
        }),
        (this._setScrollPosition = (e, i) => {
          const a = this._gantt;
          requestAnimationFrame(() => {
            a.scrollLayoutCell(e.$id, i.x, i.y);
          });
        }),
        (this._stopDrag = (e) => {
          const i = this._gantt;
          if (
            ((this._trace = []),
            i.$root.classList.remove("gantt_noselect"),
            this._originalReadonly !== void 0 &&
              this._mouseDown &&
              ((i.config.readonly = this._originalReadonly),
              i.config.drag_timeline &&
                i.config.drag_timeline.render &&
                i.render()),
            this._originAutoscroll !== void 0 &&
              (i.config.autoscroll = this._originAutoscroll),
            i.config.drag_timeline)
          ) {
            const { useKey: a } = i.config.drag_timeline;
            if (a && e[a] !== !0) return;
          }
          (this._mouseDown = !1), (xe = !1);
        }),
        (this._startDrag = (e) => {
          const i = this._gantt;
          (this._originAutoscroll = i.config.autoscroll),
            (i.config.autoscroll = !1),
            (xe = !0),
            i.$root.classList.add("gantt_noselect"),
            (this._originalReadonly = i.config.readonly),
            (i.config.readonly = !0),
            i.config.drag_timeline &&
              i.config.drag_timeline.render &&
              i.render(),
            (this._trace = []),
            (this._mouseDown = !0);
          const { x: a, y: r } = this._getScrollPosition(this._timeline);
          (this._scrollState = { x: a, y: r }),
            (this._startPoint = { x: e.clientX, y: e.clientY }),
            this._trace.push(this._startPoint);
        }),
        (this._gantt = n),
        (this._domEvents = n._createDomEventScope()),
        (this._trace = []);
    }
    static create(n) {
      return new Qt(n);
    }
    static _isDragInProgress() {
      return xe;
    }
    destructor() {
      this._domEvents.detachAll();
    }
    attach(n) {
      this._timeline = n;
      const e = this._gantt;
      this._domEvents.attach(n.$task, "mousedown", (i) => {
        if (!e.config.drag_timeline) return;
        const { useKey: a, ignore: r, enabled: s } = e.config.drag_timeline;
        if (s === !1) return;
        let o = ".gantt_task_line, .gantt_task_link";
        r !== void 0 && (o = r instanceof Array ? r.join(", ") : r),
          (o && e.utils.dom.closest(i.target, o)) ||
            (a && i[a] !== !0) ||
            this._startDrag(i);
      }),
        this._domEvents.attach(document, "keydown", (i) => {
          if (!e.config.drag_timeline) return;
          const { useKey: a } = e.config.drag_timeline;
          a && i[a] === !0 && this._applyDndReadyStyles();
        }),
        this._domEvents.attach(document, "keyup", (i) => {
          if (!e.config.drag_timeline) return;
          const { useKey: a } = e.config.drag_timeline;
          a && i[a] === !1 && (this._clearDndReadyStyles(), this._stopDrag(i));
        }),
        this._domEvents.attach(document, "mouseup", (i) => {
          this._stopDrag(i);
        }),
        this._domEvents.attach(e.$root, "mouseup", (i) => {
          this._stopDrag(i);
        }),
        this._domEvents.attach(document, "mouseleave", (i) => {
          this._stopDrag(i);
        }),
        this._domEvents.attach(e.$root, "mouseleave", (i) => {
          this._stopDrag(i);
        }),
        this._domEvents.attach(e.$root, "mousemove", (i) => {
          if (!e.config.drag_timeline) return;
          const { useKey: a } = e.config.drag_timeline;
          if (a && i[a] !== !0) return;
          const r = this._gantt.ext.clickDrag,
            s = (this._gantt.config.click_drag || {}).useKey;
          if ((!r || !s || a || !i[s]) && this._mouseDown === !0) {
            this._trace.push({ x: i.clientX, y: i.clientY });
            const o = this._countNewScrollPosition({
              x: i.clientX,
              y: i.clientY,
            });
            this._setScrollPosition(n, o),
              (this._scrollState = o),
              (this._startPoint = { x: i.clientX, y: i.clientY });
          }
        });
    }
  }
  function gi(t) {
    (function () {
      var n = [];
      function e() {
        return !!n.length;
      }
      function i(d) {
        setTimeout(function () {
          e() || t.$destroyed || t.focus();
        }, 1);
      }
      function a(d) {
        t.eventRemove(d, "keydown", s), t.event(d, "keydown", s), n.push(d);
      }
      function r() {
        var d = n.pop();
        d && t.eventRemove(d, "keydown", s), i();
      }
      function s(d) {
        var c = d.currentTarget;
        c == n[n.length - 1] && t.$keyboardNavigation.trapFocus(c, d);
      }
      function o() {
        a(t.getLightbox());
      }
      t.attachEvent("onLightbox", o),
        t.attachEvent("onAfterLightbox", r),
        t.attachEvent("onLightboxChange", function () {
          r(), o();
        }),
        t.attachEvent("onAfterQuickInfo", function () {
          i();
        }),
        t.attachEvent("onMessagePopup", function (d) {
          (l = t.utils.dom.getActiveElement()), a(d);
        }),
        t.attachEvent("onAfterMessagePopup", function () {
          r(),
            setTimeout(function () {
              l && l.focus && (l.focus(), (l = null));
            }, 1);
        });
      var l = null;
      t.$keyboardNavigation.isModal = e;
    })();
  }
  class fi {
    constructor(n) {
      (this.show = (e, i) => {
        i === void 0 ? this._showForTask(e) : this._showAtCoordinates(e, i);
      }),
        (this.hide = (e) => {
          const i = this._gantt,
            a = this._quickInfoBox;
          this._quickInfoBoxId = 0;
          const r = this._quickInfoTask;
          if (((this._quickInfoTask = null), a && a.parentNode)) {
            if (i.config.quick_info_detached)
              return (
                i.callEvent("onAfterQuickInfo", [r]),
                a.parentNode.removeChild(a)
              );
            (a.className += " gantt_qi_hidden"),
              a.style.right === "auto"
                ? (a.style.left = "-350px")
                : (a.style.right = "-350px"),
              e &&
                ((a.style.left = a.style.right = ""),
                a.parentNode.removeChild(a)),
              i.callEvent("onAfterQuickInfo", [r]);
          }
        }),
        (this.getNode = () => (this._quickInfoBox ? this._quickInfoBox : null)),
        (this.setContainer = (e) => {
          e &&
            (this._container =
              typeof e == "string" ? document.getElementById(e) : e);
        }),
        (this.setContent = (e) => {
          const i = this._gantt,
            a = {
              taskId: null,
              header: { title: "", date: "" },
              content: "",
              buttons: i.config.quickinfo_buttons,
            };
          e || (e = a),
            e.taskId || (e.taskId = a.taskId),
            e.header || (e.header = a.header),
            e.header.title || (e.header.title = a.header.title),
            e.header.date || (e.header.date = a.header.date),
            e.content || (e.content = a.content),
            e.buttons || (e.buttons = a.buttons);
          let r = this.getNode();
          r || (r = this._createQuickInfoElement()),
            e.taskId && (this._quickInfoBoxId = e.taskId);
          const s = r.querySelector(".gantt_cal_qi_title"),
            o = s.querySelector(".gantt_cal_qi_tcontent"),
            l = s.querySelector(".gantt_cal_qi_tdate"),
            d = r.querySelector(".gantt_cal_qi_content"),
            c = r.querySelector(".gantt_cal_qi_controls");
          i._waiAria.quickInfoHeader(
            r,
            [e.header.title, e.header.date].join(" ")
          ),
            (o.innerHTML = e.header.title),
            (l.innerHTML = e.header.date),
            e.header.title || e.header.date
              ? (s.style.display = "")
              : (s.style.display = "none"),
            (d.innerHTML = e.content);
          const u = e.buttons;
          u.length ? (c.style.display = "") : (c.style.display = "none");
          let h = "";
          for (let _ = 0; _ < u.length; _++) {
            const f = i._waiAria.quickInfoButtonAttrString(
              i.locale.labels[u[_]]
            );
            h += `<div class="gantt_qi_big_icon ${u[_]} dhx_gantt_${
              u[_]
            }" title="${i.locale.labels[u[_]]}" ${f}>
            <div class='dhx_menu_icon dhx_gantt_icon ${
              u[_]
            } gantt_menu_icon dhx_gantt_${u[_]}'></div>
            <div>${i.locale.labels[u[_]]}</div>
         </div>`;
          }
          (c.innerHTML = h),
            i.eventRemove(r, "click", this._qiButtonClickHandler),
            i.eventRemove(r, "keypress", this._qiKeyPressHandler),
            i.event(r, "click", this._qiButtonClickHandler),
            i.event(r, "keypress", this._qiKeyPressHandler);
        }),
        (this._qiButtonClickHandler = (e) => {
          this._qi_button_click(e.target);
        }),
        (this._qiKeyPressHandler = (e) => {
          const i = e.which;
          (i !== 13 && i !== 32) ||
            setTimeout(() => {
              this._qi_button_click(e.target);
            }, 1);
        }),
        (this._gantt = n);
    }
    _showAtCoordinates(n, e) {
      this.hide(!0),
        (this._quickInfoBoxId = 0),
        (this._quickInfoTask = null),
        this._quickInfoBox ||
          (this._createQuickInfoElement(), this.setContent()),
        this._appendAtCoordinates(n, e),
        this._gantt.callEvent("onQuickInfo", [null]);
    }
    _showForTask(n) {
      const e = this._gantt;
      if (
        (n === this._quickInfoBoxId &&
          e.utils.dom.isChildOf(this._quickInfoBox, document.body)) ||
        !e.config.show_quick_info
      )
        return;
      this.hide(!0);
      const i = this._getContainer(),
        a = this._get_event_counter_part(n, 6, i.xViewport, i.yViewport);
      a &&
        ((this._quickInfoBox = this._init_quick_info(n)),
        (this._quickInfoTask = n),
        (this._quickInfoBox.className = this._prepare_quick_info_classname(n)),
        this._fill_quick_data(n),
        this._show_quick_info(a, 6),
        e.callEvent("onQuickInfo", [n]));
    }
    _get_event_counter_part(n, e, i, a) {
      const r = this._gantt;
      let s = r.getTaskNode(n);
      if (!s && ((s = r.getTaskRowNode(n)), !s)) return null;
      let o = 0;
      const l = e + s.offsetTop + s.offsetHeight;
      let d = s;
      if (r.utils.dom.isChildOf(d, i))
        for (; d && d !== i; ) (o += d.offsetLeft), (d = d.offsetParent);
      const c = r.getScrollState();
      return d
        ? {
            left: o,
            top: l,
            dx: o + s.offsetWidth / 2 - c.x > i.offsetWidth / 2 ? 1 : 0,
            dy: l + s.offsetHeight / 2 - c.y > a.offsetHeight / 2 ? 1 : 0,
            width: s.offsetWidth,
            height: s.offsetHeight,
          }
        : null;
    }
    _createQuickInfoElement() {
      const n = this._gantt,
        e = document.createElement("div");
      (e.className += "gantt_cal_quick_info"), n._waiAria.quickInfoAttr(e);
      var i = `
		<div class="gantt_cal_qi_tcontrols">
			<a class="gantt_cal_qi_close_btn dhx_gantt_icon dhx_gantt_icon_close"></a>
		</div>
		<div class="gantt_cal_qi_title" ${n._waiAria.quickInfoHeaderAttrString()}>
				
				<div class="gantt_cal_qi_tcontent"></div>
				<div class="gantt_cal_qi_tdate"></div>
			</div>
			<div class="gantt_cal_qi_content"></div>`;
      if (
        ((i += '<div class="gantt_cal_qi_controls">'),
        (i += "</div>"),
        (e.innerHTML = i),
        n.config.quick_info_detached)
      ) {
        const a = this._getContainer();
        n.event(a.parent, "scroll", () => {
          this.hide();
        });
      }
      return (this._quickInfoBox = e), e;
    }
    _init_quick_info(n) {
      const e = this._gantt,
        i = e.getTask(n);
      return (
        typeof this._quickInfoReadonly == "boolean" &&
          e.isReadonly(i) !== this._quickInfoReadonly &&
          (this.hide(!0), (this._quickInfoBox = null)),
        (this._quickInfoReadonly = e.isReadonly(i)),
        this._quickInfoBox ||
          (this._quickInfoBox = this._createQuickInfoElement()),
        this._quickInfoBox
      );
    }
    _prepare_quick_info_classname(n) {
      const e = this._gantt,
        i = e.getTask(n);
      let a = `gantt_cal_quick_info gantt_${e.getTaskType(i)}`;
      const r = e.templates.quick_info_class(i.start_date, i.end_date, i);
      return r && (a += " " + r), a;
    }
    _fill_quick_data(n) {
      const e = this._gantt,
        i = e.getTask(n);
      this._quickInfoBoxId = n;
      let a = [];
      if (this._quickInfoReadonly) {
        const r = e.config.quickinfo_buttons,
          s = { icon_delete: !0, icon_edit: !0 };
        for (let o = 0; o < r.length; o++)
          (this._quickInfoReadonly && s[r[o]]) || a.push(r[o]);
      } else a = e.config.quickinfo_buttons;
      this.setContent({
        header: {
          title: e.templates.quick_info_title(i.start_date, i.end_date, i),
          date: e.templates.quick_info_date(i.start_date, i.end_date, i),
        },
        content: e.templates.quick_info_content(i.start_date, i.end_date, i),
        buttons: a,
      });
    }
    _appendAtCoordinates(n, e) {
      const i = this._quickInfoBox,
        a = this._getContainer();
      (i.parentNode &&
        i.parentNode.nodeName.toLowerCase() !== "#document-fragment") ||
        a.parent.appendChild(i),
        (i.style.left = n + "px"),
        (i.style.top = e + "px");
    }
    _show_quick_info(n, e) {
      const i = this._gantt,
        a = this._quickInfoBox;
      if (i.config.quick_info_detached) {
        const r = this._getContainer();
        (a.parentNode &&
          a.parentNode.nodeName.toLowerCase() !== "#document-fragment") ||
          r.parent.appendChild(a);
        const s = a.offsetWidth,
          o = a.offsetHeight,
          l = i.getScrollState(),
          d = r.xViewport,
          c = r.yViewport,
          u = d.offsetWidth + l.x - s,
          h = n.top - l.y + o;
        let _ = n.top;
        h > c.offsetHeight / 2 &&
          ((_ = n.top - (o + n.height + 2 * e)),
          _ < l.y && h <= c.offsetHeight && (_ = n.top)),
          _ < l.y && (_ = l.y);
        const f = Math.min(Math.max(l.x, n.left - n.dx * (s - n.width)), u),
          y = _;
        this._appendAtCoordinates(f, y);
      } else
        (a.style.top = "20px"),
          n.dx === 1
            ? ((a.style.right = "auto"),
              (a.style.left = "-300px"),
              setTimeout(() => {
                a.style.left = "10px";
              }, 1))
            : ((a.style.left = "auto"),
              (a.style.right = "-300px"),
              setTimeout(() => {
                a.style.right = "10px";
              }, 1)),
          (a.className += " gantt_qi_" + (n.dx === 1 ? "left" : "right")),
          i.$root.appendChild(a);
    }
    _qi_button_click(n) {
      const e = this._gantt,
        i = this._quickInfoBox;
      if (!n || n === i) return;
      if (n.closest(".gantt_cal_qi_close_btn")) return void this.hide();
      const a = n.className;
      if (a.indexOf("_icon") !== -1) {
        const r = this._quickInfoBoxId;
        e.$click.buttons[a.split(" ")[1].replace("icon_", "")](r);
      } else this._qi_button_click(n.parentNode);
    }
    _getContainer() {
      const n = this._gantt;
      let e = this._container ? this._container : n.$task_data;
      return e && e.offsetHeight && e.offsetWidth
        ? { parent: e, xViewport: n.$task, yViewport: n.$task_data }
        : ((e = this._container ? this._container : n.$grid_data),
          e && e.offsetHeight && e.offsetWidth
            ? { parent: e, xViewport: n.$grid, yViewport: n.$grid_data }
            : {
                parent: this._container ? this._container : n.$layout,
                xViewport: n.$layout,
                yViewport: n.$layout,
              });
    }
  }
  var we,
    pi = {}.constructor.toString();
  function X(t) {
    var n, e;
    if (t && typeof t == "object")
      switch (!0) {
        case nt(t):
          e = new Date(t);
          break;
        case Lt(t):
          for (e = new Array(t.length), n = 0; n < t.length; n++)
            e[n] = X(t[n]);
          break;
        default:
          if (
            (function (i) {
              return i.constructor.toString() !== pi;
            })(t)
          )
            e = Object.create(t);
          else {
            if (
              (function (i) {
                return i.$$typeof && i.$$typeof.toString().includes("react.");
              })(t)
            )
              return (e = t);
            e = {};
          }
          for (n in t)
            Object.prototype.hasOwnProperty.apply(t, [n]) && (e[n] = X(t[n]));
      }
    return e || t;
  }
  function O(t, n, e) {
    for (var i in n) (t[i] === void 0 || e) && (t[i] = n[i]);
    return t;
  }
  function U(t) {
    return t !== void 0;
  }
  function ut() {
    return we || (we = new Date().valueOf()), ++we;
  }
  function z(t, n) {
    return t.bind
      ? t.bind(n)
      : function () {
          return t.apply(n, arguments);
        };
  }
  function pn(t, n, e, i) {
    t.addEventListener
      ? t.addEventListener(n, e, i !== void 0 && i)
      : t.attachEvent && t.attachEvent("on" + n, e);
  }
  function mn(t, n, e, i) {
    t.removeEventListener
      ? t.removeEventListener(n, e, i !== void 0 && i)
      : t.detachEvent && t.detachEvent("on" + n, e);
  }
  const vn = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        bind: z,
        copy: X,
        defined: U,
        event: pn,
        eventRemove: mn,
        mixin: O,
        uid: ut,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
  function Se(t, n) {
    (t = t || pn), (n = n || mn);
    var e = [],
      i = {
        attach: function (a, r, s, o) {
          e.push({ element: a, event: r, callback: s, capture: o }),
            t(a, r, s, o);
        },
        detach: function (a, r, s, o) {
          n(a, r, s, o);
          for (var l = 0; l < e.length; l++) {
            var d = e[l];
            d.element === a &&
              d.event === r &&
              d.callback === s &&
              d.capture === o &&
              (e.splice(l, 1), l--);
          }
        },
        detachAll: function () {
          for (var a = e.slice(), r = 0; r < a.length; r++) {
            var s = a[r];
            i.detach(s.element, s.event, s.callback, s.capture),
              i.detach(s.element, s.event, s.callback, void 0),
              i.detach(s.element, s.event, s.callback, !1),
              i.detach(s.element, s.event, s.callback, !0);
          }
          e.splice(0, e.length);
        },
        extend: function () {
          return Se(this.event, this.eventRemove);
        },
      };
    return i;
  }
  class mi {
    constructor(n) {
      this._gantt = n;
    }
    getNode() {
      const n = this._gantt;
      return (
        this._tooltipNode ||
          ((this._tooltipNode = document.createElement("div")),
          (this._tooltipNode.className = "gantt_tooltip"),
          n._waiAria.tooltipAttr(this._tooltipNode)),
        this._tooltipNode
      );
    }
    setViewport(n) {
      return (this._root = n), this;
    }
    show(n, e) {
      const i = this._gantt,
        a = document.body,
        r = this.getNode();
      if (
        (tt(r, a) ||
          (this.hide(),
          (r.style.top = r.style.top || "0px"),
          (r.style.left = r.style.left || "0px"),
          a.appendChild(r)),
        this._isLikeMouseEvent(n))
      ) {
        const s = this._calculateTooltipPosition(n);
        (e = s.top), (n = s.left);
      }
      return (
        (r.style.top = e + "px"),
        (r.style.left = n + "px"),
        i._waiAria.tooltipVisibleAttr(r),
        this
      );
    }
    hide() {
      const n = this._gantt,
        e = this.getNode();
      return (
        e && e.parentNode && e.parentNode.removeChild(e),
        n._waiAria.tooltipHiddenAttr(e),
        this
      );
    }
    setContent(n) {
      return (this.getNode().innerHTML = n), this;
    }
    _isLikeMouseEvent(n) {
      return !(!n || typeof n != "object") && "clientX" in n && "clientY" in n;
    }
    _getViewPort() {
      return this._root || document.body;
    }
    _calculateTooltipPosition(n) {
      const e = this._gantt,
        i = this._getViewPortSize(),
        a = this.getNode(),
        r = {
          top: 0,
          left: 0,
          width: a.offsetWidth,
          height: a.offsetHeight,
          bottom: 0,
          right: 0,
        },
        s = e.config.tooltip_offset_x,
        o = e.config.tooltip_offset_y,
        l = document.body,
        d = lt(n, l),
        c = Y(l);
      (d.y += c.y),
        (r.top = d.y),
        (r.left = d.x),
        (r.top += o),
        (r.left += s),
        (r.bottom = r.top + r.height),
        (r.right = r.left + r.width);
      const u = window.scrollY + l.scrollTop;
      return (
        r.top < i.top - u
          ? ((r.top = i.top), (r.bottom = r.top + r.height))
          : r.bottom > i.bottom &&
            ((r.bottom = i.bottom), (r.top = r.bottom - r.height)),
        r.left < i.left
          ? ((r.left = i.left), (r.right = i.left + r.width))
          : r.right > i.right &&
            ((r.right = i.right), (r.left = r.right - r.width)),
        d.x >= r.left &&
          d.x <= r.right &&
          ((r.left = d.x - r.width - s), (r.right = r.left + r.width)),
        d.y >= r.top &&
          d.y <= r.bottom &&
          ((r.top = d.y - r.height - o), (r.bottom = r.top + r.height)),
        r.left < 0 && (r.left = 0),
        r.right < 0 && (r.right = 0),
        r
      );
    }
    _getViewPortSize() {
      const n = this._gantt,
        e = this._getViewPort();
      let i,
        a = e,
        r = window.scrollY + document.body.scrollTop,
        s = window.scrollX + document.body.scrollLeft;
      return (
        e === n.$task_data
          ? ((a = n.$task), (r = 0), (s = 0), (i = Y(n.$task)))
          : (i = Y(a)),
        {
          left: i.x + s,
          top: i.y + r,
          width: i.width,
          height: i.height,
          bottom: i.y + i.height + r,
          right: i.x + i.width + s,
        }
      );
    }
  }
  class vi {
    constructor(n) {
      (this._listeners = {}),
        (this.tooltip = new mi(n)),
        (this._gantt = n),
        (this._domEvents = Se()),
        this._initDelayedFunctions();
    }
    destructor() {
      this.tooltip.hide(), this._domEvents.detachAll();
    }
    hideTooltip() {
      this.delayHide();
    }
    attach(n) {
      let e = document.body;
      const i = this._gantt;
      n.global || (e = i.$root);
      let a = null;
      const r = (s) => {
        const o = Et(s),
          l = dt(o, n.selector);
        if (tt(o, this.tooltip.getNode())) return;
        const d = () => {
          (a = l), n.onmouseenter(s, l);
        };
        a
          ? l && l === a
            ? n.onmousemove(s, l)
            : (n.onmouseleave(s, a), (a = null), l && l !== a && d())
          : l && d();
      };
      this.detach(n.selector),
        this._domEvents.attach(e, "mousemove", r),
        (this._listeners[n.selector] = { node: e, handler: r });
    }
    detach(n) {
      const e = this._listeners[n];
      e && this._domEvents.detach(e.node, "mousemove", e.handler);
    }
    tooltipFor(n) {
      const e = (i) => {
        let a = i;
        return (
          document.createEventObject &&
            !document.createEvent &&
            (a = document.createEventObject(i)),
          a
        );
      };
      this._initDelayedFunctions(),
        this.attach({
          selector: n.selector,
          global: n.global,
          onmouseenter: (i, a) => {
            const r = n.html(i, a);
            r && this.delayShow(e(i), r);
          },
          onmousemove: (i, a) => {
            const r = n.html(i, a);
            r
              ? this.delayShow(e(i), r)
              : (this.delayShow.$cancelTimeout(), this.delayHide());
          },
          onmouseleave: () => {
            this.delayShow.$cancelTimeout(), this.delayHide();
          },
        });
    }
    _initDelayedFunctions() {
      const n = this._gantt;
      this.delayShow && this.delayShow.$cancelTimeout(),
        this.delayHide && this.delayHide.$cancelTimeout(),
        this.tooltip.hide(),
        (this.delayShow = Xt((e, i) => {
          n.callEvent("onBeforeTooltip", [e]) === !1
            ? this.tooltip.hide()
            : (this.tooltip.setContent(i), this.tooltip.show(e));
        }, n.config.tooltip_timeout || 1)),
        (this.delayHide = Xt(() => {
          this.delayShow.$cancelTimeout(), this.tooltip.hide();
        }, n.config.tooltip_hide_timeout || 1));
    }
  }
  const kn = { onBeforeUndo: "onAfterUndo", onBeforeRedo: "onAfterRedo" },
    yn = [
      "onTaskDragStart",
      "onAfterTaskUpdate",
      "onAfterParentExpand",
      "onAfterTaskDelete",
      "onBeforeBatchUpdate",
    ];
  class ki {
    constructor(n, e) {
      (this._batchAction = null),
        (this._batchMode = !1),
        (this._ignore = !1),
        (this._ignoreMoveEvents = !1),
        (this._initialTasks = {}),
        (this._initialLinks = {}),
        (this._nestedTasks = {}),
        (this._nestedLinks = {}),
        (this._undo = n),
        (this._gantt = e),
        this._attachEvents();
    }
    store(n, e, i = !1) {
      return e === this._gantt.config.undo_types.task
        ? this._storeTask(n, i)
        : e === this._gantt.config.undo_types.link && this._storeLink(n, i);
    }
    isMoveEventsIgnored() {
      return this._ignoreMoveEvents;
    }
    toggleIgnoreMoveEvents(n) {
      this._ignoreMoveEvents = n || !1;
    }
    startIgnore() {
      this._ignore = !0;
    }
    stopIgnore() {
      this._ignore = !1;
    }
    startBatchAction() {
      this._timeout ||
        (this._timeout = setTimeout(() => {
          this.stopBatchAction(), (this._timeout = null);
        }, 10)),
        this._ignore ||
          this._batchMode ||
          ((this._batchMode = !0),
          (this._batchAction = this._undo.action.create()));
    }
    stopBatchAction() {
      if (this._ignore) return;
      const n = this._undo;
      this._batchAction && n.logAction(this._batchAction),
        (this._batchMode = !1),
        (this._batchAction = null);
    }
    onTaskAdded(n) {
      this._ignore || this._storeTaskCommand(n, this._undo.command.type.add);
    }
    onTaskUpdated(n) {
      this._ignore || this._storeTaskCommand(n, this._undo.command.type.update);
    }
    onTaskMoved(n) {
      this._ignore ||
        ((n.$local_index = this._gantt.getTaskIndex(n.id)),
        this._storeEntityCommand(
          n,
          this.getInitialTask(n.id),
          this._undo.command.type.move,
          this._undo.command.entity.task
        ));
    }
    onTaskDeleted(n) {
      if (!this._ignore) {
        if (
          (this._storeTaskCommand(n, this._undo.command.type.remove),
          this._nestedTasks[n.id])
        ) {
          const e = this._nestedTasks[n.id];
          for (let i = 0; i < e.length; i++)
            this._storeTaskCommand(e[i], this._undo.command.type.remove);
        }
        if (this._nestedLinks[n.id]) {
          const e = this._nestedLinks[n.id];
          for (let i = 0; i < e.length; i++)
            this._storeLinkCommand(e[i], this._undo.command.type.remove);
        }
      }
    }
    onLinkAdded(n) {
      this._ignore || this._storeLinkCommand(n, this._undo.command.type.add);
    }
    onLinkUpdated(n) {
      this._ignore || this._storeLinkCommand(n, this._undo.command.type.update);
    }
    onLinkDeleted(n) {
      this._ignore || this._storeLinkCommand(n, this._undo.command.type.remove);
    }
    setNestedTasks(n, e) {
      const i = this._gantt;
      let a = null;
      const r = [];
      let s = this._getLinks(i.getTask(n));
      for (let d = 0; d < e.length; d++)
        (a = this.setInitialTask(e[d])),
          (s = s.concat(this._getLinks(a))),
          r.push(a);
      const o = {};
      for (let d = 0; d < s.length; d++) o[s[d]] = !0;
      const l = [];
      for (const d in o) l.push(this.setInitialLink(d));
      (this._nestedTasks[n] = r), (this._nestedLinks[n] = l);
    }
    setInitialTask(n, e) {
      const i = this._gantt;
      if (e || !this._initialTasks[n] || !this._batchMode) {
        const a = i.copy(i.getTask(n));
        (a.$index = i.getGlobalTaskIndex(n)),
          (a.$local_index = i.getTaskIndex(n)),
          this.setInitialTaskObject(n, a);
      }
      return this._initialTasks[n];
    }
    getInitialTask(n) {
      return this._initialTasks[n];
    }
    clearInitialTasks() {
      this._initialTasks = {};
    }
    setInitialTaskObject(n, e) {
      this._initialTasks[n] = e;
    }
    setInitialLink(n, e) {
      return (
        (this._initialLinks[n] && this._batchMode) ||
          (this._initialLinks[n] = this._gantt.copy(this._gantt.getLink(n))),
        this._initialLinks[n]
      );
    }
    getInitialLink(n) {
      return this._initialLinks[n];
    }
    clearInitialLinks() {
      this._initialLinks = {};
    }
    _attachEvents() {
      let n = null;
      const e = this._gantt,
        i = () => {
          n ||
            ((n = setTimeout(() => {
              n = null;
            })),
            this.clearInitialTasks(),
            e.eachTask((l) => {
              this.setInitialTask(l.id);
            }),
            this.clearInitialLinks(),
            e.getLinks().forEach((l) => {
              this.setInitialLink(l.id);
            }));
        },
        a = (l) => e.copy(e.getTask(l));
      for (const l in kn)
        e.attachEvent(l, () => (this.startIgnore(), !0)),
          e.attachEvent(kn[l], () => (this.stopIgnore(), !0));
      for (let l = 0; l < yn.length; l++)
        e.attachEvent(yn[l], () => (this.startBatchAction(), !0));
      e.attachEvent("onParse", () => {
        this._undo.clearUndoStack(), this._undo.clearRedoStack(), i();
      }),
        e.attachEvent("onAfterTaskAdd", (l, d) => {
          this.setInitialTask(l, !0), this.onTaskAdded(d);
        }),
        e.attachEvent("onAfterTaskUpdate", (l, d) => {
          this.onTaskUpdated(d);
        }),
        e.attachEvent("onAfterParentExpand", (l, d) => {
          this.onTaskUpdated(d);
        }),
        e.attachEvent("onAfterTaskDelete", (l, d) => {
          this.onTaskDeleted(d);
        }),
        e.attachEvent("onAfterLinkAdd", (l, d) => {
          this.setInitialLink(l, !0), this.onLinkAdded(d);
        }),
        e.attachEvent("onAfterLinkUpdate", (l, d) => {
          this.onLinkUpdated(d);
        }),
        e.attachEvent("onAfterLinkDelete", (l, d) => {
          this.onLinkDeleted(d);
        }),
        e.attachEvent(
          "onRowDragEnd",
          (l, d) => (this.onTaskMoved(a(l)), this.toggleIgnoreMoveEvents(), !0)
        ),
        e.attachEvent("onBeforeTaskDelete", (l) => {
          this.store(l, e.config.undo_types.task);
          const d = [];
          return (
            i(),
            e.eachTask((c) => {
              d.push(c.id);
            }, l),
            this.setNestedTasks(l, d),
            !0
          );
        });
      const r = e.getDatastore("task");
      r.attachEvent(
        "onBeforeItemMove",
        (l, d, c) => (this.isMoveEventsIgnored() || i(), !0)
      ),
        r.attachEvent(
          "onAfterItemMove",
          (l, d, c) => (
            this.isMoveEventsIgnored() || this.onTaskMoved(a(l)), !0
          )
        ),
        e.attachEvent(
          "onRowDragStart",
          (l, d, c) => (this.toggleIgnoreMoveEvents(!0), i(), !0)
        );
      let s = null,
        o = !1;
      if (
        (e.attachEvent("onBeforeTaskDrag", (l) => {
          if (((s = e.getState().drag_id), s === l)) {
            const d = e.getTask(l);
            e.isSummaryTask(d) && e.config.drag_project && (o = !0);
          }
          if (e.plugins().multiselect) {
            const d = e.getSelectedTasks();
            d.length > 1 &&
              d.forEach((c) => {
                this.store(c, e.config.undo_types.task, !0);
              });
          }
          return this.store(l, e.config.undo_types.task);
        }),
        e.attachEvent("onAfterTaskDrag", (l) => {
          (o || (e.plugins().multiselect && e.getSelectedTasks().length > 1)) &&
            s === l &&
            ((o = !1), (s = null), this.stopBatchAction()),
            this.store(l, e.config.undo_types.task, !0);
        }),
        e.attachEvent("onLightbox", (l) =>
          this.store(l, e.config.undo_types.task)
        ),
        e.attachEvent(
          "onBeforeTaskAutoSchedule",
          (l) => (this.store(l.id, e.config.undo_types.task, !0), !0)
        ),
        e.ext.inlineEditors)
      ) {
        let l = null,
          d = null;
        e.attachEvent("onGanttLayoutReady", () => {
          l && e.ext.inlineEditors.detachEvent(l),
            d && e.ext.inlineEditors.detachEvent(d),
            (d = e.ext.inlineEditors.attachEvent("onEditStart", (c) => {
              this.store(c.id, e.config.undo_types.task);
            })),
            (l = e.ext.inlineEditors.attachEvent(
              "onBeforeEditStart",
              (c) => (this.stopBatchAction(), !0)
            ));
        });
      }
    }
    _storeCommand(n) {
      const e = this._undo;
      if ((e.updateConfigs(), e.undoEnabled))
        if (this._batchMode) this._batchAction.commands.push(n);
        else {
          const i = e.action.create([n]);
          e.logAction(i);
        }
    }
    _storeEntityCommand(n, e, i, a) {
      const r = this._undo.command.create(n, e, i, a);
      this._storeCommand(r);
    }
    _storeTaskCommand(n, e) {
      this._gantt.isTaskExists(n.id) &&
        (n.$local_index = this._gantt.getTaskIndex(n.id)),
        this._storeEntityCommand(
          n,
          this.getInitialTask(n.id),
          e,
          this._undo.command.entity.task
        );
    }
    _storeLinkCommand(n, e) {
      this._storeEntityCommand(
        n,
        this.getInitialLink(n.id),
        e,
        this._undo.command.entity.link
      );
    }
    _getLinks(n) {
      return n.$source.concat(n.$target);
    }
    _storeTask(n, e = !1) {
      const i = this._gantt;
      return (
        this.setInitialTask(n, e),
        i.eachTask((a) => {
          this.setInitialTask(a.id);
        }, n),
        !0
      );
    }
    _storeLink(n, e = !1) {
      return this.setInitialLink(n, e), !0;
    }
  }
  class yi {
    constructor(n) {
      (this.maxSteps = 100),
        (this.undoEnabled = !0),
        (this.redoEnabled = !0),
        (this.action = {
          create: (e) => ({ commands: e ? e.slice() : [] }),
          invert: (e) => {
            const i = this._gantt.copy(e),
              a = this.command;
            for (let r = 0; r < e.commands.length; r++) {
              const s = (i.commands[r] = a.invert(i.commands[r]));
              (s.type !== a.type.update && s.type !== a.type.move) ||
                ([s.value, s.oldValue] = [s.oldValue, s.value]);
            }
            return i;
          },
        }),
        (this.command = {
          entity: null,
          type: null,
          create: (e, i, a, r) => {
            const s = this._gantt;
            return {
              entity: r,
              type: a,
              value: s.copy(e),
              oldValue: s.copy(i || e),
            };
          },
          invert: (e) => {
            const i = this._gantt.copy(e);
            return (i.type = this.command.inverseCommands(e.type)), i;
          },
          inverseCommands: (e) => {
            const i = this._gantt,
              a = this.command.type;
            switch (e) {
              case a.update:
                return a.update;
              case a.remove:
                return a.add;
              case a.add:
                return a.remove;
              case a.move:
                return a.move;
              default:
                return i.assert(!1, "Invalid command " + e), null;
            }
          },
        }),
        (this._undoStack = []),
        (this._redoStack = []),
        (this._gantt = n);
    }
    getUndoStack() {
      return this._undoStack;
    }
    setUndoStack(n) {
      this._undoStack = n;
    }
    getRedoStack() {
      return this._redoStack;
    }
    setRedoStack(n) {
      this._redoStack = n;
    }
    clearUndoStack() {
      this._undoStack = [];
    }
    clearRedoStack() {
      this._redoStack = [];
    }
    updateConfigs() {
      const n = this._gantt;
      (this.maxSteps = n.config.undo_steps || 100),
        (this.command.entity = n.config.undo_types),
        (this.command.type = n.config.undo_actions),
        (this.undoEnabled = !!n.config.undo),
        (this.redoEnabled = !!n.config.redo);
    }
    undo() {
      const n = this._gantt;
      if ((this.updateConfigs(), !this.undoEnabled)) return;
      const e = this._pop(this._undoStack);
      if (
        (e && this._reorderCommands(e),
        n.callEvent("onBeforeUndo", [e]) !== !1 && e)
      )
        return (
          this._applyAction(this.action.invert(e)),
          this._push(this._redoStack, n.copy(e)),
          void n.callEvent("onAfterUndo", [e])
        );
      n.callEvent("onAfterUndo", [null]);
    }
    redo() {
      const n = this._gantt;
      if ((this.updateConfigs(), !this.redoEnabled)) return;
      const e = this._pop(this._redoStack);
      if (
        (e && this._reorderCommands(e),
        n.callEvent("onBeforeRedo", [e]) !== !1 && e)
      )
        return (
          this._applyAction(e),
          this._push(this._undoStack, n.copy(e)),
          void n.callEvent("onAfterRedo", [e])
        );
      n.callEvent("onAfterRedo", [null]);
    }
    logAction(n) {
      this._push(this._undoStack, n), (this._redoStack = []);
    }
    _push(n, e) {
      const i = this._gantt;
      if (!e.commands.length) return;
      const a =
        n === this._undoStack ? "onBeforeUndoStack" : "onBeforeRedoStack";
      if (i.callEvent(a, [e]) !== !1 && e.commands.length) {
        for (n.push(e); n.length > this.maxSteps; ) n.shift();
        return e;
      }
    }
    _pop(n) {
      return n.pop();
    }
    _reorderCommands(n) {
      const e = { any: 0, link: 1, task: 2 },
        i = { move: 1, any: 0 };
      n.commands.sort(function (a, r) {
        if (a.entity === "task" && r.entity === "task")
          return a.type !== r.type
            ? (i[r.type] || 0) - (i[a.type] || 0)
            : a.type === "move" &&
              a.oldValue &&
              r.oldValue &&
              r.oldValue.parent === a.oldValue.parent
            ? a.oldValue.$index - r.oldValue.$index
            : 0;
        {
          const s = e[a.entity] || e.any;
          return (e[r.entity] || e.any) - s;
        }
      });
    }
    _applyAction(n) {
      let e = null;
      const i = this.command.entity,
        a = this.command.type,
        r = this._gantt,
        s = {};
      (s[i.task] = {
        add: "addTask",
        get: "getTask",
        update: "updateTask",
        remove: "deleteTask",
        move: "moveTask",
        isExists: "isTaskExists",
      }),
        (s[i.link] = {
          add: "addLink",
          get: "getLink",
          update: "updateLink",
          remove: "deleteLink",
          isExists: "isLinkExists",
        }),
        r.batchUpdate(function () {
          for (let o = 0; o < n.commands.length; o++) {
            e = n.commands[o];
            const l = s[e.entity][e.type],
              d = s[e.entity].get,
              c = s[e.entity].isExists;
            if (e.type === a.add)
              r[l](e.oldValue, e.oldValue.parent, e.oldValue.$local_index);
            else if (e.type === a.remove) r[c](e.value.id) && r[l](e.value.id);
            else if (e.type === a.update) {
              const u = r[d](e.value.id);
              for (const h in e.value) {
                let _ = !(h.startsWith("$") || h.startsWith("_"));
                ["$open"].indexOf(h) > -1 && (_ = !0), _ && (u[h] = e.value[h]);
              }
              r[l](e.value.id);
            } else
              e.type === a.move &&
                (r[l](e.value.id, e.value.$local_index, e.value.parent),
                r.callEvent("onRowDragEnd", [e.value.id]));
          }
        });
    }
  }
  const bi = {
    auto_scheduling: function (t) {
      It(t), tn(t);
      var n = rn(t),
        e = an(),
        i = pe.Create(t),
        a = new ai(t, e, i),
        r = new ri(t, n),
        s = new si(t, e, n);
      (t.getConnectedGroup = r.getConnectedGroup),
        (t.getConstraintType = i.getConstraintType),
        (t.getConstraintLimitations = function (l) {
          var d = i.processConstraint(l, null);
          return d
            ? {
                earliestStart: d.earliestStart || null,
                earliestEnd: d.earliestEnd || null,
                latestStart: d.latestStart || null,
                latestEnd: d.latestEnd || null,
              }
            : {
                earliestStart: null,
                earliestEnd: null,
                latestStart: null,
                latestEnd: null,
              };
        }),
        (t.isCircularLink = s.isCircularLink),
        (t.findCycles = s.findCycles),
        (t.config.constraint_types = V),
        (t.config.auto_scheduling = !1),
        (t.config.auto_scheduling_descendant_links = !1),
        (t.config.auto_scheduling_initial = !0),
        (t.config.auto_scheduling_strict = !1),
        (t.config.auto_scheduling_move_projects = !0),
        (t.config.project_start = null),
        (t.config.project_end = null),
        (t.config.schedule_from_end = !1);
      var o = !1;
      t.attachEvent("onParse", function () {
        return (o = !0), !0;
      }),
        t.attachEvent("onBeforeGanttRender", function () {
          return (o = !1), !0;
        }),
        (t._autoSchedule = function (l, d) {
          if (t.callEvent("onBeforeAutoSchedule", [l]) !== !1) {
            t._autoscheduling_in_progress = !0;
            var c = i.getConstraints(l, t.isTaskExists(l) ? d : null),
              u = [],
              h = e.findLoops(d);
            if (h.length) t.callEvent("onAutoScheduleCircularLink", [h]);
            else {
              (function (f, y) {
                if (t.config.auto_scheduling_compatibility)
                  for (var v = 0; v < y.length; v++) {
                    var b = y[v],
                      g = t.getTask(b.target);
                    (t.config.auto_scheduling_strict && b.target != f) ||
                      (b.preferredStart = new Date(g.start_date));
                  }
              })(l, d);
              for (let f = 0; f < d.length; f++)
                if (d[f].subtaskLink) {
                  (a._secondIterationRequired = !0), (a._secondIteration = !1);
                  break;
                }
              var _ = a.generatePlan(d, c);
              (function (f) {
                f.length &&
                  t.batchUpdate(function () {
                    for (var y = 0; y < f.length; y++) t.updateTask(f[y]);
                  }, o);
              })((u = a.applyProjectPlan(_)));
            }
            (t._autoscheduling_in_progress = !1),
              t.callEvent("onAfterAutoSchedule", [l, u]);
          }
        }),
        (t.autoSchedule = function (l, d) {
          var c;
          (d = d === void 0 || !!d),
            (c =
              l !== void 0
                ? t.config.auto_scheduling_compatibility
                  ? n.getLinkedTasks(l, d)
                  : r.getConnectedGroupRelations(l)
                : n.getLinkedTasks()),
            t._autoSchedule(l, c);
        }),
        t.attachEvent("onTaskLoading", function (l) {
          return (
            l.constraint_date &&
              typeof l.constraint_date == "string" &&
              (l.constraint_date = t.date.parseDate(
                l.constraint_date,
                "parse_date"
              )),
            (l.constraint_type = t.getConstraintType(l)),
            !0
          );
        }),
        t.attachEvent("onTaskCreated", function (l) {
          return (l.constraint_type = t.getConstraintType(l)), !0;
        }),
        oi(t, n, s, r);
    },
    click_drag: function (t) {
      t.ext || (t.ext = {});
      const n = {
        className: "gantt_click_drag_rect",
        useRequestAnimationFrame: !0,
        callback: void 0,
        singleRow: !1,
      };
      function e() {
        const i = { viewPort: t.$task_data, ...n };
        t.ext.clickDrag && t.ext.clickDrag.destructor(),
          (t.ext.clickDrag = new hi(t));
        const a = t.config.click_drag;
        (i.render = a.render || n.render),
          (i.className = a.className || n.className),
          (i.callback = a.callback || n.callback),
          (i.viewPort = a.viewPort || t.$task_data),
          (i.useRequestAnimationFrame =
            a.useRequestAnimationFrame === void 0
              ? n.useRequestAnimationFrame
              : a.useRequestAnimationFrame),
          (i.singleRow = a.singleRow === void 0 ? n.singleRow : a.singleRow);
        const r = t.$ui.getView("timeline"),
          s = new _i(i, t, r);
        t.ext.clickDrag.attach(s, a.useKey, a.ignore);
      }
      t.attachEvent("onGanttReady", () => {
        t.config.click_drag && e();
      }),
        t.attachEvent("onGanttLayoutReady", function () {
          t.$container &&
            t.config.click_drag &&
            t.attachEvent(
              "onGanttRender",
              function () {
                e();
              },
              { once: !0 }
            );
        }),
        t.attachEvent("onDestroy", () => {
          t.ext.clickDrag && t.ext.clickDrag.destructor();
        });
    },
    critical_path: function (t) {
      It(t), tn(t);
      var n = (function (i) {
        var a = rn(i),
          r = an(),
          s = {
            _freeSlack: {},
            _totalSlack: {},
            _slackNeedCalculate: !0,
            _linkedTasksById: {},
            _successorsByTaskId: {},
            _projectEnd: null,
            _calculateSlacks: function () {
              var o = a.getLinkedTasks(),
                l = r.findLoops(o);
              if (l.length) {
                i.callEvent("onAutoScheduleCircularLink", [l]);
                var d = {};
                l.forEach(function (f) {
                  f.linkKeys.forEach(function (y) {
                    d[y] = !0;
                  });
                });
                for (var c = 0; c < o.length; c++)
                  o[c].hashSum in d && (o.splice(c, 1), c--);
              }
              const u = r.topologicalSort(o).reverse(),
                h = {};
              o.forEach((f) => {
                h[f.source] || (h[f.source] = { linked: [] }),
                  h[f.source].linked.push({ target: f.target, link: f });
              });
              const _ = {
                _cache: {},
                getDist: function (f, y) {
                  const v = `${f.id}_${y.id}`;
                  if (this._cache[v]) return this._cache[v];
                  {
                    const b = i.calculateDuration({
                      start_date: f.end_date,
                      end_date: y.start_date,
                      task: f,
                    });
                    return (this._cache[v] = b), b;
                  }
                },
              };
              (this._projectEnd = i.getSubtaskDates().end_date),
                this._calculateFreeSlack(o, u, h, _),
                this._calculateTotalSlack(o, u, h, _);
            },
            _isCompletedTask: function (o) {
              return i.config.auto_scheduling_use_progress && o.progress == 1;
            },
            _calculateFreeSlack: function (o, l, d, c) {
              const u = (this._freeSlack = {}),
                h = {};
              i.eachTask(function (f) {
                i.isSummaryTask(f) || (h[f.id] = f);
              });
              const _ = {};
              o.forEach((f) => {
                const y = h[f.source];
                if (!y) return;
                _[f.source] = !0;
                let v = c.getDist(y, i.getTask(f.target));
                (v -= f.lag || 0),
                  u[f.source] !== void 0
                    ? (u[f.source] = Math.min(v, u[f.source]))
                    : (u[f.source] = v);
              });
              for (const f in h) {
                if (_[f]) continue;
                const y = h[f];
                this._isCompletedTask(y) || y.unscheduled
                  ? (u[y.id] = 0)
                  : (u[y.id] = i.calculateDuration({
                      start_date: y.end_date,
                      end_date: this._projectEnd,
                      task: y,
                    }));
              }
              return this._freeSlack;
            },
            _disconnectedTaskSlack(o) {
              return this._isCompletedTask(o)
                ? 0
                : Math.max(
                    i.calculateDuration(o.end_date, this._projectEnd),
                    0
                  );
            },
            _calculateTotalSlack: function (o, l, d, c) {
              (this._totalSlack = {}), (this._slackNeedCalculate = !1);
              for (
                var u = {}, h = i.getTaskByTime(), _ = 0;
                _ < l.length;
                _++
              ) {
                const y = i.getTask(l[_]);
                if (this._isCompletedTask(y)) u[y.id] = 0;
                else if (d[y.id] || i.isSummaryTask(y)) {
                  const v = d[y.id].linked;
                  let b = null;
                  for (var f = 0; f < v.length; f++) {
                    const g = v[f],
                      m = i.getTask(g.target);
                    let p = 0;
                    u[m.id] !== void 0 && (p += u[m.id]),
                      (p += c.getDist(y, m)),
                      (p -= g.link.lag || 0),
                      (b = b === null ? p : Math.min(b, p));
                  }
                  u[y.id] = b || 0;
                } else u[y.id] = this.getFreeSlack(y);
              }
              return (
                h.forEach(
                  function (y) {
                    u[y.id] !== void 0 ||
                      i.isSummaryTask(y) ||
                      (u[y.id] = this.getFreeSlack(y));
                  }.bind(this)
                ),
                (this._totalSlack = u),
                this._totalSlack
              );
            },
            _resetTotalSlackCache: function () {
              this._slackNeedCalculate = !0;
            },
            _shouldCalculateTotalSlack: function () {
              return this._slackNeedCalculate;
            },
            getFreeSlack: function (o) {
              return (
                this._shouldCalculateTotalSlack() && this._calculateSlacks(),
                i.isTaskExists(o.id)
                  ? this._isCompletedTask(o)
                    ? 0
                    : i.isSummaryTask(o)
                    ? void 0
                    : this._freeSlack[o.id] || 0
                  : 0
              );
            },
            getTotalSlack: function (o) {
              if (
                (this._shouldCalculateTotalSlack() && this._calculateSlacks(),
                o === void 0)
              )
                return this._totalSlack;
              var l;
              if (((l = o.id !== void 0 ? o.id : o), this._isCompletedTask(o)))
                return 0;
              if (this._totalSlack[l] === void 0) {
                if (i.isSummaryTask(i.getTask(l))) {
                  var d = null;
                  return (
                    i.eachTask(
                      function (c) {
                        var u = this._totalSlack[c.id];
                        u !== void 0 && (d === null || u < d) && (d = u);
                      }.bind(this),
                      l
                    ),
                    (this._totalSlack[l] =
                      d !== null
                        ? d
                        : i.calculateDuration({
                            start_date: o.end_date,
                            end_date: this._projectEnd,
                            task: o,
                          })),
                    this._totalSlack[l]
                  );
                }
                return 0;
              }
              return this._totalSlack[l] || 0;
            },
            dropCachedFreeSlack: function () {
              (this._freeSlack = {}), this._resetTotalSlackCache();
            },
            init: function () {
              function o() {
                s.dropCachedFreeSlack();
              }
              i.attachEvent("onAfterLinkAdd", o),
                i.attachEvent("onTaskIdChange", o),
                i.attachEvent("onAfterLinkUpdate", o),
                i.attachEvent("onAfterLinkDelete", o),
                i.attachEvent("onAfterTaskAdd", o),
                i.attachEvent("onAfterTaskUpdate", o),
                i.attachEvent("onAfterTaskDelete", o),
                i.attachEvent("onRowDragEnd", o),
                i.attachEvent("onAfterTaskMove", o),
                i.attachEvent("onParse", o),
                i.attachEvent("onClear", o),
                i.$data.tasksStore.attachEvent("onClearAll", o),
                i.$data.linksStore.attachEvent("onClearAll", o);
            },
          };
        return s;
      })(t);
      n.init(),
        (t.getFreeSlack = function (i) {
          return n.getFreeSlack(i);
        }),
        (t.getTotalSlack = function (i) {
          return n.getTotalSlack(i);
        });
      var e = (function (i) {
        return (
          (i._isProjectEnd = function (a) {
            return !this._hasDuration({
              start_date: a.end_date,
              end_date: this._getProjectEnd(),
              task: a,
            });
          }),
          {
            _cache: {},
            _slackHelper: null,
            reset: function () {
              this._cache = {};
            },
            _calculateCriticalPath: function () {
              this.reset();
            },
            isCriticalTask: function (a) {
              if (!a) return !1;
              if (i.config.auto_scheduling_use_progress && a.progress === 1)
                return (this._cache[a.id] = !1), !1;
              if (a.unscheduled) return !1;
              if (this._cache[a.id] === void 0)
                if (i.isSummaryTask(a)) {
                  let r = !1;
                  i.eachTask(
                    function (s) {
                      r || (r = this.isCriticalTask(s));
                    }.bind(this),
                    a.id
                  ),
                    (this._cache[a.id] = r);
                } else
                  this._cache[a.id] = this._slackHelper.getTotalSlack(a) <= 0;
              return this._cache[a.id];
            },
            init: function (a) {
              this._slackHelper = a;
              var r = i.bind(function () {
                  return this.reset(), !0;
                }, this),
                s = i.bind(function (l, d) {
                  return (
                    this._cache &&
                      ((this._cache[d] = this._cache[l]),
                      delete this._cache[l]),
                    !0
                  );
                }, this);
              i.attachEvent("onAfterLinkAdd", r),
                i.attachEvent("onAfterLinkUpdate", r),
                i.attachEvent("onAfterLinkDelete", r),
                i.attachEvent("onAfterTaskAdd", r),
                i.attachEvent("onTaskIdChange", s),
                i.attachEvent("onAfterTaskUpdate", r),
                i.attachEvent("onAfterTaskDelete", r),
                i.attachEvent("onParse", r),
                i.attachEvent("onClear", r),
                i.$data.tasksStore.attachEvent("onClearAll", r),
                i.$data.linksStore.attachEvent("onClearAll", r);
              var o = function () {
                i.config.highlight_critical_path &&
                  !i.getState("batchUpdate").batch_update &&
                  i.render();
              };
              i.attachEvent("onAfterLinkAdd", o),
                i.attachEvent("onAfterLinkUpdate", o),
                i.attachEvent("onAfterLinkDelete", o),
                i.attachEvent("onAfterTaskAdd", o),
                i.attachEvent("onTaskIdChange", function (l, d) {
                  return (
                    i.config.highlight_critical_path &&
                      i.isTaskExists(d) &&
                      i.refreshTask(d),
                    !0
                  );
                }),
                i.attachEvent("onAfterTaskUpdate", o),
                i.attachEvent("onAfterTaskDelete", o);
            },
          }
        );
      })(t);
      (t.config.highlight_critical_path = !1),
        e.init(n),
        (t.isCriticalTask = function (i) {
          return (
            t.assert(
              !(!i || i.id === void 0),
              "Invalid argument for gantt.isCriticalTask"
            ),
            e.isCriticalTask(i)
          );
        }),
        (t.isCriticalLink = function (i) {
          return this.isCriticalTask(t.getTask(i.source));
        }),
        (t.getSlack = function (i, a) {
          for (var r = 0, s = [], o = {}, l = 0; l < i.$source.length; l++)
            o[i.$source[l]] = !0;
          for (l = 0; l < a.$target.length; l++)
            o[a.$target[l]] && s.push(a.$target[l]);
          if (s[0])
            for (l = 0; l < s.length; l++) {
              var d = this.getLink(s[l]),
                c = this._getSlack(
                  i,
                  a,
                  this._convertToFinishToStartLink(
                    d.id,
                    d,
                    i,
                    a,
                    i.parent,
                    a.parent
                  )
                );
              (r > c || l === 0) && (r = c);
            }
          else r = this._getSlack(i, a, {});
          return r;
        }),
        (t._getSlack = function (i, a, r) {
          var s = this.config.types,
            o = null;
          o =
            this.getTaskType(i.type) == s.milestone ? i.start_date : i.end_date;
          var l = a.start_date,
            d = 0;
          d =
            +o > +l
              ? -this.calculateDuration({ start_date: l, end_date: o, task: i })
              : this.calculateDuration({ start_date: o, end_date: l, task: i });
          var c = r.lag;
          return c && 1 * c == c && (d -= c), d;
        });
    },
    drag_timeline: function (t) {
      t.ext || (t.ext = {}),
        (t.ext.dragTimeline = {
          create: () => Qt.create(t),
          _isDragInProgress: () => Qt._isDragInProgress,
        }),
        (t.config.drag_timeline = { enabled: !0, render: !1 });
    },
    fullscreen: function (t) {
      function n() {
        const c =
          document.fullscreenElement ||
          document.mozFullScreenElement ||
          document.webkitFullscreenElement ||
          document.msFullscreenElement;
        return !(!c || c !== document.body);
      }
      function e() {
        try {
          return (
            document.fullscreenEnabled ||
            document.webkitFullscreenEnabled ||
            document.mozFullScreenEnabled ||
            document.msFullscreenEnabled
          );
        } catch (c) {
          console.error("Fullscreen is not available:", c);
        }
      }
      t.$services
        .getService("state")
        .registerProvider("fullscreen", () =>
          e() ? { fullscreen: n() } : void 0
        );
      let i = {
        overflow: null,
        padding: null,
        paddingTop: null,
        paddingRight: null,
        paddingBottom: null,
        paddingLeft: null,
      };
      const a = {
        width: null,
        height: null,
        top: null,
        left: null,
        position: null,
        zIndex: null,
        modified: !1,
      };
      let r = null;
      function s(c, u) {
        (u.width = c.width),
          (u.height = c.height),
          (u.top = c.top),
          (u.left = c.left),
          (u.position = c.position),
          (u.zIndex = c.zIndex);
      }
      let o = !1;
      function l() {
        if (!t.$container) return;
        let c;
        n()
          ? o &&
            ((c = "onExpand"),
            (function () {
              const u = t.ext.fullscreen.getFullscreenElement(),
                h = document.body;
              s(u.style, a),
                (i = {
                  overflow: h.style.overflow,
                  padding: h.style.padding ? h.style.padding : null,
                  paddingTop: h.style.paddingTop ? h.style.paddingTop : null,
                  paddingRight: h.style.paddingRight
                    ? h.style.paddingRight
                    : null,
                  paddingBottom: h.style.paddingBottom
                    ? h.style.paddingBottom
                    : null,
                  paddingLeft: h.style.paddingLeft ? h.style.paddingLeft : null,
                }),
                h.style.padding && (h.style.padding = "0"),
                h.style.paddingTop && (h.style.paddingTop = "0"),
                h.style.paddingRight && (h.style.paddingRight = "0"),
                h.style.paddingBottom && (h.style.paddingBottom = "0"),
                h.style.paddingLeft && (h.style.paddingLeft = "0"),
                (h.style.overflow = "hidden"),
                (u.style.width = "100vw"),
                (u.style.height = "100vh"),
                (u.style.top = "0px"),
                (u.style.left = "0px"),
                (u.style.position = "absolute"),
                (u.style.zIndex = 1),
                (a.modified = !0),
                (r = (function (_) {
                  let f = _.parentNode;
                  const y = [];
                  for (; f && f.style; )
                    y.push({
                      element: f,
                      originalPositioning: f.style.position,
                    }),
                      (f.style.position = "static"),
                      (f = f.parentNode);
                  return y;
                })(u));
            })())
          : o &&
            ((o = !1),
            (c = "onCollapse"),
            (function () {
              const u = t.ext.fullscreen.getFullscreenElement(),
                h = document.body;
              a.modified &&
                (i.padding && (h.style.padding = i.padding),
                i.paddingTop && (h.style.paddingTop = i.paddingTop),
                i.paddingRight && (h.style.paddingRight = i.paddingRight),
                i.paddingBottom && (h.style.paddingBottom = i.paddingBottom),
                i.paddingLeft && (h.style.paddingLeft = i.paddingLeft),
                (h.style.overflow = i.overflow),
                (i = {
                  overflow: null,
                  padding: null,
                  paddingTop: null,
                  paddingRight: null,
                  paddingBottom: null,
                  paddingLeft: null,
                }),
                s(a, u.style),
                (a.modified = !1)),
                r.forEach((_) => {
                  _.element.style.position = _.originalPositioning;
                }),
                (r = null);
            })()),
          setTimeout(() => {
            t.render();
          }),
          setTimeout(() => {
            t.callEvent(c, [t.ext.fullscreen.getFullscreenElement()]);
          });
      }
      function d() {
        return !t.$container || !t.ext.fullscreen.getFullscreenElement()
          ? !0
          : e()
          ? !1
          : ((console.warning || console.log)(
              "The `fullscreen` feature not being allowed, or full-screen mode not being supported"
            ),
            !0);
      }
      (t.ext.fullscreen = {
        expand() {
          if (
            d() ||
            n() ||
            !t.callEvent("onBeforeExpand", [this.getFullscreenElement()])
          )
            return;
          o = !0;
          const c = document.body,
            u = c.webkitRequestFullscreen ? [Element.ALLOW_KEYBOARD_INPUT] : [],
            h =
              c.msRequestFullscreen ||
              c.mozRequestFullScreen ||
              c.webkitRequestFullscreen ||
              c.requestFullscreen;
          h && h.apply(c, u);
        },
        collapse() {
          if (
            d() ||
            !n() ||
            !t.callEvent("onBeforeCollapse", [this.getFullscreenElement()])
          )
            return;
          const c =
            document.msExitFullscreen ||
            document.mozCancelFullScreen ||
            document.webkitExitFullscreen ||
            document.exitFullscreen;
          c && c.apply(document);
        },
        toggle() {
          d() || (n() ? this.collapse() : this.expand());
        },
        getFullscreenElement: () => t.$root,
      }),
        (t.expand = function () {
          t.ext.fullscreen.expand();
        }),
        (t.collapse = function () {
          t.ext.fullscreen.collapse();
        }),
        t.attachEvent("onGanttReady", function () {
          t.event(document, "webkitfullscreenchange", l),
            t.event(document, "mozfullscreenchange", l),
            t.event(document, "MSFullscreenChange", l),
            t.event(document, "fullscreenChange", l),
            t.event(document, "fullscreenchange", l);
        });
    },
    keyboard_navigation: function (t) {
      (function (n) {
        (n.config.keyboard_navigation = !0),
          (n.config.keyboard_navigation_cells = !1),
          (n.$keyboardNavigation = {}),
          (n._compose = function () {
            for (
              var e = Array.prototype.slice.call(arguments, 0), i = {}, a = 0;
              a < e.length;
              a++
            ) {
              var r = e[a];
              for (var s in (typeof r == "function" && (r = new r()), r))
                i[s] = r[s];
            }
            return i;
          }),
          (function (e) {
            e.$keyboardNavigation.shortcuts = {
              createCommand: function () {
                return {
                  modifiers: { shift: !1, alt: !1, ctrl: !1, meta: !1 },
                  keyCode: null,
                };
              },
              parse: function (i) {
                for (
                  var a = [], r = this.getExpressions(this.trim(i)), s = 0;
                  s < r.length;
                  s++
                ) {
                  for (
                    var o = this.getWords(r[s]),
                      l = this.createCommand(),
                      d = 0;
                    d < o.length;
                    d++
                  )
                    this.commandKeys[o[d]]
                      ? (l.modifiers[o[d]] = !0)
                      : this.specialKeys[o[d]]
                      ? (l.keyCode = this.specialKeys[o[d]])
                      : (l.keyCode = o[d].charCodeAt(0));
                  a.push(l);
                }
                return a;
              },
              getCommandFromEvent: function (i) {
                var a = this.createCommand();
                (a.modifiers.shift = !!i.shiftKey),
                  (a.modifiers.alt = !!i.altKey),
                  (a.modifiers.ctrl = !!i.ctrlKey),
                  (a.modifiers.meta = !!i.metaKey),
                  (a.keyCode = i.which || i.keyCode),
                  a.keyCode >= 96 && a.keyCode <= 105 && (a.keyCode -= 48);
                var r = String.fromCharCode(a.keyCode);
                return r && (a.keyCode = r.toLowerCase().charCodeAt(0)), a;
              },
              getHashFromEvent: function (i) {
                return this.getHash(this.getCommandFromEvent(i));
              },
              getHash: function (i) {
                var a = [];
                for (var r in i.modifiers) i.modifiers[r] && a.push(r);
                return a.push(i.keyCode), a.join(this.junctionChar);
              },
              getExpressions: function (i) {
                return i.split(this.junctionChar);
              },
              getWords: function (i) {
                return i.split(this.combinationChar);
              },
              trim: function (i) {
                return i.replace(/\s/g, "");
              },
              junctionChar: ",",
              combinationChar: "+",
              commandKeys: { shift: 16, alt: 18, ctrl: 17, meta: !0 },
              specialKeys: {
                backspace: 8,
                tab: 9,
                enter: 13,
                esc: 27,
                space: 32,
                up: 38,
                down: 40,
                left: 37,
                right: 39,
                home: 36,
                end: 35,
                pageup: 33,
                pagedown: 34,
                delete: 46,
                insert: 45,
                plus: 107,
                f1: 112,
                f2: 113,
                f3: 114,
                f4: 115,
                f5: 116,
                f6: 117,
                f7: 118,
                f8: 119,
                f9: 120,
                f10: 121,
                f11: 122,
                f12: 123,
              },
            };
          })(n),
          (function (e) {
            e.$keyboardNavigation.EventHandler = {
              _handlers: null,
              findHandler: function (i) {
                this._handlers || (this._handlers = {});
                var a = e.$keyboardNavigation.shortcuts.getHash(i);
                return this._handlers[a];
              },
              doAction: function (i, a) {
                var r = this.findHandler(i);
                if (r) {
                  if (
                    e.$keyboardNavigation.facade.callEvent("onBeforeAction", [
                      i,
                      a,
                    ]) === !1
                  )
                    return;
                  r.call(this, a),
                    a.preventDefault
                      ? a.preventDefault()
                      : (a.returnValue = !1);
                }
              },
              bind: function (i, a) {
                this._handlers || (this._handlers = {});
                for (
                  var r = e.$keyboardNavigation.shortcuts,
                    s = r.parse(i),
                    o = 0;
                  o < s.length;
                  o++
                )
                  this._handlers[r.getHash(s[o])] = a;
              },
              unbind: function (i) {
                for (
                  var a = e.$keyboardNavigation.shortcuts,
                    r = a.parse(i),
                    s = 0;
                  s < r.length;
                  s++
                )
                  this._handlers[a.getHash(r[s])] &&
                    delete this._handlers[a.getHash(r[s])];
              },
              bindAll: function (i) {
                for (var a in i) this.bind(a, i[a]);
              },
              initKeys: function () {
                this._handlers || (this._handlers = {}),
                  this.keys && this.bindAll(this.keys);
              },
            };
          })(n),
          (function (e) {
            (e.$keyboardNavigation.getFocusableNodes = zt),
              (e.$keyboardNavigation.trapFocus = function (i, a) {
                if (a.keyCode != 9) return !1;
                for (
                  var r = e.$keyboardNavigation.getFocusableNodes(i),
                    s = $e(),
                    o = -1,
                    l = 0;
                  l < r.length;
                  l++
                )
                  if (r[l] == s) {
                    o = l;
                    break;
                  }
                if (a.shiftKey) {
                  if (o <= 0) {
                    var d = r[r.length - 1];
                    if (d) return d.focus(), a.preventDefault(), !0;
                  }
                } else if (o >= r.length - 1) {
                  var c = r[0];
                  if (c) return c.focus(), a.preventDefault(), !0;
                }
                return !1;
              });
          })(n),
          (function (e) {
            (e.$keyboardNavigation.GanttNode = function () {}),
              (e.$keyboardNavigation.GanttNode.prototype = e._compose(
                e.$keyboardNavigation.EventHandler,
                {
                  focus: function () {
                    e.focus();
                  },
                  blur: function () {},
                  isEnabled: function () {
                    return e.$container.hasAttribute("tabindex");
                  },
                  scrollHorizontal: function (i) {
                    var a = e.dateFromPos(e.getScrollState().x),
                      r = e.getScale(),
                      s = i < 0 ? -r.step : r.step;
                    (a = e.date.add(a, s, r.unit)),
                      e.scrollTo(e.posFromDate(a));
                  },
                  scrollVertical: function (i) {
                    var a = e.getScrollState().y,
                      r = e.config.row_height;
                    e.scrollTo(null, a + (i < 0 ? -1 : 1) * r);
                  },
                  keys: {
                    "alt+left": function (i) {
                      this.scrollHorizontal(-1);
                    },
                    "alt+right": function (i) {
                      this.scrollHorizontal(1);
                    },
                    "alt+up": function (i) {
                      this.scrollVertical(-1);
                    },
                    "alt+down": function (i) {
                      this.scrollVertical(1);
                    },
                    "ctrl+z": function () {
                      e.undo && e.undo();
                    },
                    "ctrl+r": function () {
                      e.redo && e.redo();
                    },
                  },
                }
              )),
              e.$keyboardNavigation.GanttNode.prototype.bindAll(
                e.$keyboardNavigation.GanttNode.prototype.keys
              );
          })(n),
          (function (e) {
            (e.$keyboardNavigation.KeyNavNode = function () {}),
              (e.$keyboardNavigation.KeyNavNode.prototype = e._compose(
                e.$keyboardNavigation.EventHandler,
                {
                  isValid: function () {
                    return !0;
                  },
                  fallback: function () {
                    return null;
                  },
                  moveTo: function (i) {
                    e.$keyboardNavigation.dispatcher.setActiveNode(i);
                  },
                  compareTo: function (i) {
                    if (!i) return !1;
                    for (var a in this) {
                      if (!!this[a] != !!i[a]) return !1;
                      var r = !(!this[a] || !this[a].toString),
                        s = !(!i[a] || !i[a].toString);
                      if (s != r) return !1;
                      if (s && r) {
                        if (i[a].toString() != this[a].toString()) return !1;
                      } else if (i[a] != this[a]) return !1;
                    }
                    return !0;
                  },
                  getNode: function () {},
                  focus: function () {
                    var i = this.getNode();
                    if (i) {
                      var a = e.$keyboardNavigation.facade;
                      a.callEvent("onBeforeFocus", [i]) !== !1 &&
                        i &&
                        (i.setAttribute("tabindex", "-1"),
                        i.$eventAttached ||
                          ((i.$eventAttached = !0),
                          e.event(
                            i,
                            "focus",
                            function (r) {
                              return r.preventDefault(), !1;
                            },
                            !1
                          )),
                        e.utils.dom.isChildOf(document.activeElement, i) &&
                          (i = document.activeElement),
                        i.focus && i.focus(),
                        a.callEvent("onFocus", [this.getNode()]));
                    }
                  },
                  blur: function () {
                    var i = this.getNode();
                    i &&
                      (e.$keyboardNavigation.facade.callEvent("onBlur", [i]),
                      i.setAttribute("tabindex", "-1"));
                  },
                }
              ));
          })(n),
          (function (e) {
            (e.$keyboardNavigation.HeaderCell = function (i) {
              this.index = i || 0;
            }),
              (e.$keyboardNavigation.HeaderCell.prototype = e._compose(
                e.$keyboardNavigation.KeyNavNode,
                {
                  _handlers: null,
                  isValid: function () {
                    return !(
                      (!e.config.show_grid && e.getVisibleTaskCount()) ||
                      (!e.getGridColumns()[this.index] &&
                        e.getVisibleTaskCount())
                    );
                  },
                  fallback: function () {
                    if (!e.config.show_grid)
                      return e.getVisibleTaskCount()
                        ? new e.$keyboardNavigation.TaskRow()
                        : null;
                    for (
                      var i = e.getGridColumns(), a = this.index;
                      a >= 0 && !i[a];

                    )
                      a--;
                    return i[a]
                      ? new e.$keyboardNavigation.HeaderCell(a)
                      : null;
                  },
                  fromDomElement: function (i) {
                    var a = mt(i, "gantt_grid_head_cell");
                    if (a) {
                      for (var r = 0; a && a.previousSibling; )
                        (a = a.previousSibling), (r += 1);
                      return new e.$keyboardNavigation.HeaderCell(r);
                    }
                    return null;
                  },
                  getNode: function () {
                    const i = e.$grid_scale;
                    return i ? i.childNodes[this.index] : null;
                  },
                  keys: {
                    left: function () {
                      this.index > 0 &&
                        this.moveTo(
                          new e.$keyboardNavigation.HeaderCell(this.index - 1)
                        );
                    },
                    right: function () {
                      var i = e.getGridColumns();
                      this.index < i.length - 1 &&
                        this.moveTo(
                          new e.$keyboardNavigation.HeaderCell(this.index + 1)
                        );
                    },
                    down: function () {
                      var i,
                        a = e.getChildren(e.config.root_id);
                      e.isTaskExists(a[0]) && (i = a[0]),
                        i &&
                          (e.config.keyboard_navigation_cells
                            ? this.moveTo(
                                new e.$keyboardNavigation.TaskCell(
                                  i,
                                  this.index
                                )
                              )
                            : this.moveTo(
                                new e.$keyboardNavigation.TaskRow(i)
                              ));
                    },
                    end: function () {
                      var i = e.getGridColumns();
                      this.moveTo(
                        new e.$keyboardNavigation.HeaderCell(i.length - 1)
                      );
                    },
                    home: function () {
                      this.moveTo(new e.$keyboardNavigation.HeaderCell(0));
                    },
                    "enter, space": function () {
                      $e().click();
                    },
                    "ctrl+enter": function () {
                      e.isReadonly(this) || e.createTask({}, this.taskId);
                    },
                  },
                }
              )),
              e.$keyboardNavigation.HeaderCell.prototype.bindAll(
                e.$keyboardNavigation.HeaderCell.prototype.keys
              );
          })(n),
          (function (e) {
            (e.$keyboardNavigation.TaskRow = function (i) {
              if (!i) {
                var a = e.getChildren(e.config.root_id);
                a[0] && (i = a[0]);
              }
              (this.taskId = i),
                e.isTaskExists(this.taskId) &&
                  ((this.index = e.getTaskIndex(this.taskId)),
                  (this.globalIndex = e.getGlobalTaskIndex(this.taskId)),
                  (this.splitItem = !!e.getTask(this.taskId).$split_subtask),
                  (this.parentId = e.getParent(this.taskId)));
            }),
              (e.$keyboardNavigation.TaskRow.prototype = e._compose(
                e.$keyboardNavigation.KeyNavNode,
                {
                  _handlers: null,
                  isValid: function () {
                    return (
                      e.isTaskExists(this.taskId) &&
                      e.getTaskIndex(this.taskId) > -1
                    );
                  },
                  fallback: function () {
                    if (!e.getVisibleTaskCount()) {
                      var i = new e.$keyboardNavigation.HeaderCell();
                      return i.isValid() ? i : null;
                    }
                    if (this.splitItem)
                      return new e.$keyboardNavigation.TaskRow(this.parentId);
                    var a = -1;
                    if (e.getTaskByIndex(this.globalIndex - 1))
                      a = this.globalIndex - 1;
                    else if (e.getTaskByIndex(this.globalIndex + 1))
                      a = this.globalIndex + 1;
                    else
                      for (var r = this.globalIndex; r >= 0; ) {
                        if (e.getTaskByIndex(r)) {
                          a = r;
                          break;
                        }
                        r--;
                      }
                    return a > -1
                      ? new e.$keyboardNavigation.TaskRow(
                          e.getTaskByIndex(a).id
                        )
                      : void 0;
                  },
                  fromDomElement: function (i) {
                    if (e.config.keyboard_navigation_cells) return null;
                    var a = e.locate(i);
                    return e.isTaskExists(a)
                      ? new e.$keyboardNavigation.TaskRow(a)
                      : null;
                  },
                  getNode: function () {
                    if (
                      e.isTaskExists(this.taskId) &&
                      e.isTaskVisible(this.taskId)
                    )
                      return e.config.show_grid
                        ? e.$grid.querySelector(
                            `.gantt_row[${e.config.task_attribute}="${String(
                              this.taskId
                            ).replaceAll('"', '\\"')}"]`
                          )
                        : e.getTaskNode(this.taskId);
                  },
                  focus: function (i) {
                    if (!i) {
                      const a = e.getTaskPosition(e.getTask(this.taskId)),
                        r = e.getTaskHeight(this.taskId),
                        s = e.getScrollState();
                      let o, l;
                      (o = e.$task ? e.$task.offsetWidth : s.inner_width),
                        (l =
                          e.$grid_data || e.$task_data
                            ? (e.$grid_data || e.$task_data).offsetHeight
                            : s.inner_height);
                      const d =
                        e.config.show_chart && e.$ui.getView("timeline");
                      a.top < s.y || a.top + r > s.y + l
                        ? e.scrollTo(null, a.top - 20)
                        : e.config.scroll_on_click &&
                          d &&
                          (a.left > s.x + o
                            ? e.scrollTo(a.left - e.config.task_scroll_offset)
                            : a.left + a.width < s.x &&
                              e.scrollTo(
                                a.left + a.width - e.config.task_scroll_offset
                              ));
                    }
                    e.$keyboardNavigation.KeyNavNode.prototype.focus.apply(
                      this,
                      [i]
                    ),
                      (function () {
                        var a = e.$ui.getView("grid");
                        if (a && a.$grid_data) {
                          var r = parseInt(a.$grid.scrollLeft),
                            s = parseInt(a.$grid_data.scrollTop),
                            o = a.$config.scrollX;
                          if (o && a.$config.scrollable) {
                            var l = e.$ui.getView(o);
                            l && l.scrollTo(r, s);
                          }
                          var d = a.$config.scrollY;
                          if (d) {
                            var c = e.$ui.getView(d);
                            c && c.scrollTo(r, s);
                          }
                        }
                      })();
                  },
                  keys: {
                    pagedown: function () {
                      e.getVisibleTaskCount() &&
                        this.moveTo(
                          new e.$keyboardNavigation.TaskRow(
                            e.getTaskByIndex(e.getVisibleTaskCount() - 1).id
                          )
                        );
                    },
                    pageup: function () {
                      e.getVisibleTaskCount() &&
                        this.moveTo(
                          new e.$keyboardNavigation.TaskRow(
                            e.getTaskByIndex(0).id
                          )
                        );
                    },
                    up: function () {
                      var i = null,
                        a = e.getPrev(this.taskId);
                      (i = e.isTaskExists(a)
                        ? new e.$keyboardNavigation.TaskRow(a)
                        : new e.$keyboardNavigation.HeaderCell()),
                        this.moveTo(i);
                    },
                    down: function () {
                      var i = e.getNext(this.taskId);
                      e.isTaskExists(i) &&
                        this.moveTo(new e.$keyboardNavigation.TaskRow(i));
                    },
                    "shift+down": function () {
                      e.hasChild(this.taskId) &&
                        !e.getTask(this.taskId).$open &&
                        e.open(this.taskId);
                    },
                    "shift+up": function () {
                      e.hasChild(this.taskId) &&
                        e.getTask(this.taskId).$open &&
                        e.close(this.taskId);
                    },
                    "shift+right": function () {
                      if (!e.isReadonly(this)) {
                        var i = e.getPrevSibling(this.taskId);
                        e.isTaskExists(i) &&
                          !e.isChildOf(this.taskId, i) &&
                          ((e.getTask(i).$open = !0),
                          e.moveTask(this.taskId, -1, i) !== !1 &&
                            e.updateTask(this.taskId));
                      }
                    },
                    "shift+left": function () {
                      if (!e.isReadonly(this)) {
                        var i = e.getParent(this.taskId);
                        e.isTaskExists(i) &&
                          e.moveTask(
                            this.taskId,
                            e.getTaskIndex(i) + 1,
                            e.getParent(i)
                          ) !== !1 &&
                          e.updateTask(this.taskId);
                      }
                    },
                    space: function (i) {
                      e.isSelectedTask(this.taskId)
                        ? e.unselectTask(this.taskId)
                        : e.selectTask(this.taskId);
                    },
                    "ctrl+left": function (i) {
                      e.close(this.taskId);
                    },
                    "ctrl+right": function (i) {
                      e.open(this.taskId);
                    },
                    delete: function (i) {
                      e.isReadonly(this) ||
                        e.$click.buttons.delete(this.taskId);
                    },
                    enter: function () {
                      e.isReadonly(this) || e.showLightbox(this.taskId);
                    },
                    "ctrl+enter": function () {
                      e.isReadonly(this) || e.createTask({}, this.taskId);
                    },
                  },
                }
              )),
              e.$keyboardNavigation.TaskRow.prototype.bindAll(
                e.$keyboardNavigation.TaskRow.prototype.keys
              );
          })(n),
          (function (e) {
            (e.$keyboardNavigation.TaskCell = function (i, a) {
              if (!(i = ot(i, e.config.root_id))) {
                var r = e.getChildren(e.config.root_id);
                r[0] && (i = r[0]);
              }
              (this.taskId = i),
                (this.columnIndex = a || 0),
                e.isTaskExists(this.taskId) &&
                  ((this.index = e.getTaskIndex(this.taskId)),
                  (this.globalIndex = e.getGlobalTaskIndex(this.taskId)));
            }),
              (e.$keyboardNavigation.TaskCell.prototype = e._compose(
                e.$keyboardNavigation.TaskRow,
                {
                  _handlers: null,
                  isValid: function () {
                    return (
                      e.$keyboardNavigation.TaskRow.prototype.isValid.call(
                        this
                      ) && !!e.getGridColumns()[this.columnIndex]
                    );
                  },
                  fallback: function () {
                    var i =
                        e.$keyboardNavigation.TaskRow.prototype.fallback.call(
                          this
                        ),
                      a = i;
                    if (i instanceof e.$keyboardNavigation.TaskRow) {
                      for (
                        var r = e.getGridColumns(), s = this.columnIndex;
                        s >= 0 && !r[s];

                      )
                        s--;
                      r[s] &&
                        (a = new e.$keyboardNavigation.TaskCell(i.taskId, s));
                    }
                    return a;
                  },
                  fromDomElement: function (i) {
                    if (!e.config.keyboard_navigation_cells) return null;
                    var a = e.locate(i);
                    if (e.isTaskExists(a)) {
                      var r = 0,
                        s = Q(i, "data-column-index");
                      return (
                        s && (r = 1 * s.getAttribute("data-column-index")),
                        new e.$keyboardNavigation.TaskCell(a, r)
                      );
                    }
                    return null;
                  },
                  getNode: function () {
                    if (
                      e.isTaskExists(this.taskId) &&
                      (e.isTaskVisible(this.taskId) ||
                        e.config.show_tasks_outside_timescale)
                    ) {
                      if (e.config.show_grid && e.$grid) {
                        var i = e.$grid.querySelector(
                          ".gantt_row[" +
                            e.config.task_attribute +
                            "='" +
                            this.taskId +
                            "']"
                        );
                        return i
                          ? i.querySelector(
                              "[data-column-index='" + this.columnIndex + "']"
                            )
                          : null;
                      }
                      return e.getTaskNode(this.taskId);
                    }
                  },
                  keys: {
                    up: function () {
                      var i = null,
                        a = e.getPrev(this.taskId);
                      (i = e.isTaskExists(a)
                        ? new e.$keyboardNavigation.TaskCell(
                            a,
                            this.columnIndex
                          )
                        : new e.$keyboardNavigation.HeaderCell(
                            this.columnIndex
                          )),
                        this.moveTo(i);
                    },
                    down: function () {
                      var i = e.getNext(this.taskId);
                      e.isTaskExists(i) &&
                        this.moveTo(
                          new e.$keyboardNavigation.TaskCell(
                            i,
                            this.columnIndex
                          )
                        );
                    },
                    left: function () {
                      this.columnIndex > 0 &&
                        this.moveTo(
                          new e.$keyboardNavigation.TaskCell(
                            this.taskId,
                            this.columnIndex - 1
                          )
                        );
                    },
                    right: function () {
                      var i = e.getGridColumns();
                      this.columnIndex < i.length - 1 &&
                        this.moveTo(
                          new e.$keyboardNavigation.TaskCell(
                            this.taskId,
                            this.columnIndex + 1
                          )
                        );
                    },
                    end: function () {
                      var i = e.getGridColumns();
                      this.moveTo(
                        new e.$keyboardNavigation.TaskCell(
                          this.taskId,
                          i.length - 1
                        )
                      );
                    },
                    home: function () {
                      this.moveTo(
                        new e.$keyboardNavigation.TaskCell(this.taskId, 0)
                      );
                    },
                    pagedown: function () {
                      e.getVisibleTaskCount() &&
                        this.moveTo(
                          new e.$keyboardNavigation.TaskCell(
                            e.getTaskByIndex(e.getVisibleTaskCount() - 1).id,
                            this.columnIndex
                          )
                        );
                    },
                    pageup: function () {
                      e.getVisibleTaskCount() &&
                        this.moveTo(
                          new e.$keyboardNavigation.TaskCell(
                            e.getTaskByIndex(0).id,
                            this.columnIndex
                          )
                        );
                    },
                  },
                }
              )),
              e.$keyboardNavigation.TaskCell.prototype.bindAll(
                e.$keyboardNavigation.TaskRow.prototype.keys
              ),
              e.$keyboardNavigation.TaskCell.prototype.bindAll(
                e.$keyboardNavigation.TaskCell.prototype.keys
              );
          })(n),
          gi(n),
          (function (e) {
            e.$keyboardNavigation.dispatcher = {
              isActive: !1,
              activeNode: null,
              globalNode: new e.$keyboardNavigation.GanttNode(),
              enable: function () {
                (this.isActive = !0), this.setActiveNode(this.getActiveNode());
              },
              disable: function () {
                this.isActive = !1;
              },
              isEnabled: function () {
                return !!this.isActive;
              },
              getDefaultNode: function () {
                var i;
                return (
                  (i = e.config.keyboard_navigation_cells
                    ? new e.$keyboardNavigation.TaskCell()
                    : new e.$keyboardNavigation.TaskRow()).isValid() ||
                    (i = i.fallback()),
                  i
                );
              },
              setDefaultNode: function () {
                this.setActiveNode(this.getDefaultNode());
              },
              getActiveNode: function () {
                var i = this.activeNode;
                return i && !i.isValid() && (i = i.fallback()), i;
              },
              fromDomElement: function (i) {
                for (
                  var a = [
                      e.$keyboardNavigation.TaskRow,
                      e.$keyboardNavigation.TaskCell,
                      e.$keyboardNavigation.HeaderCell,
                    ],
                    r = 0;
                  r < a.length;
                  r++
                )
                  if (a[r].prototype.fromDomElement) {
                    var s = a[r].prototype.fromDomElement(i);
                    if (s) return s;
                  }
                return null;
              },
              focusGlobalNode: function () {
                this.blurNode(this.globalNode), this.focusNode(this.globalNode);
              },
              setActiveNode: function (i) {
                var a = !0;
                this.activeNode && this.activeNode.compareTo(i) && (a = !1),
                  this.isEnabled() &&
                    (a && this.blurNode(this.activeNode),
                    (this.activeNode = i),
                    this.focusNode(this.activeNode, !a));
              },
              focusNode: function (i, a) {
                i && i.focus && i.focus(a);
              },
              blurNode: function (i) {
                i && i.blur && i.blur();
              },
              keyDownHandler: function (i) {
                if (
                  !e.$keyboardNavigation.isModal() &&
                  this.isEnabled() &&
                  !i.defaultPrevented
                ) {
                  var a = this.globalNode,
                    r = e.$keyboardNavigation.shortcuts.getCommandFromEvent(i),
                    s = this.getActiveNode();
                  e.$keyboardNavigation.facade.callEvent("onKeyDown", [
                    r,
                    i,
                  ]) !== !1 &&
                    (s
                      ? s.findHandler(r)
                        ? s.doAction(r, i)
                        : a.findHandler(r) && a.doAction(r, i)
                      : this.setDefaultNode());
                }
              },
              _timeout: null,
              awaitsFocus: function () {
                return this._timeout !== null;
              },
              delay: function (i, a) {
                clearTimeout(this._timeout),
                  (this._timeout = setTimeout(
                    e.bind(function () {
                      (this._timeout = null), i();
                    }, this),
                    a || 1
                  ));
              },
              clearDelay: function () {
                clearTimeout(this._timeout);
              },
            };
          })(n),
          (function () {
            var e = n.$keyboardNavigation.dispatcher;
            e.isTaskFocused = function (v) {
              var b = e.activeNode;
              return (
                (b instanceof n.$keyboardNavigation.TaskRow ||
                  b instanceof n.$keyboardNavigation.TaskCell) &&
                b.taskId == v
              );
            };
            var i = function (v) {
                if (
                  n.config.keyboard_navigation &&
                  (n.config.keyboard_navigation_cells || !s(v)) &&
                  !o(v) &&
                  !(function (b) {
                    return !!dt(b.target, ".gantt_cal_light");
                  })(v)
                )
                  return e.keyDownHandler(v);
              },
              a = function (v) {
                if (e.$preventDefault)
                  return v.preventDefault(), n.$container.blur(), !1;
                e.awaitsFocus() || e.focusGlobalNode();
              },
              r = function () {
                if (!e.isEnabled()) return;
                const v =
                  !tt(document.activeElement, n.$container) &&
                  document.activeElement.localName != "body";
                var b = e.getActiveNode();
                if (b && !v) {
                  var g,
                    m,
                    p = b.getNode();
                  p &&
                    p.parentNode &&
                    ((g = p.parentNode.scrollTop),
                    (m = p.parentNode.scrollLeft)),
                    b.focus(!0),
                    p &&
                      p.parentNode &&
                      ((p.parentNode.scrollTop = g),
                      (p.parentNode.scrollLeft = m));
                }
              };
            function s(v) {
              return !!dt(v.target, ".gantt_grid_editor_placeholder");
            }
            function o(v) {
              return !!dt(v.target, ".no_keyboard_navigation");
            }
            function l(v) {
              if (
                !n.config.keyboard_navigation ||
                (!n.config.keyboard_navigation_cells && s(v))
              )
                return !0;
              if (!o(v)) {
                var b,
                  g = e.fromDomElement(v);
                if (
                  g &&
                  (e.activeNode instanceof n.$keyboardNavigation.TaskCell &&
                    tt(v.target, n.$task) &&
                    (g = new n.$keyboardNavigation.TaskCell(
                      g.taskId,
                      e.activeNode.columnIndex
                    )),
                  (b = g),
                  n.config.show_grid &&
                    n.$ui.getView("grid") &&
                    n.config.keyboard_navigation_cells)
                ) {
                  const m = v.target.classList.contains("gantt_row"),
                    p = v.target.closest(".gantt_task_line"),
                    k = n.utils.dom.getNodePosition(n.$grid).x,
                    w = k + n.$grid.offsetWidth,
                    x = n.utils.dom.getNodePosition(document.activeElement).x;
                  if (m || (p && (x < k || w < x))) {
                    let $ = n.$grid.scrollLeft;
                    const S = $ + n.$grid.offsetWidth;
                    let T = 0;
                    m &&
                      ($ = n.utils.dom.getRelativeEventPosition(v, n.$grid).x);
                    for (let E = 0; E < n.config.columns.length; E++) {
                      const C = n.config.columns[E];
                      if (!C.hide && ((T += C.width), $ < T)) {
                        S < T && (T -= C.width), (b.columnIndex = E);
                        break;
                      }
                    }
                  }
                }
                b
                  ? e.isEnabled()
                    ? e.delay(function () {
                        e.setActiveNode(b);
                      })
                    : (e.activeNode = b)
                  : ((e.$preventDefault = !0),
                    setTimeout(function () {
                      e.$preventDefault = !1;
                    }, 300));
              }
            }
            n.attachEvent("onDataRender", function () {
              n.config.keyboard_navigation && r();
            }),
              n.attachEvent("onGanttRender", function () {
                n.$root &&
                  (n.eventRemove(n.$root, "keydown", i),
                  n.eventRemove(n.$container, "focus", a),
                  n.eventRemove(n.$container, "mousedown", l),
                  n.config.keyboard_navigation
                    ? (n.event(n.$root, "keydown", i),
                      n.event(n.$container, "focus", a),
                      n.event(n.$container, "mousedown", l),
                      n.$container.setAttribute("tabindex", "0"))
                    : n.$container.removeAttribute("tabindex"));
              });
            var d = n.attachEvent("onGanttReady", function () {
              if (
                (n.detachEvent(d),
                n.$data.tasksStore.attachEvent("onStoreUpdated", function (b) {
                  if (n.config.keyboard_navigation && e.isEnabled()) {
                    const g = e.getActiveNode(),
                      m = n.$ui.getView("grid");
                    if (!m || !m.$grid_data) return;
                    const p = m.getItemTop(b),
                      k = m.$grid_data.scrollTop,
                      w = k + m.$grid_data.getBoundingClientRect().height;
                    g && g.taskId == b && k <= p && w >= p && r();
                  }
                }),
                n._smart_render)
              ) {
                var v = n._smart_render._redrawTasks;
                n._smart_render._redrawTasks = function (b, g) {
                  if (n.config.keyboard_navigation && e.isEnabled()) {
                    var m = e.getActiveNode();
                    if (m && m.taskId !== void 0) {
                      for (var p = !1, k = 0; k < g.length; k++)
                        if (g[k].id == m.taskId && g[k].start_date) {
                          p = !0;
                          break;
                        }
                      p || g.push(n.getTask(m.taskId));
                    }
                  }
                  return v.apply(this, arguments);
                };
              }
            });
            let c = null,
              u = !1;
            n.attachEvent("onTaskCreated", function (v) {
              return (c = v.id), !0;
            }),
              n.attachEvent("onAfterTaskAdd", function (v, b) {
                if (!n.config.keyboard_navigation) return !0;
                if (e.isEnabled()) {
                  if (
                    (v == c &&
                      ((u = !0),
                      setTimeout(() => {
                        (u = !1), (c = null);
                      })),
                    u && b.type == n.config.types.placeholder)
                  )
                    return;
                  var g = 0,
                    m = e.activeNode;
                  m instanceof n.$keyboardNavigation.TaskCell &&
                    (g = m.columnIndex);
                  var p = n.config.keyboard_navigation_cells
                    ? n.$keyboardNavigation.TaskCell
                    : n.$keyboardNavigation.TaskRow;
                  (b.type == n.config.types.placeholder &&
                    n.config.placeholder_task.focusOnCreate === !1) ||
                    e.setActiveNode(new p(v, g));
                }
              }),
              n.attachEvent("onTaskIdChange", function (v, b) {
                if (!n.config.keyboard_navigation) return !0;
                var g = e.activeNode;
                return e.isTaskFocused(v) && (g.taskId = b), !0;
              });
            var h = setInterval(function () {
              n.config.keyboard_navigation && (e.isEnabled() || e.enable());
            }, 500);
            function _(v) {
              var b = {
                gantt: n.$keyboardNavigation.GanttNode,
                headerCell: n.$keyboardNavigation.HeaderCell,
                taskRow: n.$keyboardNavigation.TaskRow,
                taskCell: n.$keyboardNavigation.TaskCell,
              };
              return b[v] || b.gantt;
            }
            function f(v) {
              for (var b = n.getGridColumns(), g = 0; g < b.length; g++)
                if (b[g].name == v) return g;
              return 0;
            }
            n.attachEvent("onDestroy", function () {
              clearInterval(h);
            });
            var y = {};
            ct(y),
              n.mixin(y, {
                addShortcut: function (v, b, g) {
                  var m = _(g);
                  m && m.prototype.bind(v, b);
                },
                getShortcutHandler: function (v, b) {
                  var g = n.$keyboardNavigation.shortcuts.parse(v);
                  if (g.length) return y.getCommandHandler(g[0], b);
                },
                getCommandHandler: function (v, b) {
                  var g = _(b);
                  if (g && v) return g.prototype.findHandler(v);
                },
                removeShortcut: function (v, b) {
                  var g = _(b);
                  g && g.prototype.unbind(v);
                },
                focus: function (v) {
                  var b,
                    g = v ? v.type : null,
                    m = _(g);
                  switch (g) {
                    case "taskCell":
                      b = new m(v.id, f(v.column));
                      break;
                    case "taskRow":
                      b = new m(v.id);
                      break;
                    case "headerCell":
                      b = new m(f(v.column));
                  }
                  e.delay(function () {
                    b
                      ? e.setActiveNode(b)
                      : (e.enable(),
                        e.getActiveNode()
                          ? e.awaitsFocus() || e.enable()
                          : e.setDefaultNode());
                  });
                },
                getActiveNode: function () {
                  if (e.isEnabled()) {
                    var v = e.getActiveNode(),
                      b =
                        (m = v) instanceof n.$keyboardNavigation.GanttNode
                          ? "gantt"
                          : m instanceof n.$keyboardNavigation.HeaderCell
                          ? "headerCell"
                          : m instanceof n.$keyboardNavigation.TaskRow
                          ? "taskRow"
                          : m instanceof n.$keyboardNavigation.TaskCell
                          ? "taskCell"
                          : null,
                      g = n.getGridColumns();
                    switch (b) {
                      case "taskCell":
                        return {
                          type: "taskCell",
                          id: v.taskId,
                          column: g[v.columnIndex].name,
                        };
                      case "taskRow":
                        return { type: "taskRow", id: v.taskId };
                      case "headerCell":
                        return { type: "headerCell", column: g[v.index].name };
                    }
                  }
                  var m;
                  return null;
                },
              }),
              (n.$keyboardNavigation.facade = y),
              (n.ext.keyboardNavigation = y),
              (n.focus = function () {
                y.focus();
              }),
              (n.addShortcut = y.addShortcut),
              (n.getShortcutHandler = y.getShortcutHandler),
              (n.removeShortcut = y.removeShortcut);
          })();
      })(t);
    },
    quick_info: function (t) {
      t.ext || (t.ext = {}),
        (t.ext.quickInfo = new fi(t)),
        (t.config.quickinfo_buttons = ["icon_edit", "icon_delete"]),
        (t.config.quick_info_detached = !0),
        (t.config.show_quick_info = !0),
        (t.templates.quick_info_title = function (a, r, s) {
          return s.text.substr(0, 50);
        }),
        (t.templates.quick_info_content = function (a, r, s) {
          return s.details || s.text;
        }),
        (t.templates.quick_info_date = function (a, r, s) {
          return t.templates.task_time(a, r, s);
        }),
        (t.templates.quick_info_class = function (a, r, s) {
          return "";
        }),
        t.attachEvent("onTaskClick", function (a, r) {
          const s = t.utils.dom.closest(r.target, ".gantt_add"),
            o = t.utils.dom.closest(r.target, ".gantt_close"),
            l = t.utils.dom.closest(r.target, ".gantt_open");
          return (
            !s &&
              !o &&
              !l &&
              setTimeout(function () {
                t.ext.quickInfo.show(a);
              }, 0),
            !0
          );
        });
      const n = [
          "onViewChange",
          "onLightbox",
          "onBeforeTaskDelete",
          "onBeforeDrag",
        ],
        e = function () {
          return t.ext.quickInfo.hide(), !0;
        };
      for (let a = 0; a < n.length; a++) t.attachEvent(n[a], e);
      function i() {
        return (
          t.ext.quickInfo.hide(), (t.ext.quickInfo._quickInfoBox = null), !0
        );
      }
      t.attachEvent("onEmptyClick", function (a) {
        let r = !0;
        const s = document.querySelector(".gantt_cal_quick_info");
        s && t.utils.dom.isChildOf(a.target, s) && (r = !1), r && e();
      }),
        t.attachEvent("onGanttReady", i),
        t.attachEvent("onDestroy", i),
        t.event(window, "keydown", function (a) {
          a.keyCode === 27 && t.ext.quickInfo.hide();
        }),
        (t.showQuickInfo = function () {
          t.ext.quickInfo.show.apply(t.ext.quickInfo, arguments);
        }),
        (t.hideQuickInfo = function () {
          t.ext.quickInfo.hide.apply(t.ext.quickInfo, arguments);
        });
    },
    tooltip: function (t) {
      (t.config.tooltip_timeout = 30),
        (t.config.tooltip_offset_y = 20),
        (t.config.tooltip_offset_x = 10),
        (t.config.tooltip_hide_timeout = 30);
      const n = new vi(t);
      (t.ext.tooltips = n),
        t.attachEvent("onGanttReady", function () {
          t.$root &&
            n.tooltipFor({
              selector:
                "[" + t.config.task_attribute + "]:not(.gantt_task_row)",
              html: (e) => {
                if (t.config.touch && !t.config.touch_tooltip) return;
                const i = t.locate(e);
                if (t.isTaskExists(i)) {
                  const a = t.getTask(i);
                  return t.templates.tooltip_text(a.start_date, a.end_date, a);
                }
                return null;
              },
              global: !1,
            });
        }),
        t.attachEvent("onDestroy", function () {
          n.destructor();
        }),
        t.attachEvent("onLightbox", function () {
          n.hideTooltip();
        }),
        t.attachEvent("onBeforeTooltip", function () {
          if (t.getState().link_source_id) return !1;
        }),
        t.attachEvent("onGanttScroll", function () {
          n.hideTooltip();
        });
    },
    undo: function (t) {
      const n = new yi(t),
        e = new ki(n, t);
      function i(c, u) {
        return String(c) === String(u);
      }
      function a(c, u, h) {
        c && (i(c.id, u) && (c.id = h), i(c.parent, u) && (c.parent = h));
      }
      function r(c, u, h) {
        a(c.value, u, h), a(c.oldValue, u, h);
      }
      function s(c, u, h) {
        c &&
          (i(c.source, u) && (c.source = h), i(c.target, u) && (c.target = h));
      }
      function o(c, u, h) {
        s(c.value, u, h), s(c.oldValue, u, h);
      }
      function l(c, u, h) {
        const _ = n;
        for (let f = 0; f < c.length; f++) {
          const y = c[f];
          for (let v = 0; v < y.commands.length; v++)
            y.commands[v].entity === _.command.entity.task
              ? r(y.commands[v], u, h)
              : y.commands[v].entity === _.command.entity.link &&
                o(y.commands[v], u, h);
        }
      }
      function d(c, u, h) {
        const _ = n;
        for (let f = 0; f < c.length; f++) {
          const y = c[f];
          for (let v = 0; v < y.commands.length; v++) {
            const b = y.commands[v];
            b.entity === _.command.entity.link &&
              (b.value && b.value.id === u && (b.value.id = h),
              b.oldValue && b.oldValue.id === u && (b.oldValue.id = h));
          }
        }
      }
      (t.config.undo = !0),
        (t.config.redo = !0),
        (t.config.undo_types = { link: "link", task: "task" }),
        (t.config.undo_actions = {
          update: "update",
          remove: "remove",
          add: "add",
          move: "move",
        }),
        t.ext || (t.ext = {}),
        (t.ext.undo = {
          undo: () => n.undo(),
          redo: () => n.redo(),
          getUndoStack: () => n.getUndoStack(),
          setUndoStack: (c) => n.setUndoStack(c),
          getRedoStack: () => n.getRedoStack(),
          setRedoStack: (c) => n.setRedoStack(c),
          clearUndoStack: () => n.clearUndoStack(),
          clearRedoStack: () => n.clearRedoStack(),
          saveState: (c, u) => e.store(c, u, !0),
          getInitialState: (c, u) =>
            u === t.config.undo_types.link
              ? e.getInitialLink(c)
              : e.getInitialTask(c),
        }),
        (t.undo = t.ext.undo.undo),
        (t.redo = t.ext.undo.redo),
        (t.getUndoStack = t.ext.undo.getUndoStack),
        (t.getRedoStack = t.ext.undo.getRedoStack),
        (t.clearUndoStack = t.ext.undo.clearUndoStack),
        (t.clearRedoStack = t.ext.undo.clearRedoStack),
        t.attachEvent("onTaskIdChange", (c, u) => {
          const h = n;
          l(h.getUndoStack(), c, u), l(h.getRedoStack(), c, u);
        }),
        t.attachEvent("onLinkIdChange", (c, u) => {
          const h = n;
          d(h.getUndoStack(), c, u), d(h.getRedoStack(), c, u);
        }),
        t.attachEvent("onGanttReady", () => {
          n.updateConfigs();
        });
    },
    grouping: function (t) {
      function n(l, d, c) {
        if (!l || (Array.isArray(c) && !c[0])) return 0;
        if (l && !Array.isArray(c)) {
          const h = [];
          return (
            l.map(function (_) {
              h.push({ resource_id: _, value: 8 });
            }),
            h
          );
        }
        if (
          (c[0].resource_id || (c = [{ resource_id: c, value: 8 }]),
          typeof l == "string" && (l = l.split(",")),
          l.length == 1)
        )
          return (c[0].resource_id = l[0]), [c[0]];
        const u = [];
        l.length > 1 && (l = [...new Set(l)]);
        for (let h = 0; h < l.length; h++) {
          let _ = l[h],
            f = c
              .map(function (y) {
                return y.resource_id;
              })
              .reduce(function (y, v, b) {
                return v === _ && y.push(b), y;
              }, []);
          if (f.length > 0)
            f.forEach((y) => {
              (c[y].resource_id = _), u.push(c[y]);
            });
          else {
            let y = t.copy(c[0]);
            (y.resource_id = _), u.push(y);
          }
        }
        return u;
      }
      function e(l, d, c) {
        return l;
      }
      function i(l, d) {
        for (var c = !1, u = !1, h = 0; h < l.length; h++) {
          var _ = l[h][d];
          if (
            Array.isArray(_) &&
            ((u = !0), _.length && _[0].resource_id !== void 0)
          ) {
            c = !0;
            break;
          }
        }
        return { haveArrays: u, haveResourceAssignments: c };
      }
      function a(l) {
        return l.map(r).sort().join(",");
      }
      function r(l) {
        return String(l && typeof l == "object" ? l.resource_id : l);
      }
      function s(l, d) {
        return l[d] instanceof Array ? (l[d].length ? a(l[d]) : 0) : l[d];
      }
      function o() {
        const l = this;
        this.$data.tasksStore._listenerToDrop &&
          this.$data.tasksStore.detachEvent(
            this.$data.tasksStore._listenerToDrop
          );
        const d = Xt(function () {
          if (
            (l._groups.is_active() &&
              i(t.getTaskByTime(), l._groups.relation_property).haveArrays &&
              (l._groups.dynamicGroups = !0),
            l._groups.regroup && t.getScrollState)
          ) {
            const c = t.getScrollState();
            l._groups.regroup(), c && t.scrollTo(c.x, c.y);
          }
          return !0;
        });
        this.$data.tasksStore.attachEvent("onAfterUpdate", function () {
          return d.$pending || d(), !0;
        }),
          t.attachEvent("onParse", function () {
            d.$pending || (l._groups.is_active() && d());
          });
      }
      (t._groups = {
        relation_property: null,
        relation_id_property: "$group_id",
        group_id: null,
        group_text: null,
        loading: !1,
        loaded: 0,
        dynamicGroups: !1,
        set_relation_value: void 0,
        _searchCache: null,
        init: function (l) {
          var d = this;
          l.attachEvent("onClear", function () {
            d.clear();
          }),
            d.clear();
          var c = l.$data.tasksStore.getParent;
          (this._searchCache = null),
            l.attachEvent("onBeforeTaskMove", function (h, _, f) {
              var y = _ === this.config.root_id,
                v =
                  this._groups.dynamicGroups &&
                  !(this._groups.set_relation_value instanceof Function);
              if (d.is_active() && (y || v)) return !1;
              var b = l.getTask(h);
              if (
                this._groups.save_tree_structure &&
                l.isTaskExists(b.parent) &&
                l.isTaskExists(_)
              ) {
                var g = l.getTask(b.parent),
                  m = l.getTask(_);
                m.$virtual &&
                  l.isChildOf(g.id, m.id) &&
                  (b.parent = l.config.root_id);
                let p = !1,
                  k = m;
                for (; k; )
                  h == k.parent && (p = !0),
                    (k = l.isTaskExists(k.parent) ? l.getTask(k.parent) : null);
                if (p) return !1;
              }
              return !0;
            }),
            l.attachEvent("onRowDragStart", function (h, _) {
              var f = l.getTask(h);
              return (
                this._groups.save_tree_structure &&
                  l.isTaskExists(f.parent) &&
                  l.config.order_branch &&
                  l.config.order_branch != "marker" &&
                  (f.$initial_parent = f.parent),
                !0
              );
            }),
            l.attachEvent("onRowDragEnd", function (h, _) {
              if (l.config.order_branch && l.config.order_branch != "marker") {
                var f = l.getTask(h);
                if (f.$initial_parent) {
                  if (f.parent == l.config.root_id) {
                    var y = l.getTask(f.$rendered_parent),
                      v = l.getTask(f.$initial_parent),
                      b = !1;
                    this._groups.dynamicGroups &&
                      y[this._groups.group_id] != v[this._groups.group_id] &&
                      (b = !0),
                      this._groups.dynamicGroups ||
                        y[this._groups.group_id] ==
                          v[this._groups.relation_property] ||
                        (b = !0),
                      b && (f.parent = f.$initial_parent);
                  }
                  delete f.$initial_parent;
                }
              }
            }),
            (l.$data.tasksStore._listenerToDrop =
              l.$data.tasksStore.attachEvent("onStoreUpdated", l.bind(o, l))),
            (l.$data.tasksStore.getParent = function (h) {
              return d.is_active()
                ? d.get_parent(l, h)
                : c.apply(this, arguments);
            });
          var u = l.$data.tasksStore.setParent;
          (l.$data.tasksStore.setParent = function (h, _) {
            if (!d.is_active()) return u.apply(this, arguments);
            if (d.set_relation_value instanceof Function && l.isTaskExists(_)) {
              var f = (b = l.getTask(_))[d.relation_id_property];
              if (!b.$virtual) {
                var y = s(b, d.relation_property);
                d._searchCache || d._buildCache();
                var v = d._searchCache[y];
                f = l.getTask(v)[d.relation_id_property];
              }
              h[d.group_id] === void 0 && (h[d.group_id] = f),
                d.save_tree_structure &&
                  h[d.group_id] != f &&
                  (h[d.group_id] = f),
                f && (f = typeof f == "string" ? f.split(",") : [f]),
                (h[d.relation_property] =
                  d.set_relation_value(f, h.id, h[d.relation_property]) || f);
            } else if (l.isTaskExists(_)) {
              var b = l.getTask(_);
              d.dynamicGroups ||
                (b.$virtual
                  ? (h[d.relation_property] = b[d.relation_id_property])
                  : (h[d.relation_property] = b[d.relation_property])),
                this._setParentInner.apply(this, arguments);
            } else
              d.dynamicGroups &&
                (h[d.group_id] === void 0 ||
                  (!h.$virtual && h[d.relation_property][0] === [][0])) &&
                (h[d.relation_property] !== d.group_id
                  ? (h[d.relation_property] = h[d.relation_property] || 0)
                  : (h[d.relation_property] = 0));
            return l.isTaskExists(_) &&
              ((h.$rendered_parent = _), !l.getTask(_).$virtual)
              ? u.apply(this, arguments) || _
              : void 0;
          }),
            l.attachEvent("onBeforeTaskDisplay", function (h, _) {
              return !(
                d.is_active() &&
                _.type == l.config.types.project &&
                !_.$virtual
              );
            }),
            l.attachEvent("onBeforeParse", function () {
              (d.loading = !0), d._clearCache();
            }),
            l.attachEvent("onTaskLoading", function () {
              return (
                d.is_active() &&
                  (d.loaded--,
                  d.loaded <= 0 &&
                    ((d.loading = !1),
                    d._clearCache(),
                    l.eachTask(
                      l.bind(function (h) {
                        this.get_parent(l, h);
                      }, d)
                    ))),
                !0
              );
            }),
            l.attachEvent("onParse", function () {
              (d.loading = !1), (d.loaded = 0);
            });
        },
        _clearCache: function () {
          this._searchCache = null;
        },
        _buildCache: function () {
          this._searchCache = {};
          for (var l = t.$data.tasksStore.getItems(), d = 0; d < l.length; d++)
            this._searchCache[l[d][this.relation_id_property]] = l[d].id;
        },
        get_parent: function (l, d, c) {
          d.id === void 0 && (d = l.getTask(d));
          var u = s(d, this.relation_property);
          if (this.save_tree_structure && l.isTaskExists(d.parent)) {
            let f = l.getTask(d.parent);
            const y = s(f, this.relation_property);
            if (f.type != "project" && u == y) return d.parent;
          }
          if (this._groups_pull[u] === d.id) return l.config.root_id;
          if (this._groups_pull[u] !== void 0) return this._groups_pull[u];
          var h = l.config.root_id;
          if (!this.loading && u !== void 0) {
            this._searchCache || this._buildCache();
            var _ = this._searchCache[u];
            l.isTaskExists(_) && _ != d.id && (h = this._searchCache[u]),
              (this._groups_pull[u] = h);
          }
          return h;
        },
        clear: function () {
          (this._groups_pull = {}),
            (this.relation_property = null),
            (this.group_id = null),
            (this.group_text = null),
            this._clearCache();
        },
        is_active: function () {
          return !!this.relation_property;
        },
        generate_sections: function (l, d) {
          for (var c = [], u = 0; u < l.length; u++) {
            var h = t.copy(l[u]);
            (h.type = d),
              h.open === void 0 && (h.open = !0),
              (h.$virtual = !0),
              (h.readonly = !0),
              (h[this.relation_id_property] = h[this.group_id]),
              (h.text = h[this.group_text]),
              c.push(h);
          }
          return c;
        },
        clear_temp_tasks: function (l) {
          for (var d = 0; d < l.length; d++)
            l[d].$virtual && (l.splice(d, 1), d--);
        },
        generate_data: function (l, d) {
          var c = l.getLinks(),
            u = l.getTaskByTime();
          this.clear_temp_tasks(u),
            u.forEach(function (f) {
              f.$calculate_duration = !1;
            });
          var h = [];
          this.is_active() &&
            d &&
            d.length &&
            (h = this.generate_sections(d, l.config.types.project));
          var _ = { links: c };
          return (_.data = h.concat(u)), _;
        },
        update_settings: function (l, d, c) {
          this.clear(),
            (this.relation_property = l),
            (this.group_id = d),
            (this.group_text = c);
        },
        group_tasks: function (l, d, c, u, h) {
          this.update_settings(c, u, h);
          var _ = this.generate_data(l, d);
          this.loaded = _.data.length;
          var f = [];
          l.eachTask(function (v) {
            l.isSelectedTask(v.id) && f.push(v.id);
          }),
            l._clear_data();
          var y = l.config.auto_scheduling_initial;
          (l.config.auto_scheduling_initial = !1),
            l.parse(_),
            f.forEach(function (v) {
              l.isTaskExists(v) && l.selectTask(v);
            }),
            (l.config.auto_scheduling_initial = y);
        },
      }),
        t._groups.init(t),
        (t.groupBy = function (l) {
          var d = this,
            c = t.getTaskByTime();
          (this._groups.set_relation_value = l.set_relation_value),
            (this._groups.dynamicGroups = !1),
            (this._groups.save_tree_structure = l.save_tree_structure);
          var u = i(c, l.relation_property);
          u.haveArrays && (this._groups.dynamicGroups = !0),
            this._groups.set_relation_value ||
              (this._groups.set_relation_value = (function (y) {
                return y.haveResourceAssignments ? n : y.haveArrays ? e : null;
              })(u)),
            ((l = l || {}).default_group_label =
              l.default_group_label ||
              this.locale.labels.default_group ||
              "None");
          var h = l.relation_property || null,
            _ = l.group_id || "key",
            f = l.group_text || "label";
          (this._groups.regroup = function () {
            var y = t.getTaskByTime(),
              v = {},
              b = !1;
            y.forEach(function (m) {
              m.$virtual &&
                m.$open !== void 0 &&
                ((v[m[_]] = m.$open), (b = !0));
            });
            var g = (function (m, p, k) {
              var w;
              return (
                (w = m.groups
                  ? k._groups.dynamicGroups
                    ? (function (x, $) {
                        var S = {},
                          T = [],
                          E = {},
                          C = $.relation_property,
                          D = $.delimiter || ",",
                          A = !1,
                          I = 0;
                        st($.groups, function (R) {
                          R.default && ((A = !0), (I = R.group_id)),
                            (E[R.key || R[$.group_id]] = R);
                        });
                        for (var M = 0; M < x.length; M++) {
                          var L,
                            N,
                            P = x[M][C];
                          if (Lt(P))
                            if (P.length > 0)
                              (L = a(P)),
                                (N = P.map(function (R, B) {
                                  var H;
                                  return (
                                    (H =
                                      R && typeof R == "object"
                                        ? R.resource_id
                                        : R),
                                    (R = E[H]).label || R.text
                                  );
                                }).sort()),
                                (N = [...new Set(N)].join(D));
                            else {
                              if (A) continue;
                              (L = 0), (N = $.default_group_label);
                            }
                          else if (P) N = E[(L = P)].label || E[L].text;
                          else {
                            if (A) continue;
                            (L = 0), (N = $.default_group_label);
                          }
                          L !== void 0 &&
                            S[L] === void 0 &&
                            ((S[L] = { key: L, label: N }),
                            L === I && (S[L].default = !0),
                            (S[L][$.group_text] = N),
                            (S[L][$.group_id] = L));
                        }
                        return (
                          (T = (function (R) {
                            var B = [];
                            for (var H in R)
                              R.hasOwnProperty(H) && B.push(R[H]);
                            return B;
                          })(S)).forEach(function (R) {
                            R.key == I && (R.default = !0);
                          }),
                          T
                        );
                      })(p, m)
                    : m.groups
                  : null),
                w
              );
            })(l, y, t);
            return (
              g &&
                b &&
                g.forEach(function (m) {
                  v[m[_]] !== void 0 && (m.open = v[m[_]]);
                }),
              d._groups.group_tasks(d, g, h, _, f),
              !0
            );
          }),
            this._groups.regroup();
        }),
        t.$services
          .getService("state")
          .registerProvider("groupBy", function () {
            return {
              group_mode: t._groups.is_active()
                ? t._groups.relation_property
                : null,
            };
          });
    },
    marker: function (t) {
      function n(i) {
        if (!t.config.show_markers || !i.start_date) return !1;
        var a = t.getState();
        if (
          +i.start_date > +a.max_date ||
          ((!i.end_date || +i.end_date < +a.min_date) &&
            +i.start_date < +a.min_date)
        )
          return;
        var r = document.createElement("div");
        r.setAttribute("data-marker-id", i.id);
        var s = "gantt_marker";
        t.templates.marker_class && (s += " " + t.templates.marker_class(i)),
          i.css && (s += " " + i.css),
          t.templates.marker_class && (s += " " + t.templates.marker_class(i)),
          i.title && (r.title = i.title),
          (r.className = s);
        var o = t.posFromDate(i.start_date);
        r.style.left = o + "px";
        let l = Math.max(t.getRowTop(t.getVisibleTaskCount()), 0) + "px";
        if (
          (t.config.timeline_placeholder &&
            t.$task_data &&
            (l = t.$task_data.scrollHeight + "px"),
          (r.style.height = l),
          i.end_date)
        ) {
          var d = t.posFromDate(i.end_date);
          r.style.width = Math.max(d - o, 0) + "px";
        }
        if (i.text) {
          let c = null;
          (c = typeof i.text == "function" ? i.text(i) : i.text),
            c &&
              (t.config.external_render && t.config.external_render.isElement(c)
                ? ((r.innerHTML = "<div class='gantt_marker_content' ></div>"),
                  t.config.external_render.renderElement(
                    c,
                    r.querySelector(".gantt_marker_content")
                  ))
                : (r.innerHTML =
                    "<div class='gantt_marker_content' >" + i.text + "</div>"));
        }
        return r;
      }
      function e() {
        if (t.$task_data && t.$root.contains(t.$task_data)) {
          if (!t.$marker_area || !t.$task_data.contains(t.$marker_area)) {
            var i = document.createElement("div");
            (i.className = "gantt_marker_area"),
              t.$task_data.appendChild(i),
              (t.$marker_area = i);
          }
        } else t.$marker_area = null;
      }
      t._markers ||
        (t._markers = t.createDatastore({
          name: "marker",
          initItem: function (i) {
            return (i.id = i.id || t.uid()), i;
          },
        })),
        (t.config.show_markers = !0),
        t.attachEvent("onBeforeGanttRender", function () {
          t.$marker_area || e();
        }),
        t.attachEvent("onDataRender", function () {
          t.$marker_area || (e(), t.renderMarkers());
        }),
        t.attachEvent("onGanttLayoutReady", function () {
          t.attachEvent(
            "onBeforeGanttRender",
            function () {
              t.$marker_area && (t.$marker_area.innerHTML = ""),
                e(),
                t.$services
                  .getService("layers")
                  .createDataRender({
                    name: "marker",
                    defaultContainer: function () {
                      return t.$marker_area;
                    },
                  })
                  .addLayer(n);
            },
            { once: !0 }
          );
        }),
        (t.getMarker = function (i) {
          return this._markers ? this._markers.getItem(i) : null;
        }),
        (t.addMarker = function (i) {
          return this._markers.addItem(i);
        }),
        (t.deleteMarker = function (i) {
          return !!this._markers.exists(i) && (this._markers.removeItem(i), !0);
        }),
        (t.updateMarker = function (i) {
          this._markers.refresh(i);
        }),
        (t._getMarkers = function () {
          return this._markers.getItems();
        }),
        (t.renderMarkers = function () {
          this._markers.refresh();
        });
    },
    multiselect: function (t) {
      (t.config.multiselect = !0),
        (t.config.multiselect_one_level = !1),
        (t._multiselect = {
          _selected: {},
          _one_level: !1,
          _active: !0,
          _first_selected_when_shift: null,
          getDefaultSelected: function () {
            var n = this.getSelected();
            return n.length ? n[n.length - 1] : null;
          },
          setFirstSelected: function (n) {
            this._first_selected_when_shift = n;
          },
          getFirstSelected: function () {
            return this._first_selected_when_shift;
          },
          isActive: function () {
            return this.updateState(), this._active;
          },
          updateState: function () {
            this._one_level = t.config.multiselect_one_level;
            var n = this._active;
            (this._active = t.config.select_task),
              this._active != n && this.reset();
          },
          reset: function () {
            this._selected = {};
          },
          setLastSelected: function (n) {
            t.$data.tasksStore.silent(function () {
              var e = t.$data.tasksStore;
              n ? e.select(n + "") : e.unselect(null);
            });
          },
          getLastSelected: function () {
            var n = t.$data.tasksStore.getSelectedId();
            return n && t.isTaskExists(n) ? n : null;
          },
          select: function (n, e) {
            return (
              !!(
                n &&
                t.callEvent("onBeforeTaskMultiSelect", [n, !0, e]) &&
                t.callEvent("onBeforeTaskSelected", [n])
              ) &&
              ((this._selected[n] = !0),
              this.setLastSelected(n),
              this.afterSelect(n),
              t.callEvent("onTaskMultiSelect", [n, !0, e]),
              t.callEvent("onTaskSelected", [n]),
              !0)
            );
          },
          toggle: function (n, e) {
            this._selected[n] ? this.unselect(n, e) : this.select(n, e);
          },
          unselect: function (n, e) {
            n &&
              t.callEvent("onBeforeTaskMultiSelect", [n, !1, e]) &&
              ((this._selected[n] = !1),
              this.getLastSelected() == n &&
                this.setLastSelected(this.getDefaultSelected()),
              this.afterSelect(n),
              t.callEvent("onTaskMultiSelect", [n, !1, e]),
              t.callEvent("onTaskUnselected", [n]));
          },
          isSelected: function (n) {
            return !(!t.isTaskExists(n) || !this._selected[n]);
          },
          getSelected: function () {
            var n = [];
            for (var e in this._selected)
              this._selected[e] && t.isTaskExists(e)
                ? n.push(e)
                : (this._selected[e] = !1);
            return (
              n.sort(function (i, a) {
                return t.getGlobalTaskIndex(i) > t.getGlobalTaskIndex(a)
                  ? 1
                  : -1;
              }),
              n
            );
          },
          forSelected: function (n) {
            for (var e = this.getSelected(), i = 0; i < e.length; i++) n(e[i]);
          },
          isSameLevel: function (n) {
            if (!this._one_level) return !0;
            var e = this.getLastSelected();
            return (
              !e ||
              !t.isTaskExists(e) ||
              !t.isTaskExists(n) ||
              t.calculateTaskLevel(t.getTask(e)) ==
                t.calculateTaskLevel(t.getTask(n))
            );
          },
          afterSelect: function (n) {
            t.isTaskExists(n) &&
              t._quickRefresh(function () {
                t.refreshTask(n);
              });
          },
          doSelection: function (n) {
            if (!this.isActive() || t._is_icon_open_click(n)) return !1;
            var e = t.locate(n);
            if (!e || !t.callEvent("onBeforeMultiSelect", [n])) return !1;
            var i = this.getSelected(),
              a = this.getFirstSelected(),
              r = !1,
              s = this.getLastSelected(),
              o = t.config.multiselect,
              l = function () {
                const c = t.ext.inlineEditors;
                if (c && c.getState) {
                  const h = c.getState(),
                    _ = c.locateCell(n.target);
                  t.config.inline_editors_multiselect_open &&
                    _ &&
                    c.getEditorConfig(_.columnName) &&
                    ((c.isVisible() &&
                      h.id == _.id &&
                      h.columnName == _.columnName) ||
                      c.startEdit(_.id, _.columnName));
                }
                this.setFirstSelected(e),
                  this.isSelected(e) || this.select(e, n),
                  (i = this.getSelected());
                for (var u = 0; u < i.length; u++)
                  i[u] !== e && this.unselect(i[u], n);
              }.bind(this),
              d = function () {
                if (s) {
                  if (e) {
                    var c = t.getGlobalTaskIndex(this.getFirstSelected()),
                      u = t.getGlobalTaskIndex(e),
                      h = t.getGlobalTaskIndex(s);
                    (c != -1 && h != -1) || ((c = u), this.reset());
                    for (var _ = s; t.getGlobalTaskIndex(_) !== c; )
                      this.unselect(_, n),
                        (_ = c > h ? t.getNext(_) : t.getPrev(_));
                    for (_ = e; t.getGlobalTaskIndex(_) !== c; )
                      this.select(_, n) && !r && ((r = !0), (a = _)),
                        (_ = c > u ? t.getNext(_) : t.getPrev(_));
                  }
                } else s = e;
              }.bind(this);
            return (
              o && (n.ctrlKey || n.metaKey)
                ? (this.isSelected(e) || this.setFirstSelected(e),
                  e && this.toggle(e, n))
                : o && n.shiftKey
                ? ((t.isTaskExists(this.getFirstSelected()) &&
                    this.getFirstSelected() !== null) ||
                    this.setFirstSelected(e),
                  i.length ? d() : l())
                : l(),
              this.isSelected(e)
                ? this.setLastSelected(e)
                : a
                ? e == s &&
                  this.setLastSelected(
                    n.shiftKey ? a : this.getDefaultSelected()
                  )
                : this.setLastSelected(null),
              this.getSelected().length || this.setLastSelected(null),
              (this.getLastSelected() &&
                this.isSelected(this.getFirstSelected())) ||
                this.setFirstSelected(this.getLastSelected()),
              !0
            );
          },
        }),
        (function () {
          var n = t.selectTask;
          t.selectTask = function (i) {
            if (!(i = ot(i, this.config.root_id))) return !1;
            var a = t._multiselect,
              r = i;
            return (
              a.isActive()
                ? (a.select(i, null) && a.setLastSelected(i),
                  a.setFirstSelected(a.getLastSelected()))
                : (r = n.call(this, i)),
              r
            );
          };
          var e = t.unselectTask;
          (t.unselectTask = function (i) {
            var a = t._multiselect,
              r = a.isActive();
            (i = i || a.getLastSelected()) &&
              r &&
              (a.unselect(i, null),
              i == a.getLastSelected() && a.setLastSelected(null),
              t.refreshTask(i),
              a.setFirstSelected(a.getLastSelected()));
            var s = i;
            return r || (s = e.call(this, i)), s;
          }),
            (t.toggleTaskSelection = function (i) {
              var a = t._multiselect;
              i &&
                a.isActive() &&
                (a.toggle(i), a.setFirstSelected(a.getLastSelected()));
            }),
            (t.getSelectedTasks = function () {
              var i = t._multiselect;
              return i.isActive(), i.getSelected();
            }),
            (t.eachSelectedTask = function (i) {
              return this._multiselect.forSelected(i);
            }),
            (t.isSelectedTask = function (i) {
              return this._multiselect.isSelected(i);
            }),
            (t.getLastSelectedTask = function () {
              return this._multiselect.getLastSelected();
            }),
            t.attachEvent("onGanttReady", function () {
              var i = t.$data.tasksStore.isSelected;
              t.$data.tasksStore.isSelected = function (a) {
                return t._multiselect.isActive()
                  ? t._multiselect.isSelected(a)
                  : i.call(this, a);
              };
            });
        })(),
        t.attachEvent("onTaskIdChange", function (n, e) {
          var i = t._multiselect;
          if (!i.isActive()) return !0;
          t.isSelectedTask(n) && (i.unselect(n, null), i.select(e, null));
        }),
        t.attachEvent("onAfterTaskDelete", function (n, e) {
          var i = t._multiselect;
          if (!i.isActive()) return !0;
          i._selected[n] &&
            ((i._selected[n] = !1), i.setLastSelected(i.getDefaultSelected())),
            i.forSelected(function (a) {
              t.isTaskExists(a) || i.unselect(a, null);
            });
        }),
        t.attachEvent("onBeforeTaskMultiSelect", function (n, e, i) {
          const a = t._multiselect;
          if (e && a.isActive()) {
            let r = t.getSelectedId(),
              s = null;
            r && (s = t.getTask(r));
            let o = t.getTask(n),
              l = !1;
            if (
              (s && s.$level != o.$level && (l = !0),
              t.config.multiselect_one_level && l && !i.ctrlKey && !i.shiftKey)
            )
              return !0;
            if (a._one_level) return a.isSameLevel(n);
          }
          return !0;
        }),
        t.attachEvent("onTaskClick", function (n, e) {
          return (
            t._multiselect.doSelection(e) && t.callEvent("onMultiSelect", [e]),
            !0
          );
        });
    },
    overlay: function (t) {
      t.ext || (t.ext = {}), (t.ext.overlay = {});
      var n = {};
      function e() {
        if (t.$task_data) {
          t.event(t.$task_data, "scroll", function (l) {
            t.ext.$overlay_area &&
              (t.ext.$overlay_area.style.top = l.target.scrollTop + "px");
          });
          var o = document.createElement("div");
          (o.className = "gantt_overlay_area"),
            t.$task_data.appendChild(o),
            (t.ext.$overlay_area = o),
            i();
        }
      }
      function i() {
        for (var o in n) {
          var l = n[o];
          l.isAttached || a(l);
        }
      }
      function a(o) {
        t.ext.$overlay_area.appendChild(o.node), (o.isAttached = !0);
      }
      function r() {
        t.ext.$overlay_area.style.display = "block";
      }
      function s() {
        var o = !1;
        for (var l in n)
          if (n[l].isVisible) {
            o = !0;
            break;
          }
        o || (t.ext.$overlay_area.style.display = "none");
      }
      t.attachEvent("onBeforeGanttRender", function () {
        if (t.$root) {
          if ((t.ext.$overlay_area || e(), !t.ext.$overlay_area.isConnected))
            for (var o in ((t.ext.$overlay_area.innerHTML = ""),
            t.ext.$overlay_area.remove(),
            (t.ext.$overlay_area = null),
            e(),
            n))
              n[o].isAttached = !1;
          i(), s();
        }
      }),
        t.attachEvent("onGanttReady", function () {
          t.$root && (e(), i(), s());
        }),
        (t.ext.overlay.addOverlay = function (o, l) {
          return (
            (l = l || t.uid()),
            (n[l] = (function (d, c) {
              var u = document.createElement("div");
              return (
                u.setAttribute("data-overlay-id", d),
                (u.className = "gantt_overlay"),
                (u.style.display = "none"),
                { id: d, render: c, isVisible: !1, isAttached: !1, node: u }
              );
            })(l, o)),
            l
          );
        }),
        (t.ext.overlay.deleteOverlay = function (o) {
          return !!n[o] && (delete n[o], s(), !0);
        }),
        (t.ext.overlay.getOverlaysIds = function () {
          var o = [];
          for (var l in n) o.push(l);
          return o;
        }),
        (t.ext.overlay.refreshOverlay = function (o) {
          r(),
            (n[o].isVisible = !0),
            (n[o].node.innerHTML = ""),
            (n[o].node.style.display = "block"),
            n[o].render(n[o].node);
        }),
        (t.ext.overlay.showOverlay = function (o) {
          r(), this.refreshOverlay(o);
        }),
        (t.ext.overlay.hideOverlay = function (o) {
          (n[o].isVisible = !1), (n[o].node.style.display = "none"), s();
        }),
        (t.ext.overlay.isOverlayVisible = function (o) {
          return !!o && n[o].isVisible;
        });
    },
    export_api: function (t) {
      return (
        (t.ext = t.ext || {}),
        (t.ext.export_api = t.ext.export_api || {
          _apiUrl: "https://export.dhtmlx.com/gantt",
          _preparePDFConfigRaw(n, e) {
            let i = null;
            n.start &&
              n.end &&
              ((i = {
                start_date: t.config.start_date,
                end_date: t.config.end_date,
              }),
              (t.config.start_date = t.date.str_to_date(t.config.date_format)(
                n.start
              )),
              (t.config.end_date = t.date.str_to_date(t.config.date_format)(
                n.end
              ))),
              (n = t.mixin(n, {
                name: "gantt." + e,
                data: t.ext.export_api._serializeHtml(),
              })),
              i &&
                ((t.config.start_date = i.start_date),
                (t.config.end_date = i.end_date));
          },
          _prepareConfigPDF: (n, e) => (
            (n = t.mixin(n || {}, {
              name: "gantt." + e,
              data: t.ext.export_api._serializeAll(),
              config: t.config,
            })),
            t.ext.export_api._fixColumns(n.config.columns),
            n
          ),
          _pdfExportRouter(n, e) {
            n && n.raw
              ? t.ext.export_api._preparePDFConfigRaw(n, e)
              : (n = t.ext.export_api._prepareConfigPDF(n, e)),
              (n.version = t.version),
              t.ext.export_api._sendToExport(n, e);
          },
          exportToPDF(n) {
            t.ext.export_api._pdfExportRouter(n, "pdf");
          },
          exportToPNG(n) {
            t.ext.export_api._pdfExportRouter(n, "png");
          },
          exportToICal(n) {
            (n = t.mixin(n || {}, {
              name: "gantt.ical",
              data: t.ext.export_api._serializePlain().data,
              version: t.version,
            })),
              t.ext.export_api._sendToExport(n, "ical");
          },
          exportToExcel(n) {
            let e, i, a, r;
            n = n || {};
            const s = t.config.smart_rendering;
            if (
              (n.visual === "base-colors" && (t.config.smart_rendering = !1),
              n.start || n.end)
            ) {
              (a = t.getState()),
                (i = [t.config.start_date, t.config.end_date]),
                (r = t.getScrollState());
              const o = t.date.str_to_date(t.config.date_format);
              (e = t.eachTask),
                n.start && (t.config.start_date = o(n.start)),
                n.end && (t.config.end_date = o(n.end)),
                t.render(),
                (t.config.smart_rendering = s),
                (t.eachTask = t.ext.export_api._eachTaskTimed(
                  t.config.start_date,
                  t.config.end_date
                ));
            } else
              n.visual === "base-colors" &&
                (t.render(), (t.config.smart_rendering = s));
            (t._no_progress_colors = n.visual === "base-colors"),
              (n = t.mixin(n, {
                name: "gantt.xlsx",
                title: "Tasks",
                data: t.ext.export_api._serializeTimeline(n).data,
                columns: t.ext.export_api._serializeGrid({ rawDates: !0 }),
                version: t.version,
              })).visual && (n.scales = t.ext.export_api._serializeScales(n)),
              t.ext.export_api._sendToExport(n, "excel"),
              (n.start || n.end) &&
                ((t.config.start_date = a.min_date),
                (t.config.end_date = a.max_date),
                (t.eachTask = e),
                t.render(),
                t.scrollTo(r.x, r.y),
                (t.config.start_date = i[0]),
                (t.config.end_date = i[1]));
          },
          exportToJSON(n) {
            (n = t.mixin(n || {}, {
              name: "gantt.json",
              data: t.ext.export_api._serializeAll(),
              config: t.config,
              columns: t.ext.export_api._serializeGrid(),
              worktime: t.ext.export_api._getWorktimeSettings(),
              version: t.version,
            })),
              t.ext.export_api._sendToExport(n, "json");
          },
          importFromExcel(n) {
            try {
              const e = n.data;
              if (e instanceof File) {
                const i = new FormData();
                i.append("file", e), (n.data = i);
              }
            } catch {}
            t.ext.export_api._sendImportAjaxExcel(n);
          },
          importFromMSProject(n) {
            const e = n.data;
            try {
              if (e instanceof File) {
                const i = new FormData();
                i.append("file", e), (n.data = i);
              }
            } catch {}
            t.ext.export_api._sendImportAjaxMSP(n);
          },
          importFromPrimaveraP6: (n) => (
            (n.type = "primaveraP6-parse"), t.importFromMSProject(n)
          ),
          exportToMSProject(n) {
            (n = n || {}).skip_circular_links =
              n.skip_circular_links === void 0 || !!n.skip_circular_links;
            const e = t.templates.xml_format,
              i = t.templates.format_date,
              a = t.config.xml_date,
              r = t.config.date_format,
              s = "%d-%m-%Y %H:%i:%s";
            (t.config.xml_date = s),
              (t.config.date_format = s),
              (t.templates.xml_format = t.date.date_to_str(s)),
              (t.templates.format_date = t.date.date_to_str(s));
            const o = t.ext.export_api._serializeAll();
            t.ext.export_api._customProjectProperties(o, n),
              t.ext.export_api._customTaskProperties(o, n),
              n.skip_circular_links && t.ext.export_api._clearRecLinks(o),
              (n = t.ext.export_api._exportConfig(o, n)),
              t.ext.export_api._sendToExport(n, n.type || "msproject"),
              (t.config.xml_date = a),
              (t.config.date_format = r),
              (t.templates.xml_format = e),
              (t.templates.format_date = i),
              (t.config.$custom_data = null),
              (t.config.custom = null);
          },
          exportToPrimaveraP6: (n) => (
            ((n = n || {}).type = "primaveraP6"), t.exportToMSProject(n)
          ),
          _fixColumns(n) {
            for (let e = 0; e < n.length; e++)
              (n[e].label =
                n[e].label || t.locale.labels["column_" + n[e].name]),
                typeof n[e].width == "string" && (n[e].width = 1 * n[e].width);
          },
          _xdr(n, e, i) {
            t.ajax.post(n, e, i);
          },
          _markColumns(n) {
            const e = n.config.columns;
            if (e)
              for (let i = 0; i < e.length; i++)
                e[i].template && (e[i].$template = !0);
          },
          _sendImportAjaxExcel(n) {
            const e = n.server || t.ext.export_api._apiUrl,
              i = n.store || 0,
              a = n.data,
              r = n.callback;
            a.append("type", "excel-parse"),
              a.append("data", JSON.stringify({ sheet: n.sheet || 0 })),
              i && a.append("store", i);
            const s = new XMLHttpRequest();
            (s.onreadystatechange = function (o) {
              s.readyState === 4 && s.status === 0 && r && r(null);
            }),
              (s.onload = function () {
                let o = null;
                if (!(s.status > 400))
                  try {
                    o = JSON.parse(s.responseText);
                  } catch {}
                r && r(o);
              }),
              s.open("POST", e, !0),
              s.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
              s.send(a);
          },
          _ajaxToExport(n, e, i) {
            delete n.callback;
            const a = n.server || t.ext.export_api._apiUrl,
              r =
                "type=" +
                e +
                "&store=1&data=" +
                encodeURIComponent(JSON.stringify(n));
            t.ext.export_api._xdr(a, r, function (s) {
              const o = s.xmlDoc || s;
              let l = null;
              if (!(o.status > 400))
                try {
                  l = JSON.parse(o.responseText);
                } catch {}
              i(l);
            });
          },
          _serializableGanttConfig(n) {
            const e = t.mixin({}, n);
            return (
              e.columns &&
                (e.columns = e.columns.map(function (i) {
                  const a = t.mixin({}, i);
                  return delete a.editor, a;
                })),
              delete e.editor_types,
              e
            );
          },
          _sendToExport(n, e) {
            const i = t.date.date_to_str(
              t.config.date_format || t.config.xml_date
            );
            if (
              (n.skin || (n.skin = t.skin),
              n.config &&
                ((n.config = t.copy(
                  t.ext.export_api._serializableGanttConfig(n.config)
                )),
                t.ext.export_api._markColumns(n, e),
                n.config.start_date &&
                  n.config.end_date &&
                  (n.config.start_date instanceof Date &&
                    (n.config.start_date = i(n.config.start_date)),
                  n.config.end_date instanceof Date &&
                    (n.config.end_date = i(n.config.end_date)))),
              n.callback)
            )
              return t.ext.export_api._ajaxToExport(n, e, n.callback);
            const a = t.ext.export_api._createHiddenForm();
            (a.firstChild.action = n.server || t.ext.export_api._apiUrl),
              (a.firstChild.childNodes[0].value = JSON.stringify(n)),
              (a.firstChild.childNodes[1].value = e),
              a.firstChild.submit();
          },
          _createHiddenForm() {
            if (!t.ext.export_api._hidden_export_form) {
              const n = (t.ext.export_api._hidden_export_form =
                document.createElement("div"));
              (n.style.display = "none"),
                (n.innerHTML =
                  "<form method='POST' target='_blank'><textarea name='data' style='width:0px; height:0px;' readonly='true'></textarea><input type='hidden' name='type' value=''></form>"),
                document.body.appendChild(n);
            }
            return t.ext.export_api._hidden_export_form;
          },
          _copyObjectBase(n) {
            const e = {
              start_date: void 0,
              end_date: void 0,
              constraint_date: void 0,
              deadline: void 0,
            };
            for (const a in n)
              a.charAt(0) !== "$" && a !== "baselines" && (e[a] = n[a]);
            const i = t.templates.xml_format || t.templates.format_date;
            return (
              (e.start_date = i(e.start_date)),
              e.end_date && (e.end_date = i(e.end_date)),
              e.constraint_date && (e.constraint_date = i(e.constraint_date)),
              e.deadline && (e.deadline = i(e.deadline)),
              e
            );
          },
          _color_box: null,
          _color_hash: {},
          _getStyles(n) {
            if (
              (t.ext.export_api._color_box ||
                ((t.ext.export_api._color_box = document.createElement("DIV")),
                (t.ext.export_api._color_box.style.cssText =
                  "position:absolute; display:none;"),
                document.body.appendChild(t.ext.export_api._color_box)),
              t.ext.export_api._color_hash[n])
            )
              return t.ext.export_api._color_hash[n];
            t.ext.export_api._color_box.className = n;
            const e = t.ext.export_api._getColor(
                t.ext.export_api._color_box,
                "color"
              ),
              i = t.ext.export_api._getColor(
                t.ext.export_api._color_box,
                "backgroundColor"
              );
            return (t.ext.export_api._color_hash[n] = e + ";" + i);
          },
          _getMinutesWorktimeSettings(n) {
            const e = [];
            return (
              n.forEach(function (i) {
                e.push(i.startMinute), e.push(i.endMinute);
              }),
              e
            );
          },
          _getWorktimeSettings() {
            const n = {
              hours: [0, 24],
              minutes: null,
              dates: { 0: !0, 1: !0, 2: !0, 3: !0, 4: !0, 5: !0, 6: !0 },
            };
            let e;
            if (t.config.work_time) {
              const i = t._working_time_helper;
              if (i && i.get_calendar) e = i.get_calendar();
              else if (i) e = { hours: i.hours, minutes: null, dates: i.dates };
              else if (t.config.worktimes && t.config.worktimes.global) {
                const a = t.config.worktimes.global;
                if (a.parsed) {
                  e = {
                    hours: null,
                    minutes: t.ext.export_api._getMinutesWorktimeSettings(
                      a.parsed.hours
                    ),
                    dates: {},
                  };
                  for (const r in a.parsed.dates)
                    Array.isArray(a.parsed.dates[r])
                      ? (e.dates[r] =
                          t.ext.export_api._getMinutesWorktimeSettings(
                            a.parsed.dates[r]
                          ))
                      : (e.dates[r] = a.parsed.dates[r]);
                } else e = { hours: a.hours, minutes: null, dates: a.dates };
              } else e = n;
            } else e = n;
            return e;
          },
          _eachTaskTimed: (n, e) =>
            function (i, a, r) {
              (a = a || t.config.root_id), (r = r || t);
              const s = t.getChildren(a);
              if (s)
                for (let o = 0; o < s.length; o++) {
                  const l = t._pull[s[o]];
                  (!n || l.end_date > n) &&
                    (!e || l.start_date < e) &&
                    i.call(r, l),
                    t.hasChild(l.id) && t.eachTask(i, l.id, r);
                }
            },
          _originalCopyObject: t.json._copyObject,
          _copyObjectPlain(n) {
            const e = t.templates.task_text(n.start_date, n.end_date, n),
              i = t.ext.export_api._copyObjectBase(n);
            return (i.text = e || i.text), i;
          },
          _getColor(n, e) {
            const i = n.currentStyle
                ? n.currentStyle[e]
                : getComputedStyle(n, null)[e],
              a = i.replace(/\s/g, "").match(/^rgba?\((\d+),(\d+),(\d+)/i);
            return (
              a && a.length === 4
                ? ("0" + parseInt(a[1], 10).toString(16)).slice(-2) +
                  ("0" + parseInt(a[2], 10).toString(16)).slice(-2) +
                  ("0" + parseInt(a[3], 10).toString(16)).slice(-2)
                : i
            ).replace("#", "");
          },
          _copyObjectTable(n) {
            const e = t.date.date_to_str("%Y-%m-%dT%H:%i:%s.000Z"),
              i = t.ext.export_api._copyObjectColumns(
                n,
                t.ext.export_api._copyObjectPlain(n)
              );
            i.start_date && (i.start_date = e(n.start_date)),
              i.end_date && (i.end_date = e(n.end_date));
            const a = t._day_index_by_date
              ? t._day_index_by_date
              : t.columnIndexByDate;
            (i.$start = a.call(t, n.start_date)),
              (i.$end = a.call(t, n.end_date));
            let r = 0;
            const s = t.getScale().width;
            if (s.indexOf(0) > -1) {
              let l = 0;
              for (; l < i.$start; l++) s[l] || r++;
              for (i.$start -= r; l < i.$end; l++) s[l] || r++;
              i.$end -= r;
            }
            (i.$level = n.$level), (i.$type = n.$rendered_type);
            const o = t.templates;
            return (
              (i.$text = o.task_text(n.start, n.end_date, n)),
              (i.$left = o.leftside_text
                ? o.leftside_text(n.start, n.end_date, n)
                : ""),
              (i.$right = o.rightside_text
                ? o.rightside_text(n.start, n.end_date, n)
                : ""),
              i
            );
          },
          _copyObjectColors(n) {
            const e = t.ext.export_api._copyObjectTable(n),
              i = t.getTaskNode(n.id);
            if (i && i.firstChild) {
              let a = t.ext.export_api._getColor(
                t._no_progress_colors ? i : i.firstChild,
                "backgroundColor"
              );
              a === "363636" &&
                (a = t.ext.export_api._getColor(i, "backgroundColor")),
                (e.$color = a);
            } else n.color && (e.$color = n.color);
            return e;
          },
          _copyObjectColumns(n, e) {
            for (let i = 0; i < t.config.columns.length; i++) {
              const a = t.config.columns[i].template;
              if (a) {
                let r = a(n);
                r instanceof Date && (r = t.templates.date_grid(r, n)),
                  (e["_" + i] = r);
              }
            }
            return e;
          },
          _copyObjectAll(n) {
            const e = t.ext.export_api._copyObjectBase(n),
              i = [
                "leftside_text",
                "rightside_text",
                "task_text",
                "progress_text",
                "task_class",
              ];
            for (let a = 0; a < i.length; a++) {
              const r = t.templates[i[a]];
              r && (e["$" + a] = r(n.start_date, n.end_date, n));
            }
            return (
              t.ext.export_api._copyObjectColumns(n, e), (e.open = n.$open), e
            );
          },
          _serializeHtml() {
            const n = t.config.smart_scales,
              e = t.config.smart_rendering;
            (n || e) &&
              ((t.config.smart_rendering = !1),
              (t.config.smart_scales = !1),
              t.render());
            const i = t.$container.parentNode.innerHTML;
            return (
              (n || e) &&
                ((t.config.smart_scales = n),
                (t.config.smart_rendering = e),
                t.render()),
              i
            );
          },
          _serializeAll() {
            t.json._copyObject = t.ext.export_api._copyObjectAll;
            const n = t.ext.export_api._exportSerialize();
            return (
              (t.json._copyObject = t.ext.export_api._originalCopyObject), n
            );
          },
          _serializePlain() {
            const n = t.templates.xml_format,
              e = t.templates.format_date;
            (t.templates.xml_format = t.date.date_to_str("%Y%m%dT%H%i%s", !0)),
              (t.templates.format_date = t.date.date_to_str(
                "%Y%m%dT%H%i%s",
                !0
              )),
              (t.json._copyObject = t.ext.export_api._copyObjectPlain);
            const i = t.ext.export_api._exportSerialize();
            return (
              (t.templates.xml_format = n),
              (t.templates.format_date = e),
              (t.json._copyObject = t.ext.export_api._originalCopyObject),
              delete i.links,
              i
            );
          },
          _getRaw() {
            if (t._scale_helpers) {
              const n = t._get_scales(),
                e = t.config.min_column_width,
                i = t._get_resize_options().x
                  ? Math.max(t.config.autosize_min_width, 0)
                  : t.config.$task.offsetWidth,
                a = t.config.config.scale_height - 1;
              return t._scale_helpers.prepareConfigs(n, e, i, a);
            }
            {
              const n = t.$ui.getView("timeline");
              if (n) {
                let e = n.$config.width;
                (t.config.autosize !== "x" && t.config.autosize !== "xy") ||
                  (e = Math.max(t.config.autosize_min_width, 0));
                const i = t.getState(),
                  a = n._getScales(),
                  r = t.config.min_column_width,
                  s = t.config.scale_height - 1,
                  o = t.config.rtl;
                return n.$scaleHelper.prepareConfigs(
                  a,
                  r,
                  e,
                  s,
                  i.min_date,
                  i.max_date,
                  o
                );
              }
            }
          },
          _serializeTimeline(n) {
            t.json._copyObject = n.visual
              ? t.ext.export_api._copyObjectColors
              : t.ext.export_api._copyObjectTable;
            const e = t.ext.export_api._exportSerialize();
            if (
              ((t.json._copyObject = t.ext.export_api._originalCopyObject),
              delete e.links,
              n.cellColors)
            ) {
              const i =
                t.templates.timeline_cell_class || t.templates.task_cell_class;
              if (i) {
                const a = t.ext.export_api._getRaw();
                let r = a[0].trace_x;
                for (let s = 1; s < a.length; s++)
                  a[s].trace_x.length > r.length && (r = a[s].trace_x);
                for (let s = 0; s < e.data.length; s++) {
                  e.data[s].styles = [];
                  const o = t.getTask(e.data[s].id);
                  for (let l = 0; l < r.length; l++) {
                    const d = i(o, r[l]);
                    d &&
                      e.data[s].styles.push({
                        index: l,
                        styles: t.ext.export_api._getStyles(d),
                      });
                  }
                }
              }
            }
            return e;
          },
          _serializeScales(n) {
            const e = [],
              i = t.ext.export_api._getRaw();
            let a = 1 / 0,
              r = 0;
            for (let s = 0; s < i.length; s++) a = Math.min(a, i[s].col_width);
            for (let s = 0; s < i.length; s++) {
              let o = 0,
                l = 0;
              const d = [];
              e.push(d);
              const c = i[s];
              r = Math.max(r, c.trace_x.length);
              const u =
                c.format ||
                c.template ||
                (c.date ? t.date.date_to_str(c.date) : t.config.date_scale);
              for (let h = 0; h < c.trace_x.length; h++) {
                const _ = c.trace_x[h];
                l = o + Math.round(c.width[h] / a);
                const f = { text: u(_), start: o, end: l, styles: "" };
                if (n.cellColors) {
                  const y = c.css || t.templates.scaleCell_class;
                  if (y) {
                    const v = y(_);
                    v && (f.styles = t.ext.export_api._getStyles(v));
                  }
                }
                d.push(f), (o = l);
              }
            }
            return { width: r, height: e.length, data: e };
          },
          _serializeGrid(n) {
            t.exportMode = !0;
            const e = [],
              i = t.config.columns;
            let a = 0;
            for (let r = 0; r < i.length; r++)
              i[r].name !== "add" &&
                i[r].name !== "buttons" &&
                ((e[a] = {
                  id: i[r].template ? "_" + r : i[r].name,
                  header: i[r].label || t.locale.labels["column_" + i[r].name],
                  width: i[r].width ? Math.floor(i[r].width / 4) : "",
                  tree: i[r].tree || !1,
                }),
                i[r].name === "duration" && (e[a].type = "number"),
                (i[r].name !== "start_date" && i[r].name !== "end_date") ||
                  ((e[a].type = "date"),
                  n && n.rawDates && (e[a].id = i[r].name)),
                a++);
            return (t.exportMode = !1), e;
          },
          _exportSerialize() {
            t.exportMode = !0;
            const n = t.templates.xml_format,
              e = t.templates.format_date;
            t.templates.xml_format = t.templates.format_date =
              t.date.date_to_str(t.config.date_format || t.config.xml_date);
            const i = t.serialize();
            return (
              (t.templates.xml_format = n),
              (t.templates.format_date = e),
              (t.exportMode = !1),
              i
            );
          },
          _setLevel(n) {
            for (let e = 0; e < n.length; e++) {
              n[e].parent == 0 && (n[e]._lvl = 1);
              for (let i = e + 1; i < n.length; i++)
                n[e].id == n[i].parent && (n[i]._lvl = n[e]._lvl + 1);
            }
          },
          _clearLevel(n) {
            for (let e = 0; e < n.length; e++) delete n[e]._lvl;
          },
          _clearRecLinks(n) {
            t.ext.export_api._setLevel(n.data);
            const e = {};
            for (let r = 0; r < n.data.length; r++) e[n.data[r].id] = n.data[r];
            const i = {};
            for (let r = 0; r < n.links.length; r++) {
              const s = n.links[r];
              t.isTaskExists(s.source) &&
                t.isTaskExists(s.target) &&
                e[s.source] &&
                e[s.target] &&
                (i[s.id] = s);
            }
            for (const r in i) t.ext.export_api._makeLinksSameLevel(i[r], e);
            const a = {};
            for (const r in e)
              t.ext.export_api._clearCircDependencies(e[r], i, e, {}, a, null);
            Object.keys(i) && t.ext.export_api._clearLinksSameLevel(i, e);
            for (let r = 0; r < n.links.length; r++)
              i[n.links[r].id] || (n.links.splice(r, 1), r--);
            t.ext.export_api._clearLevel(n.data);
          },
          _clearCircDependencies(n, e, i, a, r, s) {
            const o = n.$_source;
            if (!o) return;
            a[n.id] && t.ext.export_api._onCircDependencyFind(s, e, a, r),
              (a[n.id] = !0);
            const l = {};
            for (let d = 0; d < o.length; d++) {
              if (r[o[d]]) continue;
              const c = e[o[d]],
                u = i[c._target];
              l[u.id] && t.ext.export_api._onCircDependencyFind(c, e, a, r),
                (l[u.id] = !0),
                t.ext.export_api._clearCircDependencies(u, e, i, a, r, c);
            }
            a[n.id] = !1;
          },
          _onCircDependencyFind(n, e, i, a) {
            n &&
              (t.callEvent("onExportCircularDependency", [n.id, n]) &&
                delete e[n.id],
              delete i[n._source],
              delete i[n._target],
              (a[n.id] = !0));
          },
          _makeLinksSameLevel(n, e) {
            let i, a;
            const r = { target: e[n.target], source: e[n.source] };
            if (r.target._lvl != r.source._lvl) {
              r.target._lvl < r.source._lvl
                ? ((i = "source"), (a = r.target._lvl))
                : ((i = "target"), (a = r.source._lvl));
              do {
                const l = e[r[i].parent];
                if (!l) break;
                r[i] = l;
              } while (r[i]._lvl < a);
              let s = e[r.source.parent],
                o = e[r.target.parent];
              for (; s && o && s.id != o.id; )
                (r.source = s),
                  (r.target = o),
                  (s = e[r.source.parent]),
                  (o = e[r.target.parent]);
            }
            (n._target = r.target.id),
              (n._source = r.source.id),
              r.target.$_target || (r.target.$_target = []),
              r.target.$_target.push(n.id),
              r.source.$_source || (r.source.$_source = []),
              r.source.$_source.push(n.id);
          },
          _clearLinksSameLevel(n, e) {
            for (const i in n) delete n[i]._target, delete n[i]._source;
            for (const i in e) delete e[i].$_source, delete e[i].$_target;
          },
          _customProjectProperties(n, e) {
            if (e && e.project) {
              for (const i in e.project)
                t.config.$custom_data || (t.config.$custom_data = {}),
                  (t.config.$custom_data[i] =
                    typeof e.project[i] == "function"
                      ? e.project[i](t.config)
                      : e.project[i]);
              delete e.project;
            }
          },
          _customTaskProperties(n, e) {
            e &&
              e.tasks &&
              (n.data.forEach(function (i) {
                for (const a in e.tasks)
                  i.$custom_data || (i.$custom_data = {}),
                    (i.$custom_data[a] =
                      typeof e.tasks[a] == "function"
                        ? e.tasks[a](i, t.config)
                        : e.tasks[a]);
              }),
              delete e.tasks);
          },
          _exportConfig(n, e) {
            const i = e.name || "gantt.xml";
            delete e.name, (t.config.custom = e);
            const a = t.ext.export_api._getWorktimeSettings(),
              r = t.getSubtaskDates();
            if (r.start_date && r.end_date) {
              const l = t.templates.format_date || t.templates.xml_format;
              t.config.start_end = {
                start_date: l(r.start_date),
                end_date: l(r.end_date),
              };
            }
            const s = e.auto_scheduling !== void 0 && !!e.auto_scheduling,
              o = {
                callback: e.callback || null,
                config: t.config,
                data: n,
                manual: s,
                name: i,
                worktime: a,
              };
            for (const l in e) o[l] = e[l];
            return o;
          },
          _sendImportAjaxMSP(n) {
            const e = n.server || t.ext.export_api._apiUrl,
              i = n.store || 0,
              a = n.data,
              r = n.callback,
              s = {
                durationUnit: n.durationUnit || void 0,
                projectProperties: n.projectProperties || void 0,
                taskProperties: n.taskProperties || void 0,
              };
            a.append("type", n.type || "msproject-parse"),
              a.append("data", JSON.stringify(s)),
              i && a.append("store", i);
            const o = new XMLHttpRequest();
            (o.onreadystatechange = function (l) {
              o.readyState === 4 && o.status === 0 && r && r(null);
            }),
              (o.onload = function () {
                let l = null;
                if (!(o.status > 400))
                  try {
                    l = JSON.parse(o.responseText);
                  } catch {}
                r && r(l);
              }),
              o.open("POST", e, !0),
              o.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
              o.send(a);
          },
        }),
        (t.exportToPDF = t.ext.export_api.exportToPDF),
        (t.exportToPNG = t.ext.export_api.exportToPNG),
        (t.exportToICal = t.ext.export_api.exportToICal),
        (t.exportToExcel = t.ext.export_api.exportToExcel),
        (t.exportToJSON = t.ext.export_api.exportToJSON),
        (t.importFromExcel = t.ext.export_api.importFromExcel),
        (t.importFromMSProject = t.ext.export_api.importFromMSProject),
        (t.exportToMSProject = t.ext.export_api.exportToMSProject),
        (t.importFromPrimaveraP6 = t.ext.export_api.importFromPrimaveraP6),
        (t.exportToPrimaveraP6 = t.ext.export_api.exportToPrimaveraP6),
        t.ext.export_api
      );
    },
  };
  class bn {
    constructor(n) {
      (this.addExtension = (e, i) => {
        this._extensions[e] = i;
      }),
        (this.getExtension = (e) => this._extensions[e]),
        (this._extensions = {});
      for (const e in n) this._extensions[e] = n[e];
    }
  }
  const $i = {
    KEY_CODES: {
      UP: 38,
      DOWN: 40,
      LEFT: 37,
      RIGHT: 39,
      SPACE: 32,
      ENTER: 13,
      DELETE: 46,
      ESC: 27,
      TAB: 9,
    },
  };
  var vt = typeof window < "u";
  const kt = {
    isIE:
      vt &&
      (navigator.userAgent.indexOf("MSIE") >= 0 ||
        navigator.userAgent.indexOf("Trident") >= 0),
    isOpera:
      vt &&
      (navigator.userAgent.indexOf("Opera") >= 0 ||
        navigator.userAgent.indexOf("OPR") >= 0),
    isChrome: vt && navigator.userAgent.indexOf("Chrome") >= 0,
    isSafari:
      vt &&
      (navigator.userAgent.indexOf("Safari") >= 0 ||
        navigator.userAgent.indexOf("Konqueror") >= 0),
    isFF: vt && navigator.userAgent.indexOf("Firefox") >= 0,
    isIPad: vt && navigator.userAgent.search(/iPad/gi) >= 0,
    isEdge: vt && navigator.userAgent.indexOf("Edge") != -1,
    isNode: !vt || typeof navigator > "u" || !1,
    isSalesforce: vt && (!!J.Sfdc || !!J.$A || J.Aura),
  };
  function $n(t) {
    if (typeof t == "string" || typeof t == "number") return t;
    let n = "";
    for (const e in t) {
      let i = "";
      t.hasOwnProperty(e) &&
        ((i =
          typeof t[e] == "string"
            ? encodeURIComponent(t[e])
            : typeof t[e] == "number"
            ? String(t[e])
            : encodeURIComponent(JSON.stringify(t[e]))),
        (i = e + "=" + i),
        n.length && (i = "&" + i),
        (n += i));
    }
    return n;
  }
  function Rt(t, n) {
    var e = { method: t };
    if (n.length === 0) throw new Error("Arguments list of query is wrong.");
    if (n.length === 1)
      return (
        typeof n[0] == "string"
          ? ((e.url = n[0]), (e.async = !0))
          : ((e.url = n[0].url),
            (e.async = n[0].async || !0),
            (e.callback = n[0].callback),
            (e.headers = n[0].headers)),
        n[0].data
          ? typeof n[0].data != "string"
            ? (e.data = $n(n[0].data))
            : (e.data = n[0].data)
          : (e.data = ""),
        e
      );
    switch (((e.url = n[0]), t)) {
      case "GET":
      case "DELETE":
        (e.callback = n[1]), (e.headers = n[2]);
        break;
      case "POST":
      case "PUT":
        n[1]
          ? typeof n[1] != "string"
            ? (e.data = $n(n[1]))
            : (e.data = n[1])
          : (e.data = ""),
          (e.callback = n[2]),
          (e.headers = n[3]);
    }
    return e;
  }
  const xn = {
      date_to_str: (t, n, e) => {
        t = t.replace(/%[a-zA-Z]/g, (a) => {
          switch (a) {
            case "%d":
              return `"+to_fixed(date.get${n ? "UTC" : ""}Date())+"`;
            case "%m":
              return `"+to_fixed((date.get${n ? "UTC" : ""}Month()+1))+"`;
            case "%j":
              return `"+date.get${n ? "UTC" : ""}Date()+"`;
            case "%n":
              return `"+(date.get${n ? "UTC" : ""}Month()+1)+"`;
            case "%y":
              return `"+to_fixed(date.get${n ? "UTC" : ""}FullYear()%100)+"`;
            case "%Y":
              return `"+date.get${n ? "UTC" : ""}FullYear()+"`;
            case "%D":
              return `"+locale.date.day_short[date.get${
                n ? "UTC" : ""
              }Day()]+"`;
            case "%l":
              return `"+locale.date.day_full[date.get${n ? "UTC" : ""}Day()]+"`;
            case "%M":
              return `"+locale.date.month_short[date.get${
                n ? "UTC" : ""
              }Month()]+"`;
            case "%F":
              return `"+locale.date.month_full[date.get${
                n ? "UTC" : ""
              }Month()]+"`;
            case "%h":
              return `"+to_fixed((date.get${n ? "UTC" : ""}Hours()+11)%12+1)+"`;
            case "%g":
              return `"+((date.get${n ? "UTC" : ""}Hours()+11)%12+1)+"`;
            case "%G":
              return `"+date.get${n ? "UTC" : ""}Hours()+"`;
            case "%H":
              return `"+to_fixed(date.get${n ? "UTC" : ""}Hours())+"`;
            case "%i":
              return `"+to_fixed(date.get${n ? "UTC" : ""}Minutes())+"`;
            case "%a":
              return `"+(date.get${n ? "UTC" : ""}Hours()>11?"pm":"am")+"`;
            case "%A":
              return `"+(date.get${n ? "UTC" : ""}Hours()>11?"PM":"AM")+"`;
            case "%s":
              return `"+to_fixed(date.get${n ? "UTC" : ""}Seconds())+"`;
            case "%W":
              return '"+to_fixed(getISOWeek(date))+"';
            case "%w":
              return '"+to_fixed(getWeek(date))+"';
            default:
              return a;
          }
        });
        const i = new Function(
          "date",
          "to_fixed",
          "locale",
          "getISOWeek",
          "getWeek",
          `return "${t}";`
        );
        return (a) =>
          i(a, e.date.to_fixed, e.locale, e.date.getISOWeek, e.date.getWeek);
      },
      str_to_date: (t, n, e) => {
        let i = "var temp=date.match(/[a-zA-Z]+|[0-9]+/g);";
        const a = t.match(/%[a-zA-Z]/g);
        for (let o = 0; o < a.length; o++)
          switch (a[o]) {
            case "%j":
            case "%d":
              i += `set[2]=temp[${o}]||1;`;
              break;
            case "%n":
            case "%m":
              i += `set[1]=(temp[${o}]||1)-1;`;
              break;
            case "%y":
              i += `set[0]=temp[${o}]*1+(temp[${o}]>50?1900:2000);`;
              break;
            case "%g":
            case "%G":
            case "%h":
            case "%H":
              i += `set[3]=temp[${o}]||0;`;
              break;
            case "%i":
              i += `set[4]=temp[${o}]||0;`;
              break;
            case "%Y":
              i += `set[0]=temp[${o}]||0;`;
              break;
            case "%a":
            case "%A":
              i += `set[3]=set[3]%12+((temp[${o}]||'').toLowerCase()=='am'?0:12);`;
              break;
            case "%s":
              i += `set[5]=temp[${o}]||0;`;
              break;
            case "%M":
              i += `set[1]=locale.date.month_short_hash[temp[${o}]]||0;`;
              break;
            case "%F":
              i += `set[1]=locale.date.month_full_hash[temp[${o}]]||0;`;
          }
        let r = "set[0],set[1],set[2],set[3],set[4],set[5]";
        n && (r = ` Date.UTC(${r})`);
        const s = new Function(
          "date",
          "locale",
          `var set=[0,0,1,0,0,0]; ${i} return new Date(${r});`
        );
        return (o) => s(o, e.locale);
      },
    },
    wn = {
      date_to_str: (t, n, e) => (i) =>
        t.replace(/%[a-zA-Z]/g, (a) => {
          switch (a) {
            case "%d":
              return n
                ? e.date.to_fixed(i.getUTCDate())
                : e.date.to_fixed(i.getDate());
            case "%m":
              return n
                ? e.date.to_fixed(i.getUTCMonth() + 1)
                : e.date.to_fixed(i.getMonth() + 1);
            case "%j":
              return n ? i.getUTCDate() : i.getDate();
            case "%n":
              return n ? i.getUTCMonth() + 1 : i.getMonth() + 1;
            case "%y":
              return n
                ? e.date.to_fixed(i.getUTCFullYear() % 100)
                : e.date.to_fixed(i.getFullYear() % 100);
            case "%Y":
              return n ? i.getUTCFullYear() : i.getFullYear();
            case "%D":
              return n
                ? e.locale.date.day_short[i.getUTCDay()]
                : e.locale.date.day_short[i.getDay()];
            case "%l":
              return n
                ? e.locale.date.day_full[i.getUTCDay()]
                : e.locale.date.day_full[i.getDay()];
            case "%M":
              return n
                ? e.locale.date.month_short[i.getUTCMonth()]
                : e.locale.date.month_short[i.getMonth()];
            case "%F":
              return n
                ? e.locale.date.month_full[i.getUTCMonth()]
                : e.locale.date.month_full[i.getMonth()];
            case "%h":
              return n
                ? e.date.to_fixed(((i.getUTCHours() + 11) % 12) + 1)
                : e.date.to_fixed(((i.getHours() + 11) % 12) + 1);
            case "%g":
              return n
                ? ((i.getUTCHours() + 11) % 12) + 1
                : ((i.getHours() + 11) % 12) + 1;
            case "%G":
              return n ? i.getUTCHours() : i.getHours();
            case "%H":
              return n
                ? e.date.to_fixed(i.getUTCHours())
                : e.date.to_fixed(i.getHours());
            case "%i":
              return n
                ? e.date.to_fixed(i.getUTCMinutes())
                : e.date.to_fixed(i.getMinutes());
            case "%a":
              return n
                ? i.getUTCHours() > 11
                  ? "pm"
                  : "am"
                : i.getHours() > 11
                ? "pm"
                : "am";
            case "%A":
              return n
                ? i.getUTCHours() > 11
                  ? "PM"
                  : "AM"
                : i.getHours() > 11
                ? "PM"
                : "AM";
            case "%s":
              return n
                ? e.date.to_fixed(i.getUTCSeconds())
                : e.date.to_fixed(i.getSeconds());
            case "%W":
              return n
                ? e.date.to_fixed(e.date.getUTCISOWeek(i))
                : e.date.to_fixed(e.date.getISOWeek(i));
            default:
              return a;
          }
        }),
      str_to_date: (t, n, e) => (i) => {
        const a = [0, 0, 1, 0, 0, 0],
          r = i.match(/[a-zA-Z]+|[0-9]+/g),
          s = t.match(/%[a-zA-Z]/g);
        for (let o = 0; o < s.length; o++)
          switch (s[o]) {
            case "%j":
            case "%d":
              a[2] = r[o] || 1;
              break;
            case "%n":
            case "%m":
              a[1] = (r[o] || 1) - 1;
              break;
            case "%y":
              a[0] = 1 * r[o] + (r[o] > 50 ? 1900 : 2e3);
              break;
            case "%g":
            case "%G":
            case "%h":
            case "%H":
              a[3] = r[o] || 0;
              break;
            case "%i":
              a[4] = r[o] || 0;
              break;
            case "%Y":
              a[0] = r[o] || 0;
              break;
            case "%a":
            case "%A":
              a[3] =
                (a[3] % 12) + ((r[o] || "").toLowerCase() === "am" ? 0 : 12);
              break;
            case "%s":
              a[5] = r[o] || 0;
              break;
            case "%M":
              a[1] = e.locale.date.month_short_hash[r[o]] || 0;
              break;
            case "%F":
              a[1] = e.locale.date.month_full_hash[r[o]] || 0;
          }
        return n
          ? new Date(Date.UTC(a[0], a[1], a[2], a[3], a[4], a[5]))
          : new Date(a[0], a[1], a[2], a[3], a[4], a[5]);
      },
    };
  function xi(t) {
    var n = null;
    function e() {
      var a = !1;
      return (
        t.config.csp === "auto"
          ? (n === null &&
              (function () {
                try {
                  new Function("canUseCsp = false;");
                } catch {
                  n = !0;
                }
              })(),
            (a = n))
          : (a = t.config.csp),
        a
      );
    }
    var i = {
      init: function () {
        for (
          var a = t.locale,
            r = a.date.month_short,
            s = (a.date.month_short_hash = {}),
            o = 0;
          o < r.length;
          o++
        )
          s[r[o]] = o;
        for (
          r = a.date.month_full, s = a.date.month_full_hash = {}, o = 0;
          o < r.length;
          o++
        )
          s[r[o]] = o;
      },
      date_part: function (a) {
        var r = new Date(a);
        return (
          a.setHours(0),
          this.hour_start(a),
          a.getHours() &&
            (a.getDate() < r.getDate() ||
              a.getMonth() < r.getMonth() ||
              a.getFullYear() < r.getFullYear()) &&
            a.setTime(a.getTime() + 36e5 * (24 - a.getHours())),
          a
        );
      },
      time_part: function (a) {
        return (a.valueOf() / 1e3 - 60 * a.getTimezoneOffset()) % 86400;
      },
      week_start: function (a) {
        var r = a.getDay();
        return (
          t.config.start_on_monday && (r === 0 ? (r = 6) : r--),
          this.date_part(this.add(a, -1 * r, "day"))
        );
      },
      month_start: function (a) {
        return a.setDate(1), this.date_part(a);
      },
      quarter_start: function (a) {
        this.month_start(a);
        var r,
          s = a.getMonth();
        return (r = s >= 9 ? 9 : s >= 6 ? 6 : s >= 3 ? 3 : 0), a.setMonth(r), a;
      },
      year_start: function (a) {
        return a.setMonth(0), this.month_start(a);
      },
      day_start: function (a) {
        return this.date_part(a);
      },
      hour_start: function (a) {
        return a.getMinutes() && a.setMinutes(0), this.minute_start(a), a;
      },
      minute_start: function (a) {
        return (
          a.getSeconds() && a.setSeconds(0),
          a.getMilliseconds() && a.setMilliseconds(0),
          a
        );
      },
      _add_days: function (a, r, s) {
        a.setDate(a.getDate() + r);
        var o = r >= 0,
          l = !s.getHours() && a.getHours(),
          d =
            a.getDate() <= s.getDate() ||
            a.getMonth() < s.getMonth() ||
            a.getFullYear() < s.getFullYear();
        return (
          o && l && d && a.setTime(a.getTime() + 36e5 * (24 - a.getHours())),
          r > 1 && l && a.setHours(0),
          a
        );
      },
      add: function (a, r, s) {
        var o = new Date(a.valueOf());
        switch (s) {
          case "day":
            o = this._add_days(o, r, a);
            break;
          case "week":
            o = this._add_days(o, 7 * r, a);
            break;
          case "month":
            o.setMonth(o.getMonth() + r);
            break;
          case "year":
            o.setYear(o.getFullYear() + r);
            break;
          case "hour":
            o.setTime(o.getTime() + 60 * r * 60 * 1e3);
            break;
          case "minute":
            o.setTime(o.getTime() + 60 * r * 1e3);
            break;
          default:
            return this["add_" + s](a, r, s);
        }
        return o;
      },
      add_quarter: function (a, r) {
        return this.add(a, 3 * r, "month");
      },
      to_fixed: function (a) {
        return a < 10 ? "0" + a : a;
      },
      copy: function (a) {
        return new Date(a.valueOf());
      },
      date_to_str: function (a, r) {
        var s = xn;
        return e() && (s = wn), s.date_to_str(a, r, t);
      },
      str_to_date: function (a, r) {
        var s = xn;
        return e() && (s = wn), s.str_to_date(a, r, t);
      },
      getISOWeek: function (a) {
        return t.date._getWeekNumber(a, !0);
      },
      _getWeekNumber: function (a, r) {
        if (!a) return !1;
        var s = a.getDay();
        r && s === 0 && (s = 7);
        var o = new Date(a.valueOf());
        o.setDate(a.getDate() + (4 - s));
        var l = o.getFullYear(),
          d = Math.round((o.getTime() - new Date(l, 0, 1).getTime()) / 864e5);
        return 1 + Math.floor(d / 7);
      },
      getWeek: function (a) {
        return t.date._getWeekNumber(a, t.config.start_on_monday);
      },
      getUTCISOWeek: function (a) {
        return t.date.getISOWeek(a);
      },
      convert_to_utc: function (a) {
        return new Date(
          a.getUTCFullYear(),
          a.getUTCMonth(),
          a.getUTCDate(),
          a.getUTCHours(),
          a.getUTCMinutes(),
          a.getUTCSeconds()
        );
      },
      parseDate: function (a, r) {
        return (
          a &&
            !a.getFullYear &&
            (typeof r != "function" &&
              (r =
                typeof r == "string"
                  ? r === "parse_date" || r === "xml_date"
                    ? t.defined(t.templates.xml_date)
                      ? t.templates.xml_date
                      : t.templates.parse_date
                    : t.defined(t.templates[r])
                    ? t.templates[r]
                    : t.date.str_to_date(r)
                  : t.defined(t.templates.xml_date)
                  ? t.templates.xml_date
                  : t.templates.parse_date),
            (a = a ? r(a) : null)),
          a
        );
      },
    };
    return i;
  }
  class wi {
    constructor(n) {
      const { url: e, token: i } = n;
      (this._url = e),
        (this._token = i),
        (this._mode = 1),
        (this._seed = 1),
        (this._queue = []),
        (this.data = {}),
        (this.api = {}),
        (this._events = {});
    }
    headers() {
      return {
        Accept: "application/json",
        "Content-Type": "application/json",
        "Remote-Token": this._token,
      };
    }
    fetch(n, e) {
      const i = { credentials: "include", headers: this.headers() };
      return (
        e && ((i.method = "POST"), (i.body = e)),
        fetch(n, i).then((a) => a.json())
      );
    }
    load(n) {
      return (
        n && (this._url = n), this.fetch(this._url).then((e) => this.parse(e))
      );
    }
    parse(n) {
      const { key: e, websocket: i } = n;
      e && (this._token = n.key);
      for (const a in n.data) this.data[a] = n.data[a];
      for (const a in n.api) {
        const r = (this.api[a] = {}),
          s = n.api[a];
        for (const o in s) r[o] = this._wrapper(a + "." + o);
      }
      return i && this.connect(), this;
    }
    connect() {
      const n = this._socket;
      n && ((this._socket = null), (n.onclose = function () {}), n.close()),
        (this._mode = 2),
        (this._socket = (function (e, i, a, r) {
          let s = i;
          s[0] === "/" &&
            (s =
              document.location.protocol + "//" + document.location.host + i),
            (s = s.replace(/^http(s|):/, "ws$1:"));
          const o = s.indexOf("?") != -1 ? "&" : "?";
          s = `${s}${o}token=${a}&ws=1`;
          const l = new WebSocket(s);
          return (
            (l.onclose = () => setTimeout(() => e.connect(), 2e3)),
            (l.onmessage = (d) => {
              const c = JSON.parse(d.data);
              switch (c.action) {
                case "result":
                  e.result(c.body, []);
                  break;
                case "event":
                  e.fire(c.body.name, c.body.value);
                  break;
                case "start":
                  r();
                  break;
                default:
                  e.onError(c.data);
              }
            }),
            l
          );
        })(
          this,
          this._url,
          this._token,
          () => ((this._mode = 3), this._send(), this._resubscribe(), this)
        ));
    }
    _wrapper(n) {
      return function () {
        const e = [].slice.call(arguments);
        let i = null;
        const a = new Promise((r, s) => {
          (i = {
            data: { id: this._uid(), name: n, args: e },
            status: 1,
            resolve: r,
            reject: s,
          }),
            this._queue.push(i);
        });
        return (
          this.onCall(i, a),
          this._mode === 3 ? this._send(i) : setTimeout(() => this._send(), 1),
          a
        );
      }.bind(this);
    }
    _uid() {
      return (this._seed++).toString();
    }
    _send(n) {
      if (this._mode == 2) return void setTimeout(() => this._send(), 100);
      const e = n ? [n] : this._queue.filter((a) => a.status === 1);
      if (!e.length) return;
      const i = e.map((a) => ((a.status = 2), a.data));
      this._mode !== 3
        ? this.fetch(this._url, JSON.stringify(i))
            .catch((a) => this.onError(a))
            .then((a) => this.result(a, i))
        : this._socket.send(JSON.stringify({ action: "call", body: i }));
    }
    result(n, e) {
      const i = {};
      if (n) for (let a = 0; a < n.length; a++) i[n[a].id] = n[a];
      else
        for (let a = 0; a < e.length; a++)
          i[e[a].id] = { id: e[a].id, error: "Network Error", data: null };
      for (let a = this._queue.length - 1; a >= 0; a--) {
        const r = this._queue[a],
          s = i[r.data.id];
        s &&
          (this.onResponse(r, s),
          s.error ? r.reject(s.error) : r.resolve(s.data),
          this._queue.splice(a, 1));
      }
    }
    on(n, e) {
      const i = this._uid();
      let a = this._events[n];
      const r = !!a;
      return (
        r || (a = this._events[n] = []),
        a.push({ id: i, handler: e }),
        r ||
          this._mode != 3 ||
          this._socket.send(JSON.stringify({ action: "subscribe", name: n })),
        { name: n, id: i }
      );
    }
    _resubscribe() {
      if (this._mode == 3)
        for (const n in this._events)
          this._socket.send(JSON.stringify({ action: "subscribe", name: n }));
    }
    detach(n) {
      if (!n) {
        if (this._mode == 3)
          for (const r in this._events)
            this._socket.send(
              JSON.stringify({ action: "unsubscribe", key: r })
            );
        return void (this._events = {});
      }
      const { id: e, name: i } = n,
        a = this._events[i];
      if (a) {
        const r = a.filter((s) => s.id != e);
        r.length
          ? (this._events[i] = r)
          : (delete this._events[i],
            this._mode == 3 &&
              this._socket.send(
                JSON.stringify({ action: "unsubscribe", name: i })
              ));
      }
    }
    fire(n, e) {
      const i = this._events[n];
      if (i) for (let a = 0; a < i.length; a++) i[a].handler(e);
    }
    onError(n) {
      return null;
    }
    onCall(n, e) {}
    onResponse(n, e) {}
  }
  const Si = function (t, n) {
    const e = new wi({ url: t, token: n });
    (e.fetch = function (i, a) {
      const r = { headers: this.headers() };
      return (
        a && ((r.method = "POST"), (r.body = a)),
        fetch(i, r).then((s) => s.json())
      );
    }),
      (this._ready = e.load().then((i) => (this._remote = i))),
      (this.ready = function () {
        return this._ready;
      }),
      (this.on = function (i, a) {
        this.ready().then((r) => {
          if (typeof i == "string") r.on(i, a);
          else for (const s in i) r.on(s, i[s]);
        });
      });
  };
  function Sn(t, n) {
    if (!n) return !0;
    if (t._on_timeout) return !1;
    var e = Math.ceil(1e3 / n);
    return (
      e < 2 ||
        (setTimeout(function () {
          delete t._on_timeout;
        }, e),
        (t._on_timeout = !0)),
      !0
    );
  }
  var Ti = function () {
    var t = {};
    return {
      getState: function (n) {
        if (t[n]) return t[n].method();
        var e = {};
        for (var i in t) t[i].internal || O(e, t[i].method(), !0);
        return e;
      },
      registerProvider: function (n, e, i) {
        t[n] = { method: e, internal: i };
      },
      unregisterProvider: function (n) {
        delete t[n];
      },
    };
  };
  const Ei = Promise;
  var rt = {
    $create: function (t) {
      return O(t || [], this);
    },
    $removeAt: function (t, n) {
      t >= 0 && this.splice(t, n || 1);
    },
    $remove: function (t) {
      this.$removeAt(this.$find(t));
    },
    $insertAt: function (t, n) {
      if (n || n === 0) {
        var e = this.splice(n, this.length - n);
        (this[n] = t), this.push.apply(this, e);
      } else this.push(t);
    },
    $find: function (t) {
      for (var n = 0; n < this.length; n++) if (t == this[n]) return n;
      return -1;
    },
    $each: function (t, n) {
      for (var e = 0; e < this.length; e++) t.call(n || this, this[e]);
    },
    $map: function (t, n) {
      for (var e = 0; e < this.length; e++)
        this[e] = t.call(n || this, this[e]);
      return this;
    },
    $filter: function (t, n) {
      for (var e = 0; e < this.length; e++)
        t.call(n || this, this[e]) || (this.splice(e, 1), e--);
      return this;
    },
  };
  function jt(t, n, e, i) {
    return (i = n ? n.config : i) && i.placeholder_task && e.exists(t)
      ? e.getItem(t).type === i.types.placeholder
      : !1;
  }
  var ht = function (t) {
    return (
      (this.pull = {}),
      (this.$initItem = t.initItem),
      (this.visibleOrder = rt.$create()),
      (this.fullOrder = rt.$create()),
      (this._skip_refresh = !1),
      (this._filterRule = null),
      (this._searchVisibleOrder = {}),
      (this._indexRangeCache = {}),
      (this._getItemsCache = null),
      (this.$config = t),
      ct(this),
      this._attachDataChange(function () {
        return (this._indexRangeCache = {}), (this._getItemsCache = null), !0;
      }),
      this
    );
  };
  ht.prototype = {
    _attachDataChange: function (t) {
      this.attachEvent("onClearAll", t),
        this.attachEvent("onBeforeParse", t),
        this.attachEvent("onBeforeUpdate", t),
        this.attachEvent("onBeforeDelete", t),
        this.attachEvent("onBeforeAdd", t),
        this.attachEvent("onParse", t),
        this.attachEvent("onBeforeFilter", t);
    },
    _parseInner: function (t) {
      for (var n = null, e = [], i = 0, a = t.length; i < a; i++)
        (n = t[i]),
          this.$initItem &&
            (this.$config.copyOnParse() && (n = X(n)), (n = this.$initItem(n))),
          this.callEvent("onItemLoading", [n]) &&
            (this.pull.hasOwnProperty(n.id) || this.fullOrder.push(n.id),
            e.push(n),
            (this.pull[n.id] = n));
      return e;
    },
    parse: function (t) {
      this.isSilent() || this.callEvent("onBeforeParse", [t]);
      var n = this._parseInner(t);
      this.isSilent() || (this.refresh(), this.callEvent("onParse", [n]));
    },
    getItem: function (t) {
      return this.pull[t];
    },
    _updateOrder: function (t) {
      t.call(this.visibleOrder), t.call(this.fullOrder);
    },
    updateItem: function (t, n) {
      if (
        (U(n) || (n = this.getItem(t)),
        !this.isSilent() && this.callEvent("onBeforeUpdate", [n.id, n]) === !1)
      )
        return !1;
      O(this.pull[t], n, !0),
        this.isSilent() ||
          (this.callEvent("onAfterUpdate", [n.id, n]),
          this.callEvent("onStoreUpdated", [n.id, n, "update"]));
    },
    _removeItemInner: function (t) {
      this._updateOrder(function () {
        this.$remove(t);
      }),
        delete this.pull[t];
    },
    removeItem: function (t) {
      var n = this.getItem(t);
      if (
        !this.isSilent() &&
        this.callEvent("onBeforeDelete", [n.id, n]) === !1
      )
        return !1;
      this.callEvent("onAfterDeleteConfirmed", [n.id, n]),
        this._removeItemInner(t),
        this.isSilent() && this.callEvent("onAfterSilentDelete", [n.id, n]),
        this.isSilent() ||
          (this.filter(),
          this.callEvent("onAfterDelete", [n.id, n]),
          this.callEvent("onStoreUpdated", [n.id, n, "delete"]));
    },
    _addItemInner: function (t, n) {
      if (this.exists(t.id))
        this.silent(function () {
          this.updateItem(t.id, t);
        });
      else {
        var e = this.visibleOrder,
          i = e.length;
        (!U(n) || n < 0) && (n = i), n > i && (n = Math.min(e.length, n));
      }
      (this.pull[t.id] = t),
        this._updateOrder(function () {
          this.$find(t.id) === -1 && this.$insertAt(t.id, n);
        }),
        this.filter();
    },
    isVisible: function (t) {
      return this.visibleOrder.$find(t) > -1;
    },
    getVisibleItems: function () {
      return this.getIndexRange();
    },
    addItem: function (t, n) {
      return (
        U(t.id) || (t.id = ut()),
        this.$initItem && (t = this.$initItem(t)),
        !(
          !this.isSilent() && this.callEvent("onBeforeAdd", [t.id, t]) === !1
        ) &&
          (this._addItemInner(t, n),
          this.isSilent() ||
            (this.callEvent("onAfterAdd", [t.id, t]),
            this.callEvent("onStoreUpdated", [t.id, t, "add"])),
          t.id)
      );
    },
    _changeIdInner: function (t, n) {
      this.pull[t] && (this.pull[n] = this.pull[t]);
      var e = this._searchVisibleOrder[t];
      (this.pull[n].id = n),
        this._updateOrder(function () {
          this[this.$find(t)] = n;
        }),
        (this._searchVisibleOrder[n] = e),
        delete this._searchVisibleOrder[t],
        delete this.pull[t];
    },
    changeId: function (t, n) {
      this._changeIdInner(t, n), this.callEvent("onIdChange", [t, n]);
    },
    exists: function (t) {
      return !!this.pull[t];
    },
    _moveInner: function (t, n) {
      var e = this.getIdByIndex(t);
      this._updateOrder(function () {
        this.$removeAt(t), this.$insertAt(e, Math.min(this.length, n));
      });
    },
    move: function (t, n) {
      var e = this.getIdByIndex(t),
        i = this.getItem(e);
      this._moveInner(t, n),
        this.isSilent() || this.callEvent("onStoreUpdated", [i.id, i, "move"]);
    },
    clearAll: function () {
      this.$destroyed ||
        (this.silent(function () {
          this.unselect();
        }),
        (this.pull = {}),
        (this.visibleOrder = rt.$create()),
        (this.fullOrder = rt.$create()),
        this.isSilent() || (this.callEvent("onClearAll", []), this.refresh()));
    },
    silent: function (t, n) {
      var e = !1;
      this.isSilent() && (e = !0),
        (this._skip_refresh = !0),
        t.call(n || this),
        e || (this._skip_refresh = !1);
    },
    isSilent: function () {
      return !!this._skip_refresh;
    },
    arraysEqual: function (t, n) {
      if (t.length !== n.length) return !1;
      for (var e = 0; e < t.length; e++) if (t[e] !== n[e]) return !1;
      return !0;
    },
    refresh: function (t, n) {
      var e, i;
      if (
        !this.$destroyed &&
        !this.isSilent() &&
        (t && (e = this.getItem(t)),
        (i = t ? [t, e, "paint"] : [null, null, null]),
        this.callEvent("onBeforeStoreUpdate", i) !== !1)
      ) {
        var a = this._quick_refresh && !this._mark_recompute;
        if (((this._mark_recompute = !1), t)) {
          if (!n && !a) {
            var r = this.visibleOrder;
            this.filter(),
              this.arraysEqual(r, this.visibleOrder) || (t = void 0);
          }
        } else a || this.filter();
        (i = t ? [t, e, "paint"] : [null, null, null]),
          this.callEvent("onStoreUpdated", i);
      }
    },
    count: function () {
      return this.fullOrder.length;
    },
    countVisible: function () {
      return this.visibleOrder.length;
    },
    sort: function (t) {},
    serialize: function () {},
    eachItem: function (t) {
      for (var n = 0; n < this.fullOrder.length; n++) {
        var e = this.getItem(this.fullOrder[n]);
        t.call(this, e);
      }
    },
    find: function (t) {
      var n = [];
      return (
        this.eachItem(function (e) {
          t(e) && n.push(e);
        }),
        n
      );
    },
    filter: function (t) {
      this.isSilent() || this.callEvent("onBeforeFilter", []),
        this.callEvent("onPreFilter", []);
      var n = rt.$create(),
        e = [];
      this.eachItem(function (a) {
        this.callEvent("onFilterItem", [a.id, a]) &&
          (jt(a.id, null, this, this._ganttConfig)
            ? e.push(a.id)
            : n.push(a.id));
      });
      for (var i = 0; i < e.length; i++) n.push(e[i]);
      for (
        this.visibleOrder = n, this._searchVisibleOrder = {}, i = 0;
        i < this.visibleOrder.length;
        i++
      )
        this._searchVisibleOrder[this.visibleOrder[i]] = i;
      this.isSilent() || this.callEvent("onFilter", []);
    },
    getIndexRange: function (t, n) {
      var e = Math.min(n || 1 / 0, this.countVisible() - 1),
        i = t || 0,
        a = i + "-" + e;
      if (this._indexRangeCache[a]) return this._indexRangeCache[a].slice();
      for (var r = [], s = i; s <= e; s++)
        r.push(this.getItem(this.visibleOrder[s]));
      return (this._indexRangeCache[a] = r.slice()), r;
    },
    getItems: function () {
      if (this._getItemsCache) return this._getItemsCache.slice();
      var t = [];
      for (var n in this.pull) t.push(this.pull[n]);
      return (this._getItemsCache = t.slice()), t;
    },
    getIdByIndex: function (t) {
      return this.visibleOrder[t];
    },
    getIndexById: function (t) {
      var n = this._searchVisibleOrder[t];
      return n === void 0 && (n = -1), n;
    },
    _getNullIfUndefined: function (t) {
      return t === void 0 ? null : t;
    },
    getFirst: function () {
      return this._getNullIfUndefined(this.visibleOrder[0]);
    },
    getLast: function () {
      return this._getNullIfUndefined(
        this.visibleOrder[this.visibleOrder.length - 1]
      );
    },
    getNext: function (t) {
      return this._getNullIfUndefined(
        this.visibleOrder[this.getIndexById(t) + 1]
      );
    },
    getPrev: function (t) {
      return this._getNullIfUndefined(
        this.visibleOrder[this.getIndexById(t) - 1]
      );
    },
    destructor: function () {
      this.callEvent("onDestroy", []),
        this.detachAllEvents(),
        (this.$destroyed = !0),
        (this.pull = null),
        (this.$initItem = null),
        (this.visibleOrder = null),
        (this.fullOrder = null),
        (this._skip_refresh = null),
        (this._filterRule = null),
        (this._searchVisibleOrder = null),
        (this._indexRangeCache = {});
    },
  };
  var Te = function (t) {
    var n;
    ht.apply(this, [t]),
      (this._branches = {}),
      (this.pull = {}),
      (this.$initItem = function (o) {
        var l = o;
        t.initItem && (l = t.initItem(l));
        var d = this.getItem(o.id);
        return (
          d &&
            !gt(d.parent, l.parent) &&
            this.move(
              l.id,
              l.$index || -1,
              l.parent || this._ganttConfig.root_id
            ),
          l
        );
      }),
      (this.$parentProperty = t.parentProperty || "parent"),
      typeof t.rootId != "function"
        ? (this.$getRootId =
            ((n = t.rootId || 0),
            function () {
              return n;
            }))
        : (this.$getRootId = t.rootId),
      (this.$openInitially = t.openInitially),
      (this.visibleOrder = rt.$create()),
      (this.fullOrder = rt.$create()),
      (this._searchVisibleOrder = {}),
      (this._indexRangeCache = {}),
      (this._eachItemMainRangeCache = null),
      (this._getItemsCache = null),
      (this._skip_refresh = !1),
      (this._ganttConfig = null),
      t.getConfig && (this._ganttConfig = t.getConfig());
    var e = {},
      i = {},
      a = {},
      r = {},
      s = !1;
    return (
      this._attachDataChange(function () {
        return (
          (this._indexRangeCache = {}),
          (this._eachItemMainRangeCache = null),
          (this._getItemsCache = null),
          !0
        );
      }),
      this.attachEvent("onPreFilter", function () {
        (this._indexRangeCache = {}),
          (this._eachItemMainRangeCache = null),
          (e = {}),
          (i = {}),
          (a = {}),
          (r = {}),
          (s = !1),
          this.eachItem(function (o) {
            var l = this.getParent(o.id);
            o.$open && a[l] !== !1 ? (a[o.id] = !0) : (a[o.id] = !1),
              this._isSplitItem(o) &&
                ((s = !0), (e[o.id] = !0), (i[o.id] = !0)),
              s && i[l] && (i[o.id] = !0),
              a[l] || a[l] === void 0 ? (r[o.id] = !0) : (r[o.id] = !1);
          });
      }),
      this.attachEvent("onFilterItem", function (o, l) {
        var d = !1;
        this._ganttConfig && (d = this._ganttConfig.open_split_tasks);
        var c = r[l.id];
        return (
          s &&
            (c && i[l.id] && !e[l.id] && (c = !!d),
            i[l.id] && !e[l.id] && (l.$split_subtask = !0)),
          (l.$expanded_branch = !!r[l.id]),
          !!c
        );
      }),
      this.attachEvent("onFilter", function () {
        (e = {}), (i = {}), (a = {}), (r = {});
      }),
      this
    );
  };
  function gt(t, n) {
    return String(t) === String(n);
  }
  function K(t) {
    return kt.isNode || !t.$root;
  }
  Te.prototype = O(
    {
      _buildTree: function (t) {
        for (
          var n = null, e = this.$getRootId(), i = 0, a = t.length;
          i < a;
          i++
        )
          (n = t[i]), this.setParent(n, ot(this.getParent(n), e) || e);
        for (i = 0, a = t.length; i < a; i++)
          (n = t[i]),
            this._add_branch(n),
            (n.$level = this.calculateItemLevel(n)),
            (n.$local_index = this.getBranchIndex(n.id)),
            U(n.$open) ||
              (n.$open = U(n.open) ? n.open : this.$openInitially());
        this._updateOrder();
      },
      _isSplitItem: function (t) {
        return t.render == "split" && this.hasChild(t.id);
      },
      parse: function (t) {
        this._skip_refresh || this.callEvent("onBeforeParse", [t]);
        var n = this._parseInner(t);
        this._buildTree(n),
          this.filter(),
          this._skip_refresh || this.callEvent("onParse", [n]);
      },
      _addItemInner: function (t, n) {
        var e = this.getParent(t);
        U(e) || ((e = this.$getRootId()), this.setParent(t, e));
        var i =
          this.getIndexById(e) +
          Math.min(Math.max(n, 0), this.visibleOrder.length);
        1 * i !== i && (i = void 0),
          ht.prototype._addItemInner.call(this, t, i),
          this.setParent(t, e),
          t.hasOwnProperty("$rendered_parent") &&
            this._move_branch(t, t.$rendered_parent),
          this._add_branch(t, n);
      },
      _changeIdInner: function (t, n) {
        var e = this.getChildren(t),
          i = this._searchVisibleOrder[t];
        ht.prototype._changeIdInner.call(this, t, n);
        var a = this.getParent(n);
        this._replace_branch_child(a, t, n),
          this._branches[t] && (this._branches[n] = this._branches[t]);
        for (var r = 0; r < e.length; r++) {
          var s = this.getItem(e[r]);
          (s[this.$parentProperty] = n), (s.$rendered_parent = n);
        }
        (this._searchVisibleOrder[n] = i), delete this._branches[t];
      },
      _traverseBranches: function (t, n) {
        U(n) || (n = this.$getRootId());
        var e = this._branches[n];
        if (e)
          for (var i = 0; i < e.length; i++) {
            var a = e[i];
            t.call(this, a), this._branches[a] && this._traverseBranches(t, a);
          }
      },
      _updateOrder: function (t) {
        (this.fullOrder = rt.$create()),
          this._traverseBranches(function (n) {
            this.fullOrder.push(n);
          }),
          t && ht.prototype._updateOrder.call(this, t);
      },
      _removeItemInner: function (t) {
        var n = [];
        this.eachItem(function (i) {
          n.push(i);
        }, t),
          n.push(this.getItem(t));
        for (var e = 0; e < n.length; e++)
          this._move_branch(n[e], this.getParent(n[e]), null),
            ht.prototype._removeItemInner.call(this, n[e].id),
            this._move_branch(n[e], this.getParent(n[e]), null);
      },
      move: function (t, n, e) {
        var i = arguments[3],
          a = (this._ganttConfig || {}).root_id || 0;
        if ((i = ot(i, a))) {
          if (i === t) return;
          (e = this.getParent(i)), (n = this.getBranchIndex(i));
        }
        if (!gt(t, e)) {
          U(e) || (e = this.$getRootId());
          var r = this.getItem(t),
            s = this.getParent(r.id),
            o = this.getChildren(e);
          if (
            (n == -1 && (n = o.length + 1),
            gt(s, e) && this.getBranchIndex(t) == n)
          )
            return;
          if (this.callEvent("onBeforeItemMove", [t, e, n]) === !1) return !1;
          for (var l = [], d = 0; d < o.length; d++)
            jt(o[d], null, this, this._ganttConfig) &&
              (l.push(o[d]), o.splice(d, 1), d--);
          this._replace_branch_child(s, t);
          var c = (o = this.getChildren(e))[n];
          (c = ot(c, a))
            ? (o = o.slice(0, n).concat([t]).concat(o.slice(n)))
            : o.push(t),
            l.length && (o = o.concat(l)),
            gt(r.$rendered_parent, s) || gt(s, e) || (r.$rendered_parent = s),
            this.setParent(r, e),
            (this._branches[e] = o);
          var u = this.calculateItemLevel(r) - r.$level;
          (r.$level += u),
            this.eachItem(
              function (h) {
                h.$level += u;
              },
              r.id,
              this
            ),
            this._moveInner(this.getIndexById(t), this.getIndexById(e) + n),
            this.callEvent("onAfterItemMove", [t, e, n]),
            this.refresh();
        }
      },
      getBranchIndex: function (t) {
        var n = this.getChildren(this.getParent(t));
        let e = n.indexOf(t + "");
        return e == -1 && (e = n.indexOf(+t)), e;
      },
      hasChild: function (t) {
        var n = this._branches[t];
        return n && n.length;
      },
      getChildren: function (t) {
        var n = this._branches[t];
        return n || rt.$create();
      },
      isChildOf: function (t, n) {
        if (!this.exists(t)) return !1;
        if (n === this.$getRootId()) return !0;
        if (!this.hasChild(n)) return !1;
        var e = this.getItem(t),
          i = this.getParent(t);
        if (this.getItem(n).$level >= e.$level) return !1;
        for (; e && this.exists(i); ) {
          if ((e = this.getItem(i)) && gt(e.id, n)) return !0;
          i = this.getParent(e);
        }
        return !1;
      },
      getSiblings: function (t) {
        if (!this.exists(t)) return rt.$create();
        var n = this.getParent(t);
        return this.getChildren(n);
      },
      getNextSibling: function (t) {
        for (var n = this.getSiblings(t), e = 0, i = n.length; e < i; e++)
          if (gt(n[e], t)) {
            var a = n[e + 1];
            return a === 0 && e > 0 && (a = "0"), a || null;
          }
        return null;
      },
      getPrevSibling: function (t) {
        for (var n = this.getSiblings(t), e = 0, i = n.length; e < i; e++)
          if (gt(n[e], t)) {
            var a = n[e - 1];
            return a === 0 && e > 0 && (a = "0"), a || null;
          }
        return null;
      },
      getParent: function (t) {
        var n = null;
        return (n = t.id !== void 0 ? t : this.getItem(t))
          ? n[this.$parentProperty]
          : this.$getRootId();
      },
      clearAll: function () {
        (this._branches = {}), ht.prototype.clearAll.call(this);
      },
      calculateItemLevel: function (t) {
        var n = 0;
        return (
          this.eachParent(function () {
            n++;
          }, t),
          n
        );
      },
      _setParentInner: function (t, n, e) {
        e ||
          (t.hasOwnProperty("$rendered_parent")
            ? this._move_branch(t, t.$rendered_parent, n)
            : this._move_branch(t, t[this.$parentProperty], n));
      },
      setParent: function (t, n, e) {
        this._setParentInner(t, n, e), (t[this.$parentProperty] = n);
      },
      _eachItemCached: function (t, n) {
        for (var e = 0, i = n.length; e < i; e++) t.call(this, n[e]);
      },
      _eachItemIterate: function (t, n, e) {
        var i = this.getChildren(n);
        for (i.length && (i = i.slice().reverse()); i.length; ) {
          var a = i.pop(),
            r = this.getItem(a);
          if ((t.call(this, r), e && e.push(r), this.hasChild(r.id)))
            for (var s = this.getChildren(r.id), o = s.length - 1; o >= 0; o--)
              i.push(s[o]);
        }
      },
      eachItem: function (t, n) {
        var e = this.$getRootId();
        U(n) || (n = e);
        var i = ot(n, e) || e,
          a = !1,
          r = !1,
          s = null;
        i === e &&
          (this._eachItemMainRangeCache
            ? ((a = !0), (s = this._eachItemMainRangeCache))
            : ((r = !0), (s = this._eachItemMainRangeCache = []))),
          a
            ? this._eachItemCached(t, s)
            : this._eachItemIterate(t, i, r ? s : null);
      },
      eachParent: function (t, n) {
        for (var e = {}, i = n, a = this.getParent(i); this.exists(a); ) {
          if (e[a])
            throw new Error(
              "Invalid tasks tree. Cyclic reference has been detected on task " +
                a
            );
          (e[a] = !0),
            (i = this.getItem(a)),
            t.call(this, i),
            (a = this.getParent(i));
        }
      },
      _add_branch: function (t, n, e) {
        var i = e === void 0 ? this.getParent(t) : e;
        this.hasChild(i) || (this._branches[i] = rt.$create());
        var a = this.getChildren(i);
        a.indexOf(t.id + "") > -1 ||
          a.indexOf(+t.id) > -1 ||
          (1 * n == n ? a.splice(n, 0, t.id) : a.push(t.id),
          (t.$rendered_parent = i));
      },
      _move_branch: function (t, n, e) {
        (this._eachItemMainRangeCache = null),
          this._replace_branch_child(n, t.id),
          this.exists(e) || gt(e, this.$getRootId())
            ? this._add_branch(t, void 0, e)
            : delete this._branches[t.id],
          (t.$level = this.calculateItemLevel(t)),
          this.eachItem(function (i) {
            i.$level = this.calculateItemLevel(i);
          }, t.id);
      },
      _replace_branch_child: function (t, n, e) {
        var i = this.getChildren(t);
        if (i && t !== void 0) {
          var a = rt.$create();
          let r = i.indexOf(n + "");
          r != -1 || isNaN(+n) || (r = i.indexOf(+n)),
            r > -1 && (e ? i.splice(r, 1, e) : i.splice(r, 1)),
            (a = i),
            (this._branches[t] = a);
        }
      },
      sort: function (t, n, e) {
        this.exists(e) || (e = this.$getRootId()), t || (t = "order");
        var i =
          typeof t == "string"
            ? function (l, d) {
                return l[t] == d[t] ||
                  (nt(l[t]) && nt(d[t]) && l[t].valueOf() == d[t].valueOf())
                  ? 0
                  : l[t] > d[t]
                  ? 1
                  : -1;
              }
            : t;
        if (n) {
          var a = i;
          i = function (l, d) {
            return a(d, l);
          };
        }
        var r = this.getChildren(e);
        if (r) {
          for (var s = [], o = r.length - 1; o >= 0; o--)
            s[o] = this.getItem(r[o]);
          for (s.sort(i), o = 0; o < s.length; o++)
            (r[o] = s[o].id), this.sort(t, n, r[o]);
        }
      },
      filter: function (t) {
        for (let n in this.pull) {
          const e = this.pull[n].$rendered_parent,
            i = this.getParent(this.pull[n]);
          gt(e, i) || this._move_branch(this.pull[n], e, i);
        }
        return ht.prototype.filter.apply(this, arguments);
      },
      open: function (t) {
        this.exists(t) &&
          ((this.getItem(t).$open = !0),
          (this._skipTaskRecalculation = !0),
          this.callEvent("onItemOpen", [t]));
      },
      close: function (t) {
        this.exists(t) &&
          ((this.getItem(t).$open = !1),
          (this._skipTaskRecalculation = !0),
          this.callEvent("onItemClose", [t]));
      },
      destructor: function () {
        ht.prototype.destructor.call(this),
          (this._branches = null),
          (this._indexRangeCache = {}),
          (this._eachItemMainRangeCache = null);
      },
    },
    ht.prototype
  );
  const Ci = function (t, n) {
    const e = n.getDatastore(t),
      i = function (o, l) {
        const d = l.getLayers(),
          c = e.getItem(o);
        if (c && e.isVisible(o))
          for (let u = 0; u < d.length; u++) d[u].render_item(c);
      },
      a = function (o) {
        const l = o.getLayers();
        for (let _ = 0; _ < l.length; _++) l[_].clear();
        let d = null;
        const c = {};
        for (let _ = 0; _ < l.length; _++) {
          const f = l[_];
          let y;
          if (f.get_visible_range) {
            var u = f.get_visible_range(e);
            if (u.start !== void 0 && u.end !== void 0) {
              var h = u.start + " - " + u.end;
              c[h]
                ? (y = c[h])
                : ((y = e.getIndexRange(u.start, u.end)), (c[h] = y));
            } else {
              if (u.ids === void 0)
                throw new Error(
                  "Invalid range returned from 'getVisibleRange' of the layer"
                );
              y = u.ids.map(function (v) {
                return e.getItem(v);
              });
            }
          } else d || (d = e.getVisibleItems()), (y = d);
          f.prepare_data && f.prepare_data(y), l[_].render_items(y);
        }
      },
      r = function (o) {
        if (o.update_items) {
          let d = [];
          if (o.get_visible_range) {
            var l = o.get_visible_range(e);
            if (
              (l.start !== void 0 &&
                l.end !== void 0 &&
                (d = e.getIndexRange(l.start, l.end)),
              l.ids !== void 0)
            ) {
              let c = l.ids.map(function (u) {
                return e.getItem(u);
              });
              c.length > 0 &&
                ((c = c.filter((u) => u !== void 0)), (d = d.concat(c)));
            }
            if ((l.start == null || l.end == null) && l.ids == null)
              throw new Error(
                "Invalid range returned from 'getVisibleRange' of the layer"
              );
          } else d = e.getVisibleItems();
          o.prepare_data && o.prepare_data(d, o), o.update_items(d);
        }
      };
    function s(o) {
      return !!o.$services.getService("state").getState("batchUpdate")
        .batch_update;
    }
    e.attachEvent("onStoreUpdated", function (o, l, d) {
      if (K(n)) return !0;
      const c = n.$services.getService("layers").getDataRender(t);
      c &&
        (c.onUpdateRequest = function (u) {
          r(u);
        });
    }),
      e.attachEvent("onStoreUpdated", function (o, l, d) {
        s(n) ||
          (o && d != "move" && d != "delete"
            ? (e.callEvent("onBeforeRefreshItem", [l.id]),
              e.callEvent("onAfterRefreshItem", [l.id]))
            : (e.callEvent("onBeforeRefreshAll", []),
              e.callEvent("onAfterRefreshAll", [])));
      }),
      e.attachEvent("onAfterRefreshAll", function () {
        if (K(n)) return !0;
        const o = n.$services.getService("layers").getDataRender(t);
        o && !s(n) && a(o);
      }),
      e.attachEvent("onAfterRefreshItem", function (o) {
        if (K(n)) return !0;
        const l = n.$services.getService("layers").getDataRender(t);
        l && i(o, l);
      }),
      e.attachEvent("onItemOpen", function () {
        if (K(n) || e.isSilent()) return !0;
        n.render();
      }),
      e.attachEvent("onItemClose", function () {
        if (K(n) || e.isSilent()) return !0;
        n.render();
      }),
      e.attachEvent("onIdChange", function (o, l) {
        if (K(n)) return !0;
        if ((e.callEvent("onBeforeIdChange", [o, l]), !s(n) && !e.isSilent())) {
          const d = n.$services.getService("layers").getDataRender(t);
          d
            ? ((function (c, u, h) {
                for (let _ = 0; _ < c.length; _++) c[_].change_id(u, h);
              })(d.getLayers(), o, l, e.getItem(l)),
              i(l, d))
            : n.render();
        }
      });
  };
  function Ee() {
    for (
      var t = this.$services.getService("datastores"), n = [], e = 0;
      e < t.length;
      e++
    ) {
      var i = this.getDatastore(t[e]);
      i.$destroyed || n.push(i);
    }
    return n;
  }
  const Di = {
    create: function () {
      var t = O(
        {},
        {
          createDatastore: function (n) {
            var e = (n.type || "").toLowerCase() == "treedatastore" ? Te : ht;
            if (n) {
              var i = this;
              (n.openInitially = function () {
                return i.config.open_tree_initially;
              }),
                (n.copyOnParse = function () {
                  return i.config.deepcopy_on_parse;
                });
            }
            var a = new e(n);
            if (
              (this.mixin(
                a,
                (function (o) {
                  var l = null,
                    d = o._removeItemInner;
                  function c(u) {
                    (l = null), this.callEvent("onAfterUnselect", [u]);
                  }
                  return (
                    (o._removeItemInner = function (u) {
                      return (
                        l == u && c.call(this, u),
                        l &&
                          this.eachItem &&
                          this.eachItem(function (h) {
                            h.id == l && c.call(this, h.id);
                          }, u),
                        d.apply(this, arguments)
                      );
                    }),
                    o.attachEvent("onIdChange", function (u, h) {
                      o.getSelectedId() == u &&
                        o.silent(function () {
                          o.unselect(u), o.select(h);
                        });
                    }),
                    {
                      select: function (u) {
                        if (u) {
                          if (l == u) return l;
                          if (
                            !this._skip_refresh &&
                            !this.callEvent("onBeforeSelect", [u])
                          )
                            return !1;
                          this.unselect(),
                            (l = u),
                            this._skip_refresh ||
                              (this.refresh(u),
                              this.callEvent("onAfterSelect", [u]));
                        }
                        return l;
                      },
                      getSelectedId: function () {
                        return l;
                      },
                      isSelected: function (u) {
                        return u == l;
                      },
                      unselect: function (u) {
                        (u = u || l) &&
                          ((l = null),
                          this._skip_refresh ||
                            (this.refresh(u), c.call(this, u)));
                      },
                    }
                  );
                })(a)
              ),
              n.name)
            ) {
              var r = "datastore:" + n.name;
              a.attachEvent(
                "onDestroy",
                function () {
                  this.$services.dropService(r);
                  for (
                    var o = this.$services.getService("datastores"), l = 0;
                    l < o.length;
                    l++
                  )
                    if (o[l] === n.name) {
                      o.splice(l, 1);
                      break;
                    }
                }.bind(this)
              ),
                this.$services.dropService(r),
                this.$services.setService(r, function () {
                  return a;
                });
              var s = this.$services.getService("datastores");
              s
                ? s.indexOf(n.name) < 0 && s.push(n.name)
                : ((s = []),
                  this.$services.setService("datastores", function () {
                    return s;
                  }),
                  s.push(n.name)),
                Ci(n.name, this);
            }
            return a;
          },
          getDatastore: function (n) {
            return this.$services.getService("datastore:" + n);
          },
          _getDatastores: Ee,
          refreshData: function () {
            var n;
            K(this) || (n = this.getScrollState()),
              this.callEvent("onBeforeDataRender", []);
            for (var e = Ee.call(this), i = 0; i < e.length; i++)
              e[i].refresh();
            this.config.preserve_scroll &&
              !K(this) &&
              (n.x || n.y) &&
              this.scrollTo(n.x, n.y),
              this.callEvent("onDataRender", []);
          },
          isChildOf: function (n, e) {
            return this.$data.tasksStore.isChildOf(n, e);
          },
          refreshTask: function (n, e) {
            var i = this.getTask(n),
              a = this;
            function r() {
              if (e === void 0 || e) {
                for (var o = 0; o < i.$source.length; o++)
                  a.refreshLink(i.$source[o]);
                for (o = 0; o < i.$target.length; o++)
                  a.refreshLink(i.$target[o]);
              }
            }
            if (i && this.isTaskVisible(n))
              this.$data.tasksStore.refresh(
                n,
                !!this.getState("tasksDnd").drag_id || e === !1
              ),
                r();
            else if (
              this.isTaskExists(n) &&
              this.isTaskExists(this.getParent(n)) &&
              !this._bulk_dnd
            ) {
              this.refreshTask(this.getParent(n));
              var s = !1;
              this.eachParent(function (o) {
                (s || this.isSplitTask(o)) && (s = !0);
              }, n),
                s && r();
            }
          },
          refreshLink: function (n) {
            this.$data.linksStore.refresh(
              n,
              !!this.getState("tasksDnd").drag_id
            );
          },
          silent: function (n) {
            var e = this;
            e.$data.tasksStore.silent(function () {
              e.$data.linksStore.silent(function () {
                n();
              });
            });
          },
          clearAll: function () {
            for (var n = Ee.call(this), e = 0; e < n.length; e++)
              n[e].silent(function () {
                n[e].clearAll();
              });
            for (e = 0; e < n.length; e++) n[e].clearAll();
            this._update_flags(),
              (this.userdata = {}),
              this.callEvent("onClear", []),
              this.render();
          },
          _clear_data: function () {
            this.$data.tasksStore.clearAll(),
              this.$data.linksStore.clearAll(),
              this._update_flags(),
              (this.userdata = {});
          },
          selectTask: function (n) {
            var e = this.$data.tasksStore;
            if (!this.config.select_task) return !1;
            if ((n = ot(n, this.config.root_id))) {
              let i = this.getSelectedId();
              (e._skipResourceRepaint = !0),
                e.select(n),
                (e._skipResourceRepaint = !1),
                i && e.pull[i].$split_subtask && i != n && this.refreshTask(i),
                e.pull[n].$split_subtask && i != n && this.refreshTask(n);
            }
            return e.getSelectedId();
          },
          unselectTask: function (n) {
            var e = this.$data.tasksStore;
            e.unselect(n), n && e.pull[n].$split_subtask && this.refreshTask(n);
          },
          isSelectedTask: function (n) {
            return this.$data.tasksStore.isSelected(n);
          },
          getSelectedId: function () {
            return this.$data.tasksStore.getSelectedId();
          },
        }
      );
      return (
        O(t, {
          getTask: function (n) {
            (n = ot(n, this.config.root_id)),
              this.assert(n, "Invalid argument for gantt.getTask");
            var e = this.$data.tasksStore.getItem(n);
            return this.assert(e, "Task not found id=" + n), e;
          },
          getTaskByTime: function (n, e) {
            var i = this.$data.tasksStore.getItems(),
              a = [];
            if (n || e) {
              (n = +n || -1 / 0), (e = +e || 1 / 0);
              for (var r = 0; r < i.length; r++) {
                var s = i[r];
                +s.start_date < e && +s.end_date > n && a.push(s);
              }
            } else a = i;
            return a;
          },
          isTaskExists: function (n) {
            return (
              !(!this.$data || !this.$data.tasksStore) &&
              this.$data.tasksStore.exists(n)
            );
          },
          updateTask: function (n, e) {
            U(e) || (e = this.getTask(n)),
              this.$data.tasksStore.updateItem(n, e),
              this.isTaskExists(n) && this.refreshTask(n);
          },
          addTask: function (n, e, i) {
            if (
              (U(n.id) || (n.id = ut()),
              this.isTaskExists(n.id) && this.getTask(n.id).$index != n.$index)
            )
              return (
                n.start_date &&
                  typeof n.start_date == "string" &&
                  (n.start_date = this.date.parseDate(
                    n.start_date,
                    "parse_date"
                  )),
                n.end_date &&
                  typeof n.end_date == "string" &&
                  (n.end_date = this.date.parseDate(n.end_date, "parse_date")),
                this.$data.tasksStore.updateItem(n.id, n)
              );
            if (
              (U(e) || (e = this.getParent(n) || 0),
              this.isTaskExists(e) || (e = this.config.root_id),
              this.setParent(n, e),
              this.getState().lightbox && this.isTaskExists(e))
            ) {
              var a = this.getTask(e);
              this.callEvent("onAfterParentExpand", [e, a]);
            }
            return this.$data.tasksStore.addItem(n, i, e);
          },
          deleteTask: function (n) {
            return (
              (n = ot(n, this.config.root_id)),
              this.$data.tasksStore.removeItem(n)
            );
          },
          getTaskCount: function () {
            return this.$data.tasksStore.count();
          },
          getVisibleTaskCount: function () {
            return this.$data.tasksStore.countVisible();
          },
          getTaskIndex: function (n) {
            return this.$data.tasksStore.getBranchIndex(n);
          },
          getGlobalTaskIndex: function (n) {
            return (
              (n = ot(n, this.config.root_id)),
              this.assert(n, "Invalid argument"),
              this.$data.tasksStore.getIndexById(n)
            );
          },
          eachTask: function (n, e, i) {
            return this.$data.tasksStore.eachItem(z(n, i || this), e);
          },
          eachParent: function (n, e, i) {
            return this.$data.tasksStore.eachParent(z(n, i || this), e);
          },
          changeTaskId: function (n, e) {
            this.$data.tasksStore.changeId(n, e);
            var i = this.$data.tasksStore.getItem(e),
              a = [];
            i.$source && (a = a.concat(i.$source)),
              i.$target && (a = a.concat(i.$target));
            for (var r = 0; r < a.length; r++) {
              var s = this.getLink(a[r]);
              s.source == n && (s.source = e), s.target == n && (s.target = e);
            }
          },
          calculateTaskLevel: function (n) {
            return this.$data.tasksStore.calculateItemLevel(n);
          },
          getNext: function (n) {
            return this.$data.tasksStore.getNext(n);
          },
          getPrev: function (n) {
            return this.$data.tasksStore.getPrev(n);
          },
          getParent: function (n) {
            return this.$data.tasksStore.getParent(n);
          },
          setParent: function (n, e, i) {
            return this.$data.tasksStore.setParent(n, e, i);
          },
          getSiblings: function (n) {
            return this.$data.tasksStore.getSiblings(n).slice();
          },
          getNextSibling: function (n) {
            return this.$data.tasksStore.getNextSibling(n);
          },
          getPrevSibling: function (n) {
            return this.$data.tasksStore.getPrevSibling(n);
          },
          getTaskByIndex: function (n) {
            var e = this.$data.tasksStore.getIdByIndex(n);
            return this.isTaskExists(e) ? this.getTask(e) : null;
          },
          getChildren: function (n) {
            return this.hasChild(n)
              ? this.$data.tasksStore.getChildren(n).slice()
              : [];
          },
          hasChild: function (n) {
            return this.$data.tasksStore.hasChild(n);
          },
          open: function (n) {
            this.$data.tasksStore.open(n);
          },
          close: function (n) {
            this.$data.tasksStore.close(n);
          },
          moveTask: function (n, e, i) {
            return (
              (i = ot(i, this.config.root_id)),
              this.$data.tasksStore.move.apply(this.$data.tasksStore, arguments)
            );
          },
          sort: function (n, e, i, a) {
            var r = !a;
            this.$data.tasksStore.sort(n, e, i),
              this.callEvent("onAfterSort", [n, e, i]),
              r && this.render();
          },
        }),
        O(t, {
          getLinkCount: function () {
            return this.$data.linksStore.count();
          },
          getLink: function (n) {
            return this.$data.linksStore.getItem(n);
          },
          getLinks: function () {
            return this.$data.linksStore.getItems();
          },
          isLinkExists: function (n) {
            return this.$data.linksStore.exists(n);
          },
          addLink: function (n) {
            return this.$data.linksStore.addItem(n);
          },
          updateLink: function (n, e) {
            U(e) || (e = this.getLink(n)),
              this.$data.linksStore.updateItem(n, e);
          },
          deleteLink: function (n) {
            return this.$data.linksStore.removeItem(n);
          },
          changeLinkId: function (n, e) {
            return this.$data.linksStore.changeId(n, e);
          },
        }),
        t
      );
    },
  };
  function Tn(t) {
    var n = t.date,
      e = t.$services;
    return {
      getSum: function (i, a, r) {
        r === void 0 && (r = i.length - 1), a === void 0 && (a = 0);
        for (var s = 0, o = a; o <= r; o++) s += i[o];
        return s;
      },
      setSumWidth: function (i, a, r, s) {
        var o = a.width;
        s === void 0 && (s = o.length - 1), r === void 0 && (r = 0);
        var l = s - r + 1;
        if (!(r > o.length - 1 || l <= 0 || s > o.length - 1)) {
          var d = i - this.getSum(o, r, s);
          this.adjustSize(d, o, r, s),
            this.adjustSize(-d, o, s + 1),
            (a.full_width = this.getSum(o));
        }
      },
      splitSize: function (i, a) {
        for (var r = [], s = 0; s < a; s++) r[s] = 0;
        return this.adjustSize(i, r), r;
      },
      adjustSize: function (i, a, r, s) {
        r || (r = 0), s === void 0 && (s = a.length - 1);
        for (var o = s - r + 1, l = this.getSum(a, r, s), d = r; d <= s; d++) {
          var c = Math.floor(i * (l ? a[d] / l : 1 / o));
          (l -= a[d]), (i -= c), o--, (a[d] += c);
        }
        a[a.length - 1] += i;
      },
      sortScales: function (i) {
        function a(s, o) {
          var l = new Date(1970, 0, 1);
          return n.add(l, o, s) - l;
        }
        i.sort(function (s, o) {
          return a(s.unit, s.step) < a(o.unit, o.step)
            ? 1
            : a(s.unit, s.step) > a(o.unit, o.step)
            ? -1
            : 0;
        });
        for (var r = 0; r < i.length; r++) i[r].index = r;
      },
      _isLegacyMode: function (i) {
        var a = i || t.config;
        return a.scale_unit || a.date_scale || a.subscales;
      },
      _prepareScaleObject: function (i) {
        var a = i.format;
        return (
          a || (a = i.template || i.date || "%d %M"),
          typeof a == "string" && (a = t.date.date_to_str(a)),
          { unit: i.unit || "day", step: i.step || 1, format: a, css: i.css }
        );
      },
      primaryScale: function (i) {
        var a,
          r = e.getService("templateLoader"),
          s = this._isLegacyMode(i),
          o = i || t.config;
        if (s)
          r.initTemplate("date_scale", void 0, void 0, o, t.config.templates),
            (a = {
              unit: t.config.scale_unit,
              step: t.config.step,
              template: t.templates.date_scale,
              date: t.config.date_scale,
              css: t.templates.scale_cell_class,
            });
        else {
          var l = o.scales[0];
          a = {
            unit: l.unit,
            step: l.step,
            template: l.template,
            format: l.format,
            date: l.date,
            css: l.css || t.templates.scale_cell_class,
          };
        }
        return this._prepareScaleObject(a);
      },
      getSubScales: function (i) {
        var a,
          r = this._isLegacyMode(i),
          s = i || t.config;
        if (r) {
          let o =
            "https://docs.dhtmlx.com/gantt/migrating.html#:~:text=%3D%20false%3B-,Time%20scale%20settings,-Configuration%20of%20time";
          t.env.isFF &&
            (o = "https://docs.dhtmlx.com/gantt/migrating.html#6162"),
            console.warn(`You are using the obsolete scale configuration.
It will stop working in the future versions.
Please migrate the configuration to the newer version:
${o}`),
            (a = s.subscales || []);
        } else a = s.scales.slice(1);
        return a.map(
          function (o) {
            return this._prepareScaleObject(o);
          }.bind(this)
        );
      },
      prepareConfigs: function (i, a, r, s, o, l, d) {
        for (
          var c = this.splitSize(s, i.length), u = r, h = [], _ = i.length - 1;
          _ >= 0;
          _--
        ) {
          var f = _ == i.length - 1,
            y = this.initScaleConfig(i[_], o, l);
          f && this.processIgnores(y),
            this.initColSizes(y, a, u, c[_]),
            this.limitVisibleRange(y),
            f && (u = y.full_width),
            h.unshift(y);
        }
        for (_ = 0; _ < h.length - 1; _++)
          this.alineScaleColumns(h[h.length - 1], h[_]);
        for (_ = 0; _ < h.length; _++)
          d && this.reverseScale(h[_]), this.setPosSettings(h[_]);
        return h;
      },
      reverseScale: function (i) {
        (i.width = i.width.reverse()), (i.trace_x = i.trace_x.reverse());
        var a = i.trace_indexes;
        (i.trace_indexes = {}), (i.trace_index_transition = {}), (i.rtl = !0);
        for (var r = 0; r < i.trace_x.length; r++)
          (i.trace_indexes[i.trace_x[r].valueOf()] = r),
            (i.trace_index_transition[a[i.trace_x[r].valueOf()]] = r);
        return i;
      },
      setPosSettings: function (i) {
        for (var a = 0, r = i.trace_x.length; a < r; a++)
          i.left.push((i.width[a - 1] || 0) + (i.left[a - 1] || 0));
      },
      _ignore_time_config: function (i, a) {
        if (t.config.skip_off_time) {
          for (var r = !0, s = i, o = 0; o < a.step; o++)
            o && (s = n.add(i, o, a.unit)),
              (r = r && !this.isWorkTime(s, a.unit));
          return r;
        }
        return !1;
      },
      processIgnores: function (i) {
        (i.ignore_x = {}), (i.display_count = i.count);
      },
      initColSizes: function (i, a, r, s) {
        var o = r;
        i.height = s;
        var l = i.display_count === void 0 ? i.count : i.display_count;
        l || (l = 1),
          (i.col_width = Math.floor(o / l)),
          a && i.col_width < a && ((i.col_width = a), (o = i.col_width * l)),
          (i.width = []);
        for (var d = i.ignore_x || {}, c = 0; c < i.trace_x.length; c++)
          if (d[i.trace_x[c].valueOf()] || i.display_count == i.count)
            i.width[c] = 0;
          else {
            var u = 1;
            i.unit == "month" &&
              (u = Math.round(
                (n.add(i.trace_x[c], i.step, i.unit) - i.trace_x[c]) / 864e5
              )),
              (i.width[c] = u);
          }
        this.adjustSize(o - this.getSum(i.width), i.width),
          (i.full_width = this.getSum(i.width));
      },
      initScaleConfig: function (i, a, r) {
        var s = O(
          {
            count: 0,
            col_width: 0,
            full_width: 0,
            height: 0,
            width: [],
            left: [],
            trace_x: [],
            trace_indexes: {},
            min_date: new Date(a),
            max_date: new Date(r),
          },
          i
        );
        return (
          this.eachColumn(i.unit, i.step, a, r, function (o) {
            s.count++,
              s.trace_x.push(new Date(o)),
              (s.trace_indexes[o.valueOf()] = s.trace_x.length - 1);
          }),
          (s.trace_x_ascending = s.trace_x.slice()),
          s
        );
      },
      iterateScales: function (i, a, r, s, o) {
        for (
          var l = a.trace_x,
            d = i.trace_x,
            c = r || 0,
            u = s || d.length - 1,
            h = 0,
            _ = 1;
          _ < l.length;
          _++
        ) {
          var f = i.trace_indexes[+l[_]];
          f !== void 0 &&
            f <= u &&
            (o && o.apply(this, [h, _, c, f]), (c = f), (h = _));
        }
      },
      alineScaleColumns: function (i, a, r, s) {
        this.iterateScales(i, a, r, s, function (o, l, d, c) {
          var u = this.getSum(i.width, d, c - 1);
          this.getSum(a.width, o, l - 1) != u &&
            this.setSumWidth(u, a, o, l - 1);
        });
      },
      eachColumn: function (i, a, r, s, o) {
        var l = new Date(r),
          d = new Date(s);
        n[i + "_start"] && (l = n[i + "_start"](l));
        var c = new Date(l);
        for (+c >= +d && (d = n.add(c, a, i)); +c < +d; ) {
          o.call(this, new Date(c));
          var u = c.getTimezoneOffset();
          (c = n.add(c, a, i)),
            (c = t._correct_dst_change(c, u, a, i)),
            n[i + "_start"] && (c = n[i + "_start"](c));
        }
      },
      limitVisibleRange: function (i) {
        var a = i.trace_x,
          r = i.width.length - 1,
          s = 0;
        if (+a[0] < +i.min_date && r != 0) {
          var o = Math.floor(
            i.width[0] * ((a[1] - i.min_date) / (a[1] - a[0]))
          );
          (s += i.width[0] - o),
            (i.width[0] = o),
            (a[0] = new Date(i.min_date));
        }
        var l = a.length - 1,
          d = a[l],
          c = n.add(d, i.step, i.unit);
        if (
          (+c > +i.max_date &&
            l > 0 &&
            ((o =
              i.width[l] -
              Math.floor(i.width[l] * ((c - i.max_date) / (c - d)))),
            (s += i.width[l] - o),
            (i.width[l] = o)),
          s)
        ) {
          for (
            var u = this.getSum(i.width), h = 0, _ = 0;
            _ < i.width.length;
            _++
          ) {
            var f = Math.floor(s * (i.width[_] / u));
            (i.width[_] += f), (h += f);
          }
          this.adjustSize(s - h, i.width);
        }
      },
    };
  }
  function En(t) {
    var n = new Tn(t);
    return (
      (n.processIgnores = function (e) {
        var i = e.count;
        if (((e.ignore_x = {}), t.ignore_time || t.config.skip_off_time)) {
          var a =
            t.ignore_time ||
            function () {
              return !1;
            };
          i = 0;
          for (var r = 0; r < e.trace_x.length; r++)
            a.call(t, e.trace_x[r]) ||
            this._ignore_time_config.call(t, e.trace_x[r], e)
              ? ((e.ignore_x[e.trace_x[r].valueOf()] = !0),
                (e.ignored_colls = !0))
              : i++;
        }
        e.display_count = i;
      }),
      n
    );
  }
  function Ai(t) {
    var n = (function (c) {
        var u = new Tn(c).primaryScale(),
          h = u.unit,
          _ = u.step;
        if (c.config.scale_offset_minimal) {
          var f = new En(c),
            y = [f.primaryScale()].concat(f.getSubScales());
          f.sortScales(y),
            (h = y[y.length - 1].unit),
            (_ = y[y.length - 1].step || 1);
        }
        return { unit: h, step: _ };
      })(t),
      e = n.unit,
      i = n.step,
      a = (function (c, u) {
        var h = { start_date: null, end_date: null };
        if (u.config.start_date && u.config.end_date) {
          h.start_date = u.date[c + "_start"](new Date(u.config.start_date));
          var _ = new Date(u.config.end_date),
            f = u.date[c + "_start"](new Date(_));
          (_ = +_ != +f ? u.date.add(f, 1, c) : f), (h.end_date = _);
        }
        return h;
      })(e, t);
    if (!a.start_date || !a.end_date) {
      for (var r = !0, s = t.getTaskByTime(), o = 0; o < s.length; o++)
        if (s[o].type !== t.config.types.project) {
          r = !1;
          break;
        }
      if (s.length && r) {
        var l = s[0].start_date,
          d = t.date.add(l, 1, t.config.duration_unit);
        a = { start_date: new Date(l), end_date: new Date(d) };
      } else a = t.getSubtaskDates();
      (a.start_date && a.end_date) ||
        (a = { start_date: new Date(), end_date: new Date() }),
        t.eachTask(function (c) {
          t.config.deadlines && c.deadline && Ce(a, c.deadline, c.deadline),
            c.constraint_date &&
              c.constraint_type &&
              t.config.constraint_types &&
              c.constraint_type !== t.config.constraint_types.ASAP &&
              c.constraint_type !== t.config.constraint_types.ALAP &&
              Ce(a, c.constraint_date, c.constraint_date),
            t.config.baselines &&
              c.baselines &&
              c.baselines.forEach(function (u) {
                Ce(a, u.start_date, u.end_date);
              });
        }),
        (a.start_date = t.date[e + "_start"](a.start_date)),
        (a.start_date = t.calculateEndDate({
          start_date: t.date[e + "_start"](a.start_date),
          duration: -1,
          unit: e,
          step: i,
        })),
        (a.end_date = t.date[e + "_start"](a.end_date)),
        (a.end_date = t.calculateEndDate({
          start_date: a.end_date,
          duration: 2,
          unit: e,
          step: i,
        }));
    }
    (t._min_date = a.start_date), (t._max_date = a.end_date);
  }
  function Ce(t, n, e) {
    n < t.start_date && (t.start_date = new Date(n)),
      e > t.end_date && (t.end_date = new Date(e));
  }
  function De(t) {
    Ai(t),
      (function (n) {
        if (n.config.fit_tasks) {
          var e = +n._min_date,
            i = +n._max_date;
          if (+n._min_date != e || +n._max_date != i)
            return n.render(), n.callEvent("onScaleAdjusted", []), !0;
        }
      })(t);
  }
  function Cn(t, n, e) {
    for (var i = 0; i < n.length; i++)
      t.isLinkExists(n[i]) && (e[n[i]] = t.getLink(n[i]));
  }
  function Dn(t, n, e) {
    Cn(t, n.$source, e), Cn(t, n.$target, e);
  }
  const Ae = {
    getSubtreeLinks: function (t, n) {
      var e = {};
      return (
        t.isTaskExists(n) && Dn(t, t.getTask(n), e),
        t.eachTask(function (i) {
          Dn(t, i, e);
        }, n),
        e
      );
    },
    getSubtreeTasks: function (t, n) {
      var e = {};
      return (
        t.eachTask(function (i) {
          e[i.id] = i;
        }, n),
        e
      );
    },
  };
  class Mi {
    constructor(n, e) {
      (this.$gantt = n), (this.$dp = e), (this._dataProcessorHandlers = []);
    }
    attach() {
      const n = this.$dp,
        e = this.$gantt,
        i = {},
        a = (o) => this.clientSideDelete(o, n, e);
      this._dataProcessorHandlers.push(
        e.attachEvent("onAfterTaskAdd", function (o, l) {
          e.isTaskExists(o) &&
            (n.setGanttMode("tasks"), n.setUpdated(o, !0, "inserted"));
        })
      ),
        this._dataProcessorHandlers.push(
          e.attachEvent("onAfterTaskUpdate", function (o, l) {
            e.isTaskExists(o) &&
              (n.setGanttMode("tasks"),
              n.setUpdated(o, !0),
              e._sendTaskOrder && e._sendTaskOrder(o, l));
          })
        ),
        this._dataProcessorHandlers.push(
          e.attachEvent("onBeforeTaskDelete", function (o, l) {
            return (
              e.config.cascade_delete &&
                (i[o] = {
                  tasks: Ae.getSubtreeTasks(e, o),
                  links: Ae.getSubtreeLinks(e, o),
                }),
              !n.deleteAfterConfirmation ||
                (n.setGanttMode("tasks"), n.setUpdated(o, !0, "deleted"), !1)
            );
          })
        ),
        this._dataProcessorHandlers.push(
          e.attachEvent("onAfterTaskDelete", function (o, l) {
            n.setGanttMode("tasks");
            const d = !a(o),
              c = e.config.cascade_delete && i[o];
            if (d || c) {
              if (c) {
                const u = n.updateMode;
                n.setUpdateMode("off");
                const h = i[o];
                for (const _ in h.tasks)
                  a(_) ||
                    (n.storeItem(h.tasks[_]), n.setUpdated(_, !0, "deleted"));
                n.setGanttMode("links");
                for (const _ in h.links)
                  a(_) ||
                    (n.storeItem(h.links[_]), n.setUpdated(_, !0, "deleted"));
                (i[o] = null),
                  u !== "off" && n.sendAllData(),
                  n.setGanttMode("tasks"),
                  n.setUpdateMode(u);
              }
              d &&
                (n.storeItem(l),
                n.deleteAfterConfirmation || n.setUpdated(o, !0, "deleted")),
                n.updateMode === "off" || n._tSend || n.sendAllData();
            }
          })
        ),
        this._dataProcessorHandlers.push(
          e.attachEvent("onAfterLinkUpdate", function (o, l) {
            e.isLinkExists(o) && (n.setGanttMode("links"), n.setUpdated(o, !0));
          })
        ),
        this._dataProcessorHandlers.push(
          e.attachEvent("onAfterLinkAdd", function (o, l) {
            e.isLinkExists(o) &&
              (n.setGanttMode("links"), n.setUpdated(o, !0, "inserted"));
          })
        ),
        this._dataProcessorHandlers.push(
          e.attachEvent("onAfterLinkDelete", function (o, l) {
            n.setGanttMode("links"),
              !a(o) && (n.storeItem(l), n.setUpdated(o, !0, "deleted"));
          })
        ),
        this._dataProcessorHandlers.push(
          e.attachEvent("onRowDragEnd", function (o, l) {
            e._sendTaskOrder(o, e.getTask(o));
          })
        );
      let r = null,
        s = null;
      this._dataProcessorHandlers.push(
        e.attachEvent("onTaskIdChange", function (o, l) {
          if (!n._waitMode) return;
          const d = e.getChildren(l);
          if (d.length) {
            r = r || {};
            for (let u = 0; u < d.length; u++) {
              const h = this.getTask(d[u]);
              r[h.id] = h;
            }
          }
          const c = (function (u) {
            let h = [];
            return (
              u.$source && (h = h.concat(u.$source)),
              u.$target && (h = h.concat(u.$target)),
              h
            );
          })(this.getTask(l));
          if (c.length) {
            s = s || {};
            for (let u = 0; u < c.length; u++) {
              const h = this.getLink(c[u]);
              s[h.id] = h;
            }
          }
        })
      ),
        n.attachEvent("onAfterUpdateFinish", function () {
          (r || s) &&
            (e.batchUpdate(function () {
              for (const o in r) e.updateTask(r[o].id);
              for (const o in s) e.updateLink(s[o].id);
              (r = null), (s = null);
            }),
            r ? e._dp.setGanttMode("tasks") : e._dp.setGanttMode("links"));
        }),
        n.attachEvent("onBeforeDataSending", function () {
          if (this._tMode === "CUSTOM") return !0;
          let o = this._serverProcessor;
          if (this._tMode === "REST-JSON" || this._tMode === "REST") {
            const l = this._ganttMode;
            (o = o.substring(
              0,
              o.indexOf("?") > -1 ? o.indexOf("?") : o.length
            )),
              (this.serverProcessor = o + (o.slice(-1) === "/" ? "" : "/") + l);
          } else {
            const l = this._ganttMode + "s";
            this.serverProcessor =
              o + e.ajax.urlSeparator(o) + "gantt_mode=" + l;
          }
          return !0;
        }),
        n.attachEvent("insertCallback", function (o, l, d, c) {
          const u = o.data || e.xml._xmlNodeToJSON(o.firstChild),
            h = { add: e.addTask, isExist: e.isTaskExists };
          c === "links" && ((h.add = e.addLink), (h.isExist = e.isLinkExists)),
            h.isExist.call(e, l) || ((u.id = l), h.add.call(e, u));
        }),
        n.attachEvent("updateCallback", function (o, l) {
          const d = o.data || e.xml._xmlNodeToJSON(o.firstChild);
          if (!e.isTaskExists(l)) return;
          const c = e.getTask(l);
          for (const u in d) {
            let h = d[u];
            switch (u) {
              case "id":
                continue;
              case "start_date":
              case "end_date":
                h = e.defined(e.templates.xml_date)
                  ? e.templates.xml_date(h)
                  : e.templates.parse_date(h);
                break;
              case "duration":
                c.end_date = e.calculateEndDate({
                  start_date: c.start_date,
                  duration: h,
                  task: c,
                });
            }
            c[u] = h;
          }
          e.updateTask(l), e.refreshData();
        }),
        n.attachEvent("deleteCallback", function (o, l, d, c) {
          const u = { delete: e.deleteTask, isExist: e.isTaskExists };
          c === "links"
            ? ((u.delete = e.deleteLink), (u.isExist = e.isLinkExists))
            : c === "assignment" &&
              ((u.delete = function (h) {
                e.$data.assignmentsStore.remove(h);
              }),
              (u.isExist = function (h) {
                return e.$data.assignmentsStore.exists(h);
              })),
            u.isExist.call(e, l) && u.delete.call(e, l);
        }),
        this.handleResourceCRUD(n, e),
        this.handleResourceAssignmentCRUD(n, e),
        this.handleBaselineCRUD(n, e);
    }
    clientSideDelete(n, e, i) {
      const a = e.updatedRows.slice();
      let r = !1;
      i.getUserData(n, "!nativeeditor_status", e._ganttMode) ===
        "true_deleted" && ((r = !0), e.setUpdated(n, !1));
      for (let s = 0; s < a.length && !e._in_progress[n]; s++)
        a[s] === n &&
          (i.getUserData(n, "!nativeeditor_status", e._ganttMode) ===
            "inserted" && (r = !0),
          e.setUpdated(n, !1));
      return r;
    }
    handleResourceAssignmentCRUD(n, e) {
      if (
        !e.config.resources ||
        e.config.resources.dataprocessor_assignments !== !0
      )
        return;
      const i = e.getDatastore(e.config.resource_assignment_store),
        a = {},
        r = {};
      function s(o) {
        const l = o.id;
        i.exists(l) &&
          (n.setGanttMode("assignment"), n.setUpdated(l, !0, "inserted")),
          delete r[l];
      }
      e.attachEvent("onBeforeTaskAdd", function (o, l) {
        return (a[o] = !0), !0;
      }),
        e.attachEvent("onTaskIdChange", function (o, l) {
          delete a[o];
        }),
        i.attachEvent("onAfterAdd", (o, l) => {
          a[l.task_id]
            ? (function (d) {
                (r[d.id] = d), (a[d.task_id] = !0);
              })(l)
            : s(l);
        }),
        i.attachEvent("onAfterUpdate", (o, l) => {
          i.exists(o) &&
            (r[o] ? s(l) : (n.setGanttMode("assignment"), n.setUpdated(o, !0)));
        }),
        i.attachEvent("onAfterDelete", (o, l) => {
          n.setGanttMode("assignment"),
            !this.clientSideDelete(o, n, e) &&
              (n.storeItem(l), n.setUpdated(o, !0, "deleted"));
        });
    }
    handleResourceCRUD(n, e) {
      if (
        !e.config.resources ||
        e.config.resources.dataprocessor_resources !== !0
      )
        return;
      const i = e.getDatastore(e.config.resource_store);
      i.attachEvent("onAfterAdd", (a, r) => {
        (function (s) {
          const o = s.id;
          i.exists(o) &&
            (n.setGanttMode("resource"), n.setUpdated(o, !0, "inserted"));
        })(r);
      }),
        i.attachEvent("onAfterUpdate", (a, r) => {
          i.exists(a) && (n.setGanttMode("resource"), n.setUpdated(a, !0));
        }),
        i.attachEvent("onAfterDelete", (a, r) => {
          n.setGanttMode("resource"),
            !this.clientSideDelete(a, n, e) &&
              (n.storeItem(r), n.setUpdated(a, !0, "deleted"));
        });
    }
    handleBaselineCRUD(n, e) {
      if (
        !e.config.baselines ||
        e.config.baselines.dataprocessor_baselines !== !0
      )
        return;
      const i = e.getDatastore(e.config.baselines.datastore);
      i.attachEvent("onAfterAdd", (a, r) => {
        (function (s) {
          const o = s.id;
          i.exists(o) &&
            (n.setGanttMode("baseline"), n.setUpdated(o, !0, "inserted"));
        })(r);
      }),
        i.attachEvent("onAfterUpdate", (a, r) => {
          i.exists(a) && (n.setGanttMode("baseline"), n.setUpdated(a, !0));
        }),
        i.attachEvent("onAfterDelete", (a, r) => {
          n.setGanttMode("baseline"),
            !this.clientSideDelete(a, n, e) &&
              (n.storeItem(r), n.setUpdated(a, !0, "deleted"));
        });
    }
    detach() {
      st(this._dataProcessorHandlers, (n) => {
        this.$gantt.detachEvent(n);
      }),
        (this._dataProcessorHandlers = []);
    }
  }
  const de = class de {
    constructor() {
      (this.clear = () => {
        this._storage = {};
      }),
        (this.storeItem = (n) => {
          this._storage[n.id] = X(n);
        }),
        (this.getStoredItem = (n) => this._storage[n] || null),
        (this._storage = {});
    }
  };
  de.create = () => new de();
  let te = de,
    An = class {
      constructor(t) {
        (this.serverProcessor = t),
          (this.action_param = "!nativeeditor_status"),
          (this.updatedRows = []),
          (this.autoUpdate = !0),
          (this.updateMode = "cell"),
          (this._headers = null),
          (this._payload = null),
          (this._postDelim = "_"),
          (this._routerParametersFormat = "parameters"),
          (this._waitMode = 0),
          (this._in_progress = {}),
          (this._storage = te.create()),
          (this._invalid = {}),
          (this.messages = []),
          (this.styles = {
            updated: "font-weight:bold;",
            inserted: "font-weight:bold;",
            deleted: "text-decoration : line-through;",
            invalid: "background-color:FFE0E0;",
            invalid_cell: "border-bottom:2px solid red;",
            error: "color:red;",
            clear: "font-weight:normal;text-decoration:none;",
          }),
          this.enableUTFencoding(!0),
          ct(this);
      }
      setTransactionMode(t, n) {
        typeof t == "object"
          ? ((this._tMode = t.mode || this._tMode),
            U(t.headers) && (this._headers = t.headers),
            U(t.payload) && (this._payload = t.payload),
            (this._tSend = !!n))
          : ((this._tMode = t), (this._tSend = n)),
          this._tMode === "REST" && (this._tSend = !1),
          this._tMode === "JSON" || this._tMode === "REST-JSON"
            ? ((this._tSend = !1),
              (this._serializeAsJson = !0),
              (this._headers = this._headers || {}),
              (this._headers["Content-Type"] = "application/json"))
            : this._headers &&
              !this._headers["Content-Type"] &&
              (this._headers["Content-Type"] =
                "application/x-www-form-urlencoded"),
          this._tMode === "CUSTOM" &&
            ((this._tSend = !1), (this._router = t.router));
      }
      escape(t) {
        return this._utf ? encodeURIComponent(t) : escape(t);
      }
      enableUTFencoding(t) {
        this._utf = !!t;
      }
      getSyncState() {
        return !this.updatedRows.length;
      }
      setUpdateMode(t, n) {
        (this.autoUpdate = t === "cell"), (this.updateMode = t), (this.dnd = n);
      }
      ignore(t, n) {
        (this._silent_mode = !0), t.call(n || J), (this._silent_mode = !1);
      }
      setUpdated(t, n, e) {
        if (this._silent_mode) return;
        const i = this.findRow(t);
        e = e || "updated";
        const a = this.$gantt.getUserData(
          t,
          this.action_param,
          this._ganttMode
        );
        a && e === "updated" && (e = a),
          n
            ? (this.set_invalid(t, !1),
              (this.updatedRows[i] = t),
              this.$gantt.setUserData(t, this.action_param, e, this._ganttMode),
              this._in_progress[t] && (this._in_progress[t] = "wait"))
            : this.is_invalid(t) ||
              (this.updatedRows.splice(i, 1),
              this.$gantt.setUserData(
                t,
                this.action_param,
                "",
                this._ganttMode
              )),
          this.markRow(t, n, e),
          n && this.autoUpdate && this.sendData(t);
      }
      markRow(t, n, e) {
        let i = "";
        const a = this.is_invalid(t);
        if (
          (a && ((i = this.styles[a]), (n = !0)),
          this.callEvent("onRowMark", [t, n, e, a]) &&
            ((i = this.styles[n ? e : "clear"] + " " + i),
            this.$gantt[this._methods[0]](t, i),
            a && a.details))
        ) {
          i += this.styles[a + "_cell"];
          for (let r = 0; r < a.details.length; r++)
            a.details[r] && this.$gantt[this._methods[1]](t, r, i);
        }
      }
      getActionByState(t) {
        return t === "inserted"
          ? "create"
          : t === "updated"
          ? "update"
          : t === "deleted"
          ? "delete"
          : "update";
      }
      getState(t) {
        return this.$gantt.getUserData(t, this.action_param, this._ganttMode);
      }
      is_invalid(t) {
        return this._invalid[t];
      }
      set_invalid(t, n, e) {
        e &&
          (n = {
            value: n,
            details: e,
            toString: function () {
              return this.value.toString();
            },
          }),
          (this._invalid[t] = n);
      }
      checkBeforeUpdate(t) {
        return !0;
      }
      sendData(t) {
        if (
          (this.$gantt.editStop && this.$gantt.editStop(),
          t === void 0 || this._tSend)
        ) {
          const n = [];
          if (
            (this.modes &&
              ["task", "link", "assignment", "baseline"].forEach((e) => {
                this.modes[e] && this.modes[e].updatedRows.length && n.push(e);
              }),
            n.length)
          ) {
            for (let e = 0; e < n.length; e++)
              this.setGanttMode(n[e]), this.sendAllData();
            return;
          }
          return this.sendAllData();
        }
        return (
          !this._in_progress[t] &&
          ((this.messages = []),
          !(
            !this.checkBeforeUpdate(t) &&
            this.callEvent("onValidationError", [t, this.messages])
          ) && void this._beforeSendData(this._getRowData(t), t))
        );
      }
      serialize(t, n) {
        if (this._serializeAsJson) return this._serializeAsJSON(t);
        if (typeof t == "string") return t;
        if (n !== void 0) return this.serialize_one(t, "");
        {
          const e = [],
            i = [];
          for (const a in t)
            t.hasOwnProperty(a) &&
              (e.push(this.serialize_one(t[a], a + this._postDelim)),
              i.push(a));
          return (
            e.push("ids=" + this.escape(i.join(","))),
            this.$gantt.security_key &&
              e.push("dhx_security=" + this.$gantt.security_key),
            e.join("&")
          );
        }
      }
      serialize_one(t, n) {
        if (typeof t == "string") return t;
        const e = [];
        let i = "";
        for (const a in t)
          if (t.hasOwnProperty(a)) {
            if (
              (a === "id" || a == this.action_param) &&
              this._tMode === "REST"
            )
              continue;
            (i =
              typeof t[a] == "string" || typeof t[a] == "number"
                ? String(t[a])
                : JSON.stringify(t[a])),
              e.push(this.escape((n || "") + a) + "=" + this.escape(i));
          }
        return e.join("&");
      }
      sendAllData() {
        if (!this.updatedRows.length) return;
        this.messages = [];
        let t = !0;
        if (
          (this._forEachUpdatedRow(function (n) {
            t = t && this.checkBeforeUpdate(n);
          }),
          !t && !this.callEvent("onValidationError", ["", this.messages]))
        )
          return !1;
        this._tSend
          ? this._sendData(this._getAllData())
          : this._forEachUpdatedRow(function (n) {
              if (!this._in_progress[n]) {
                if (this.is_invalid(n)) return;
                this._beforeSendData(this._getRowData(n), n);
              }
            });
      }
      findRow(t) {
        let n = 0;
        for (
          n = 0;
          n < this.updatedRows.length && t != this.updatedRows[n];
          n++
        );
        return n;
      }
      defineAction(t, n) {
        this._uActions || (this._uActions = {}), (this._uActions[t] = n);
      }
      afterUpdateCallback(t, n, e, i, a) {
        if (!this.$gantt) return;
        this.setGanttMode(a);
        const r = t,
          s = e !== "error" && e !== "invalid";
        if (
          (s || this.set_invalid(t, e),
          this._uActions && this._uActions[e] && !this._uActions[e](i))
        )
          return delete this._in_progress[r];
        this._in_progress[r] !== "wait" && this.setUpdated(t, !1);
        const o = t;
        switch (e) {
          case "inserted":
          case "insert":
            n != t &&
              (this.setUpdated(t, !1),
              this.$gantt[this._methods[2]](t, n),
              (t = n));
            break;
          case "delete":
          case "deleted":
            if (this.deleteAfterConfirmation && this._ganttMode === "task") {
              if (this._ganttMode === "task" && this.$gantt.isTaskExists(t)) {
                this.$gantt.setUserData(
                  t,
                  this.action_param,
                  "true_deleted",
                  this._ganttMode
                );
                const l = this.$gantt.getTask(t);
                this.$gantt.silent(() => {
                  this.$gantt.deleteTask(t);
                }),
                  this.$gantt.callEvent("onAfterTaskDelete", [t, l]),
                  this.$gantt.render(),
                  delete this._in_progress[r];
              }
              return this.callEvent("onAfterUpdate", [t, e, n, i]);
            }
            return (
              this.$gantt.setUserData(
                t,
                this.action_param,
                "true_deleted",
                this._ganttMode
              ),
              this.$gantt[this._methods[3]](t),
              delete this._in_progress[r],
              this.callEvent("onAfterUpdate", [t, e, n, i])
            );
        }
        this._in_progress[r] !== "wait"
          ? (s &&
              this.$gantt.setUserData(
                t,
                this.action_param,
                "",
                this._ganttMode
              ),
            delete this._in_progress[r])
          : (delete this._in_progress[r],
            this.setUpdated(
              n,
              !0,
              this.$gantt.getUserData(t, this.action_param, this._ganttMode)
            )),
          this.callEvent("onAfterUpdate", [o, e, n, i]);
      }
      afterUpdate(t, n, e) {
        let i;
        i = arguments.length === 3 ? arguments[1] : arguments[4];
        let a = this.getGanttMode();
        const r = i.filePath || i.url;
        (a =
          this._tMode !== "REST" && this._tMode !== "REST-JSON"
            ? r.indexOf("gantt_mode=links") !== -1
              ? "link"
              : r.indexOf("gantt_mode=assignments") !== -1
              ? "assignment"
              : r.indexOf("gantt_mode=baselines") !== -1
              ? "baseline"
              : "task"
            : r.indexOf("/link") >= 0
            ? "link"
            : r.indexOf("/assignment") >= 0
            ? "assignment"
            : r.indexOf("/baseline") >= 0
            ? "baseline"
            : "task"),
          this.setGanttMode(a);
        const s = this.$gantt.ajax;
        let o;
        try {
          o = JSON.parse(n.xmlDoc.responseText);
        } catch {
          n.xmlDoc.responseText.length || (o = {});
        }
        const l = (u) => {
          const h = o.action || this.getState(u) || "updated",
            _ = o.sid || u[0],
            f = o.tid || u[0];
          t.afterUpdateCallback(_, f, h, o, a);
        };
        if (o)
          return (
            Array.isArray(e) && e.length > 1 ? e.forEach((u) => l(u)) : l(e),
            t.finalizeUpdate(),
            void this.setGanttMode(a)
          );
        const d = s.xmltop("data", n.xmlDoc);
        if (!d) return this.cleanUpdate(e);
        const c = s.xpath("//data/action", d);
        if (!c.length) return this.cleanUpdate(e);
        for (let u = 0; u < c.length; u++) {
          const h = c[u],
            _ = h.getAttribute("type"),
            f = h.getAttribute("sid"),
            y = h.getAttribute("tid");
          t.afterUpdateCallback(f, y, _, h, a);
        }
        t.finalizeUpdate();
      }
      cleanUpdate(t) {
        if (t)
          for (let n = 0; n < t.length; n++) delete this._in_progress[t[n]];
      }
      finalizeUpdate() {
        this._waitMode && this._waitMode--,
          this.callEvent("onAfterUpdateFinish", []),
          this.updatedRows.length || this.callEvent("onFullSync", []);
      }
      init(t) {
        if (this._initialized) return;
        (this.$gantt = t),
          this.$gantt._dp_init && this.$gantt._dp_init(this),
          this._setDefaultTransactionMode(),
          (this.styles = {
            updated: "gantt_updated",
            order: "gantt_updated",
            inserted: "gantt_inserted",
            deleted: "gantt_deleted",
            delete_confirmation: "gantt_deleted",
            invalid: "gantt_invalid",
            error: "gantt_error",
            clear: "",
          }),
          (this._methods = [
            "_row_style",
            "setCellTextStyle",
            "_change_id",
            "_delete_task",
          ]),
          (function (e, i) {
            (e.getUserData = function (a, r, s) {
              return (
                this.userdata || (this.userdata = {}),
                (this.userdata[s] = this.userdata[s] || {}),
                this.userdata[s][a] && this.userdata[s][a][r]
                  ? this.userdata[s][a][r]
                  : ""
              );
            }),
              (e.setUserData = function (a, r, s, o) {
                this.userdata || (this.userdata = {}),
                  (this.userdata[o] = this.userdata[o] || {}),
                  (this.userdata[o][a] = this.userdata[o][a] || {}),
                  (this.userdata[o][a][r] = s);
              }),
              (e._change_id = function (a, r) {
                switch (this._dp._ganttMode) {
                  case "task":
                    this.changeTaskId(a, r);
                    break;
                  case "link":
                    this.changeLinkId(a, r);
                    break;
                  case "assignment":
                    this.$data.assignmentsStore.changeId(a, r);
                    break;
                  case "resource":
                    this.$data.resourcesStore.changeId(a, r);
                    break;
                  case "baseline":
                    this.$data.baselineStore.changeId(a, r);
                    break;
                  default:
                    throw new Error(
                      `Invalid mode of the dataProcessor after database id is received: ${this._dp._ganttMode}, new id: ${r}`
                    );
                }
              }),
              (e._row_style = function (a, r) {
                this._dp._ganttMode === "task" &&
                  e.isTaskExists(a) &&
                  ((e.getTask(a).$dataprocessor_class = r), e.refreshTask(a));
              }),
              (e._delete_task = function (a, r) {}),
              (e._sendTaskOrder = function (a, r) {
                r.$drop_target &&
                  (this._dp.setGanttMode("task"),
                  (this.getTask(a).target = r.$drop_target),
                  this._dp.setUpdated(a, !0, "order"),
                  delete this.getTask(a).$drop_target);
              }),
              (e.setDp = function () {
                this._dp = i;
              }),
              e.setDp();
          })(this.$gantt, this);
        const n = new Mi(this.$gantt, this);
        n.attach(),
          this.attachEvent("onDestroy", function () {
            delete this.setGanttMode,
              delete this._getRowData,
              delete this.$gantt._dp,
              delete this.$gantt._change_id,
              delete this.$gantt._row_style,
              delete this.$gantt._delete_task,
              delete this.$gantt._sendTaskOrder,
              delete this.$gantt,
              n.detach();
          }),
          this.$gantt.callEvent("onDataProcessorReady", [this]),
          (this._initialized = !0);
      }
      setOnAfterUpdate(t) {
        this.attachEvent("onAfterUpdate", t);
      }
      setOnBeforeUpdateHandler(t) {
        this.attachEvent("onBeforeDataSending", t);
      }
      setAutoUpdate(t, n) {
        (t = t || 2e3),
          (this._user = n || new Date().valueOf()),
          (this._needUpdate = !1),
          (this._updateBusy = !1),
          this.attachEvent("onAfterUpdate", this.afterAutoUpdate),
          this.attachEvent("onFullSync", this.fullSync),
          setInterval(() => {
            this.loadUpdate();
          }, t);
      }
      afterAutoUpdate(t, n, e, i) {
        return n !== "collision" || ((this._needUpdate = !0), !1);
      }
      fullSync() {
        return (
          this._needUpdate && ((this._needUpdate = !1), this.loadUpdate()), !0
        );
      }
      getUpdates(t, n) {
        const e = this.$gantt.ajax;
        if (this._updateBusy) return !1;
        (this._updateBusy = !0), e.get(t, n);
      }
      loadUpdate() {
        const t = this.$gantt.ajax,
          n = this.$gantt.getUserData(0, "version", this._ganttMode);
        let e =
          this.serverProcessor +
          t.urlSeparator(this.serverProcessor) +
          ["dhx_user=" + this._user, "dhx_version=" + n].join("&");
        (e = e.replace("editing=true&", "")),
          this.getUpdates(e, (i) => {
            const a = t.xpath("//userdata", i);
            this.$gantt.setUserData(
              0,
              "version",
              this._getXmlNodeValue(a[0]),
              this._ganttMode
            );
            const r = t.xpath("//update", i);
            if (r.length) {
              this._silent_mode = !0;
              for (let s = 0; s < r.length; s++) {
                const o = r[s].getAttribute("status"),
                  l = r[s].getAttribute("id"),
                  d = r[s].getAttribute("parent");
                switch (o) {
                  case "inserted":
                    this.callEvent("insertCallback", [r[s], l, d]);
                    break;
                  case "updated":
                    this.callEvent("updateCallback", [r[s], l, d]);
                    break;
                  case "deleted":
                    this.callEvent("deleteCallback", [r[s], l, d]);
                }
              }
              this._silent_mode = !1;
            }
            this._updateBusy = !1;
          });
      }
      destructor() {
        this.callEvent("onDestroy", []),
          this.detachAllEvents(),
          (this.updatedRows = []),
          (this._in_progress = {}),
          (this._invalid = {}),
          this._storage.clear(),
          (this._storage = null),
          (this._headers = null),
          (this._payload = null),
          delete this._initialized;
      }
      setGanttMode(t) {
        t === "tasks" ? (t = "task") : t === "links" && (t = "link");
        const n = this.modes || {},
          e = this.getGanttMode();
        e &&
          (n[e] = {
            _in_progress: this._in_progress,
            _invalid: this._invalid,
            _storage: this._storage,
            updatedRows: this.updatedRows,
          });
        let i = n[t];
        i ||
          (i = n[t] =
            {
              _in_progress: {},
              _invalid: {},
              _storage: te.create(),
              updatedRows: [],
            }),
          (this._in_progress = i._in_progress),
          (this._invalid = i._invalid),
          (this._storage = i._storage),
          (this.updatedRows = i.updatedRows),
          (this.modes = n),
          (this._ganttMode = t);
      }
      getGanttMode() {
        return this._ganttMode;
      }
      storeItem(t) {
        this._storage.storeItem(t);
      }
      url(t) {
        this.serverProcessor = this._serverProcessor = t;
      }
      _beforeSendData(t, n) {
        if (!this.callEvent("onBeforeUpdate", [n, this.getState(n), t]))
          return !1;
        this._sendData(t, n);
      }
      _serializeAsJSON(t) {
        if (typeof t == "string") return t;
        const n = X(t);
        return (
          this._tMode === "REST-JSON" &&
            (delete n.id, delete n[this.action_param]),
          JSON.stringify(n)
        );
      }
      _applyPayload(t) {
        const n = this.$gantt.ajax;
        if (this._payload)
          for (const e in this._payload)
            t =
              t +
              n.urlSeparator(t) +
              this.escape(e) +
              "=" +
              this.escape(this._payload[e]);
        return t;
      }
      _cleanupArgumentsBeforeSend(t) {
        let n;
        if (t[this.action_param] === void 0) {
          n = {};
          for (const e in t) n[e] = this._cleanupArgumentsBeforeSend(t[e]);
        } else n = this._cleanupItemBeforeSend(t);
        return n;
      }
      _cleanupItemBeforeSend(t) {
        let n = null;
        return (
          t &&
            (t[this.action_param] === "deleted"
              ? ((n = {}),
                (n.id = t.id),
                (n[this.action_param] = t[this.action_param]))
              : (n = t)),
          n
        );
      }
      _sendData(t, n) {
        if (!t) return;
        if (
          !this.callEvent(
            "onBeforeDataSending",
            n ? [n, this.getState(n), t] : [null, null, t]
          )
        )
          return !1;
        n && (this._in_progress[n] = new Date().valueOf());
        const e = this.$gantt.ajax;
        if (this._tMode === "CUSTOM") {
          const l = this.getState(n),
            d = this.getActionByState(l);
          delete t[this.action_param];
          const c = this.getGanttMode(),
            u = (_) => {
              let f = l || "updated",
                y = n,
                v = n;
              _ &&
                ((f = _.action || l),
                (y = _.sid || y),
                (v = _.id || _.tid || v)),
                this.afterUpdateCallback(y, v, f, _, c);
            };
          let h;
          if (this._router instanceof Function)
            if (this._routerParametersFormat === "object") {
              const _ = { entity: c, action: d, data: t, id: n };
              h = this._router(_);
            } else h = this._router(c, d, t, n);
          else if (this._router[c] instanceof Function)
            h = this._router[c](d, t, n);
          else {
            const _ = "Incorrect configuration of gantt.createDataProcessor",
              f = `
You need to either add missing properties to the dataProcessor router object or to use a router function.
See https://docs.dhtmlx.com/gantt/desktop__server_side.html#customrouting and https://docs.dhtmlx.com/gantt/api__gantt_createdataprocessor.html for details.`;
            if (!this._router[c])
              throw new Error(
                `${_}: router for the **${c}** entity is not defined. ${f}`
              );
            switch (l) {
              case "inserted":
                if (!this._router[c].create)
                  throw new Error(
                    `${_}: **create** action for the **${c}** entity is not defined. ${f}`
                  );
                h = this._router[c].create(t);
                break;
              case "deleted":
                if (!this._router[c].delete)
                  throw new Error(
                    `${_}: **delete** action for the **${c}** entity is not defined. ${f}`
                  );
                h = this._router[c].delete(n);
                break;
              default:
                if (!this._router[c].update)
                  throw new Error(
                    `${_}: **update**" action for the **${c}** entity is not defined. ${f}`
                  );
                h = this._router[c].update(t, n);
            }
          }
          if (h) {
            if (
              !h.then &&
              h.id === void 0 &&
              h.tid === void 0 &&
              h.action === void 0
            )
              throw new Error(
                "Incorrect router return value. A Promise or a response object is expected"
              );
            h.then
              ? h.then(u).catch((_) => {
                  _ && _.action ? u(_) : u({ action: "error", value: _ });
                })
              : u(h);
          } else u(null);
          return;
        }
        let i;
        i = {
          callback: (l) => {
            const d = [];
            if (n) d.push(n);
            else if (t) for (const c in t) d.push(c);
            return this.afterUpdate(this, l, d);
          },
          headers: this._headers,
        };
        const a =
            "dhx_version=" +
            this.$gantt.getUserData(0, "version", this._ganttMode),
          r =
            this.serverProcessor +
            (this._user
              ? e.urlSeparator(this.serverProcessor) +
                ["dhx_user=" + this._user, a].join("&")
              : "");
        let s,
          o = this._applyPayload(r);
        switch (this._tMode) {
          case "GET":
            (s = this._cleanupArgumentsBeforeSend(t)),
              (i.url = o + e.urlSeparator(o) + this.serialize(s, n)),
              (i.method = "GET");
            break;
          case "POST":
            (s = this._cleanupArgumentsBeforeSend(t)),
              (i.url = o),
              (i.method = "POST"),
              (i.data = this.serialize(s, n));
            break;
          case "JSON":
            s = {};
            const l = this._cleanupItemBeforeSend(t);
            for (const d in l)
              d !== this.action_param &&
                d !== "id" &&
                d !== "gr_id" &&
                (s[d] = l[d]);
            (i.url = o),
              (i.method = "POST"),
              (i.data = JSON.stringify({
                id: n,
                action: t[this.action_param],
                data: s,
              }));
            break;
          case "REST":
          case "REST-JSON":
            switch (
              ((o = r.replace(/(&|\?)editing=true/, "")),
              (s = ""),
              this.getState(n))
            ) {
              case "inserted":
                (i.method = "POST"), (i.data = this.serialize(t, n));
                break;
              case "deleted":
                (i.method = "DELETE"),
                  (o = o + (o.slice(-1) === "/" ? "" : "/") + n);
                break;
              default:
                (i.method = "PUT"),
                  (i.data = this.serialize(t, n)),
                  (o = o + (o.slice(-1) === "/" ? "" : "/") + n);
            }
            i.url = this._applyPayload(o);
        }
        return this._waitMode++, e.query(i);
      }
      _forEachUpdatedRow(t) {
        const n = this.updatedRows.slice();
        for (let e = 0; e < n.length; e++) {
          const i = n[e];
          this.$gantt.getUserData(i, this.action_param, this._ganttMode) &&
            t.call(this, i);
        }
      }
      _setDefaultTransactionMode() {
        this.serverProcessor &&
          (this.setTransactionMode("POST", !0),
          (this.serverProcessor +=
            (this.serverProcessor.indexOf("?") !== -1 ? "&" : "?") +
            "editing=true"),
          (this._serverProcessor = this.serverProcessor));
      }
      _getXmlNodeValue(t) {
        return t.firstChild ? t.firstChild.nodeValue : "";
      }
      _getAllData() {
        const t = {};
        let n = !1;
        return (
          this._forEachUpdatedRow(function (e) {
            if (this._in_progress[e] || this.is_invalid(e)) return;
            const i = this._getRowData(e);
            this.callEvent("onBeforeUpdate", [e, this.getState(e), i]) &&
              ((t[e] = i),
              (n = !0),
              (this._in_progress[e] = new Date().valueOf()));
          }),
          n ? t : null
        );
      }
      _prepareDate(t) {
        return this.$gantt.defined(this.$gantt.templates.xml_format)
          ? this.$gantt.templates.xml_format(t)
          : this.$gantt.templates.format_date(t);
      }
      _prepareArray(t, n) {
        return (
          n.push(t),
          t.map((e) =>
            nt(e)
              ? this._prepareDate(e)
              : Array.isArray(e) && !Kt(n, e)
              ? this._prepareArray(e, n)
              : e && typeof e == "object" && !Kt(n, e)
              ? this._prepareObject(e, n)
              : e
          )
        );
      }
      _prepareObject(t, n) {
        const e = {};
        n.push(t);
        for (const i in t) {
          if (i.substr(0, 1) === "$") continue;
          const a = t[i];
          nt(a)
            ? (e[i] = this._prepareDate(a))
            : a === null
            ? (e[i] = "")
            : Array.isArray(a) && !Kt(n, a)
            ? (e[i] = this._prepareArray(a, n))
            : a && typeof a == "object" && !Kt(n, a)
            ? (e[i] = this._prepareObject(a, n))
            : (e[i] = a);
        }
        return e;
      }
      _prepareDataItem(t) {
        const n = this._prepareObject(t, []);
        return (
          (n[this.action_param] = this.$gantt.getUserData(
            t.id,
            this.action_param,
            this._ganttMode
          )),
          n
        );
      }
      getStoredItem(t) {
        return this._storage.getStoredItem(t);
      }
      _getRowData(t) {
        let n;
        const e = this.$gantt;
        return (
          this.getGanttMode() === "task"
            ? e.isTaskExists(t) && (n = this.$gantt.getTask(t))
            : this.getGanttMode() === "assignment"
            ? this.$gantt.$data.assignmentsStore.exists(t) &&
              (n = this.$gantt.$data.assignmentsStore.getItem(t))
            : this.getGanttMode() === "baseline"
            ? this.$gantt.$data.baselineStore.exists(t) &&
              (n = this.$gantt.$data.baselineStore.getItem(t))
            : e.isLinkExists(t) && (n = this.$gantt.getLink(t)),
          n || (n = this.getStoredItem(t)),
          n || (n = { id: t }),
          this._prepareDataItem(n)
        );
      }
    };
  const Ii = function (t) {
      return new An(t);
    },
    Li = function (t) {
      let n, e, i;
      t instanceof Function
        ? (n = t)
        : t.hasOwnProperty("router")
        ? (n = t.router)
        : t.hasOwnProperty("assignment") ||
          t.hasOwnProperty("baseline") ||
          t.hasOwnProperty("link") ||
          t.hasOwnProperty("task")
        ? (n = t)
        : t.hasOwnProperty("headers") && (i = t.headers),
        (e = n ? "CUSTOM" : t.mode || "REST-JSON");
      const a = new An(t.url);
      return (
        a.init(this),
        a.setTransactionMode({ mode: e, router: n, headers: i }, t.batchUpdate),
        t.deleteAfterConfirmation &&
          (a.deleteAfterConfirmation = t.deleteAfterConfirmation),
        a
      );
    };
  function Ni(t) {
    var n = {},
      e = !1;
    function i(l, d) {
      (d = typeof d == "function" ? d : function () {}),
        n[l] || ((n[l] = this[l]), (this[l] = d));
    }
    function a(l) {
      n[l] && ((this[l] = n[l]), (n[l] = null));
    }
    function r(l) {
      for (var d in l) i.call(this, d, l[d]);
    }
    function s() {
      for (var l in n) a.call(this, l);
    }
    function o(l) {
      try {
        l();
      } catch (d) {
        J.console.error(d);
      }
    }
    return (
      t.$services.getService("state").registerProvider(
        "batchUpdate",
        function () {
          return { batch_update: e };
        },
        !1
      ),
      function (l, d) {
        if (e) o(l);
        else {
          var c,
            u = this._dp && this._dp.updateMode != "off";
          u && ((c = this._dp.updateMode), this._dp.setUpdateMode("off"));
          var h = {},
            _ = {
              render: !0,
              refreshData: !0,
              refreshTask: !0,
              refreshLink: !0,
              resetProjectDates: function (y) {
                h[y.id] = y;
              },
            };
          for (var f in (r.call(this, _),
          (e = !0),
          this.callEvent("onBeforeBatchUpdate", []),
          o(l),
          this.callEvent("onAfterBatchUpdate", []),
          s.call(this),
          h))
            this.resetProjectDates(h[f]);
          (e = !1),
            d || this.render(),
            u &&
              (this._dp.setUpdateMode(c),
              this._dp.setGanttMode("task"),
              this._dp.sendData(),
              this._dp.setGanttMode("link"),
              this._dp.sendData());
        }
      }
    );
  }
  function Pi(t) {
    t.batchUpdate = Ni(t);
  }
  function Ri(t) {
    const n = (function (i) {
      return {
        _needRecalc: !0,
        reset: function () {
          this._needRecalc = !0;
        },
        _isRecalcNeeded: function () {
          return !this._isGroupSort() && this._needRecalc;
        },
        _isGroupSort: function () {
          return !!i.getState().group_mode;
        },
        _getWBSCode: function (a) {
          return a
            ? (this._isRecalcNeeded() && this._calcWBS(),
              a.$virtual
                ? ""
                : this._isGroupSort()
                ? a.$wbs || ""
                : (a.$wbs || (this.reset(), this._calcWBS()), a.$wbs))
            : "";
        },
        _setWBSCode: function (a, r) {
          a.$wbs = r;
        },
        getWBSCode: function (a) {
          return this._getWBSCode(a);
        },
        getByWBSCode: function (a) {
          let r = a.split("."),
            s = i.config.root_id;
          for (let o = 0; o < r.length; o++) {
            const l = i.getChildren(s);
            let d = 1 * r[o] - 1;
            if (!i.isTaskExists(l[d])) return null;
            s = l[d];
          }
          return i.isTaskExists(s) ? i.getTask(s) : null;
        },
        _calcWBS: function () {
          if (!this._isRecalcNeeded()) return;
          let a = !0;
          i.eachTask(
            function (r) {
              if (r.type == i.config.types.placeholder) return;
              if (a) return (a = !1), void this._setWBSCode(r, "1");
              const s = this._getPrevNonPlaceholderSibling(r.id);
              if (s !== null) this._increaseWBS(r, s);
              else {
                let o = i.getParent(r.id);
                this._setWBSCode(r, i.getTask(o).$wbs + ".1");
              }
            },
            i.config.root_id,
            this
          ),
            (this._needRecalc = !1);
        },
        _increaseWBS: function (a, r) {
          let s = i.getTask(r).$wbs;
          s &&
            ((s = s.split(".")),
            s[s.length - 1]++,
            this._setWBSCode(a, s.join(".")));
        },
        _getPrevNonPlaceholderSibling: function (a) {
          let r,
            s = a;
          do (r = i.getPrevSibling(s)), (s = r);
          while (r !== null && i.getTask(r).type == i.config.types.placeholder);
          return r;
        },
      };
    })(t);
    function e() {
      return n.reset(), !0;
    }
    (t.getWBSCode = function (i) {
      return n.getWBSCode(i);
    }),
      (t.getTaskByWBSCode = function (i) {
        return n.getByWBSCode(i);
      }),
      t.attachEvent("onAfterTaskMove", e),
      t.attachEvent("onBeforeParse", e),
      t.attachEvent("onAfterTaskDelete", e),
      t.attachEvent("onAfterTaskAdd", e),
      t.attachEvent("onAfterSort", e);
  }
  function Hi(t) {
    var n = {},
      e = !1;
    t.$data.tasksStore.attachEvent("onStoreUpdated", function () {
      (n = {}), (e = !1);
    }),
      t.attachEvent("onBeforeGanttRender", function () {
        n = {};
      });
    var i = String(Math.random());
    function a(l) {
      return l === null ? i + String(l) : String(l);
    }
    function r(l, d, c) {
      return Array.isArray(l)
        ? l
            .map(function (u) {
              return a(u);
            })
            .join("_") + `_${d}_${c}`
        : a(l) + `_${d}_${c}`;
    }
    function s(l, d, c) {
      var u,
        h = r(d, l, JSON.stringify(c)),
        _ = {};
      return (
        st(d, function (f) {
          _[a(f)] = !0;
        }),
        n[h]
          ? (u = n[h])
          : ((u = n[h] = []),
            t.eachTask(function (f) {
              if (c) {
                if (!c[t.getTaskType(f)]) return;
              } else if (f.type == t.config.types.project) return;
              l in f &&
                st(Lt(f[l]) ? f[l] : [f[l]], function (y) {
                  var v = y && y.resource_id ? y.resource_id : y;
                  if (_[a(v)]) u.push(f);
                  else if (!e) {
                    var b = r(y, l);
                    n[b] || (n[b] = []), n[b].push(f);
                  }
                });
            }),
            (e = !0)),
        u
      );
    }
    function o(l, d, c) {
      var u = t.config.resource_property,
        h = [];
      if (t.getDatastore("task").exists(d)) {
        var _ = t.getTask(d);
        h = _[u] || [];
      }
      Array.isArray(h) || (h = [h]);
      for (var f = 0; f < h.length; f++)
        h[f].resource_id == l &&
          c.push({
            task_id: _.id,
            resource_id: h[f].resource_id,
            value: h[f].value,
          });
    }
    return {
      getTaskBy: function (l, d, c) {
        return typeof l == "function"
          ? ((u = l),
            (h = []),
            t.eachTask(function (_) {
              u(_) && h.push(_);
            }),
            h)
          : Lt(d)
          ? s(l, d, c)
          : s(l, [d], c);
        var u, h;
      },
      getResourceAssignments: function (l, d) {
        var c = [],
          u = t.config.resource_property;
        return (
          d !== void 0
            ? o(l, d, c)
            : t.getTaskBy(u, l).forEach(function (h) {
                o(l, h.id, c);
              }),
          c
        );
      },
    };
  }
  function Oi(t) {
    var n = Hi(t);
    (t.ext.resources = (function (a) {
      const r = {
        renderEditableLabel: function (s, o, l, d, c) {
          const u = a.config.readonly ? "" : "contenteditable";
          if (s < l.end_date && o > l.start_date) {
            for (let h = 0; h < c.length; h++) {
              const _ = c[h];
              return (
                "<div " +
                u +
                " data-assignment-cell data-assignment-id='" +
                _.id +
                "' data-row-id='" +
                l.id +
                "' data-task='" +
                l.$task_id +
                "' data-start-date='" +
                a.templates.format_date(s) +
                "' data-end-date='" +
                a.templates.format_date(o) +
                "'>" +
                _.value +
                "</div>"
              );
            }
            return (
              "<div " +
              u +
              " data-assignment-cell data-empty  data-row-id='" +
              l.id +
              "' data-resource-id='" +
              l.$resource_id +
              "' data-task='" +
              l.$task_id +
              "' data-start-date='" +
              a.templates.format_date(s) +
              "''  data-end-date='" +
              a.templates.format_date(o) +
              "'>-</div>"
            );
          }
          return "";
        },
        renderSummaryLabel: function (s, o, l, d, c) {
          let u = c.reduce(function (h, _) {
            return h + Number(_.value);
          }, 0);
          return (
            u % 1 && (u = Math.round(10 * u) / 10),
            u ? "<div>" + u + "</div>" : ""
          );
        },
        editableResourceCellTemplate: function (s, o, l, d, c) {
          return l.$role === "task"
            ? r.renderEditableLabel(s, o, l, d, c)
            : r.renderSummaryLabel(s, o, l, d, c);
        },
        editableResourceCellClass: function (s, o, l, d, c) {
          const u = [];
          u.push("resource_marker"),
            l.$role === "task" ? u.push("task_cell") : u.push("resource_cell");
          const h = c.reduce(function (f, y) {
            return f + Number(y.value);
          }, 0);
          let _ = Number(l.capacity);
          return (
            isNaN(_) && (_ = 8),
            h <= _ ? u.push("workday_ok") : u.push("workday_over"),
            u.join(" ")
          );
        },
        getSummaryResourceAssignments: function (s) {
          let o;
          const l = a.getDatastore(a.config.resource_store),
            d = l.getItem(s);
          return (
            d.$role === "task"
              ? (o = a.getResourceAssignments(d.$resource_id, d.$task_id))
              : ((o = a.getResourceAssignments(s)),
                l.eachItem &&
                  l.eachItem(function (c) {
                    c.$role !== "task" &&
                      (o = o.concat(a.getResourceAssignments(c.id)));
                  }, s)),
            o
          );
        },
        initEditableDiagram: function () {
          (a.config.resource_render_empty_cells = !0),
            (function () {
              let l = null;
              function d() {
                return (
                  l && cancelAnimationFrame(l),
                  (l = requestAnimationFrame(function () {
                    a.$container &&
                      Array.prototype.slice
                        .call(
                          a.$container.querySelectorAll(
                            ".resourceTimeline_cell [data-assignment-cell]"
                          )
                        )
                        .forEach(function (c) {
                          c.contentEditable = !0;
                        });
                  })),
                  !0
                );
              }
              a.attachEvent(
                "onGanttReady",
                function () {
                  a
                    .getDatastore(a.config.resource_assignment_store)
                    .attachEvent("onStoreUpdated", d),
                    a
                      .getDatastore(a.config.resource_store)
                      .attachEvent("onStoreUpdated", d);
                },
                { once: !0 }
              ),
                a.attachEvent("onGanttLayoutReady", function () {
                  a.$layout.getCellsByType("viewCell").forEach(function (c) {
                    c.$config &&
                      c.$config.view === "resourceTimeline" &&
                      c.$content &&
                      c.$content.attachEvent("onScroll", d);
                  });
                });
            })();
          let s = null;
          function o() {
            setTimeout(function () {
              const l = zt(a.$container);
              s > -1 && l[s + 1].focus();
            }, 300);
          }
          a.attachEvent(
            "onGanttReady",
            function () {
              let l = !1;
              a.event(a.$container, "keypress", function (d) {
                var c = d.target.closest(
                  ".resourceTimeline_cell [data-assignment-cell]"
                );
                c && ((d.keyCode !== 13 && d.keyCode !== 27) || c.blur());
              }),
                a.event(a.$container, "keydown", function (d) {
                  d.key === "Tab" &&
                    (s = zt(a.$container).indexOf(document.activeElement));
                }),
                a.event(a.$container, "focusout", function (d) {
                  if (!l) {
                    (l = !0),
                      setTimeout(function () {
                        l = !1;
                      }, 300);
                    var c = d.target.closest(
                      ".resourceTimeline_cell [data-assignment-cell]"
                    );
                    if (c) {
                      var u = (c.innerText || "").trim();
                      u == "-" && (u = "0");
                      var h = Number(u),
                        _ = c.getAttribute("data-row-id"),
                        f = c.getAttribute("data-assignment-id"),
                        y = c.getAttribute("data-task"),
                        v = c.getAttribute("data-resource-id"),
                        b = a.templates.parse_date(
                          c.getAttribute("data-start-date")
                        ),
                        g = a.templates.parse_date(
                          c.getAttribute("data-end-date")
                        ),
                        m = a.getDatastore(a.config.resource_assignment_store);
                      if (isNaN(h))
                        a.getDatastore(a.config.resource_store).refresh(_);
                      else {
                        var p = a.getTask(y);
                        if (
                          (a.plugins().undo && a.ext.undo.saveState(y, "task"),
                          f)
                        ) {
                          if (h === (w = m.getItem(f)).value) return;
                          if (
                            w.start_date.valueOf() === b.valueOf() &&
                            w.end_date.valueOf() === g.valueOf()
                          )
                            (w.value = h),
                              h ? m.updateItem(w.id) : m.removeItem(w.id);
                          else {
                            if (w.end_date.valueOf() > g.valueOf()) {
                              var k = a.copy(w);
                              (k.id = a.uid()),
                                (k.start_date = g),
                                (k.duration = a.calculateDuration({
                                  start_date: k.start_date,
                                  end_date: k.end_date,
                                  task: p,
                                })),
                                (k.delay = a.calculateDuration({
                                  start_date: p.start_date,
                                  end_date: k.start_date,
                                  task: p,
                                })),
                                (k.mode = w.mode || "default"),
                                k.duration !== 0 && m.addItem(k);
                            }
                            w.start_date.valueOf() < b.valueOf()
                              ? ((w.end_date = b),
                                (w.duration = a.calculateDuration({
                                  start_date: w.start_date,
                                  end_date: w.end_date,
                                  task: p,
                                })),
                                (w.mode = "fixedDuration"),
                                w.duration === 0
                                  ? m.removeItem(w.id)
                                  : m.updateItem(w.id))
                              : m.removeItem(w.id),
                              h &&
                                m.addItem({
                                  task_id: w.task_id,
                                  resource_id: w.resource_id,
                                  value: h,
                                  start_date: b,
                                  end_date: g,
                                  duration: a.calculateDuration({
                                    start_date: b,
                                    end_date: g,
                                    task: p,
                                  }),
                                  delay: a.calculateDuration({
                                    start_date: p.start_date,
                                    end_date: b,
                                    task: p,
                                  }),
                                  mode: "fixedDuration",
                                });
                          }
                          a.updateTaskAssignments(p.id),
                            a.updateTask(p.id),
                            o();
                        } else if (h) {
                          var w = {
                            task_id: y,
                            resource_id: v,
                            value: h,
                            start_date: b,
                            end_date: g,
                            duration: a.calculateDuration({
                              start_date: b,
                              end_date: g,
                              task: p,
                            }),
                            delay: a.calculateDuration({
                              start_date: p.start_date,
                              end_date: b,
                              task: p,
                            }),
                            mode: "fixedDuration",
                          };
                          m.addItem(w),
                            a.updateTaskAssignments(p.id),
                            a.updateTask(p.id),
                            o();
                        }
                      }
                    }
                  }
                });
            },
            { once: !0 }
          );
        },
      };
      return r;
    })(t)),
      (t.config.resources = {
        dataprocessor_assignments: !1,
        dataprocessor_resources: !1,
        editable_resource_diagram: !1,
        resource_store: {
          type: "treeDataStore",
          fetchTasks: !1,
          initItem: function (a) {
            return (
              (a.parent = a.parent || t.config.root_id),
              (a[t.config.resource_property] = a.parent),
              (a.open = !0),
              a
            );
          },
        },
        lightbox_resources: function (a) {
          const r = [],
            s = t.getDatastore(t.config.resource_store);
          return (
            a.forEach(function (o) {
              if (!s.hasChild(o.id)) {
                const l = t.copy(o);
                (l.key = o.id), (l.label = o.text), r.push(l);
              }
            }),
            r
          );
        },
      }),
      t.attachEvent("onBeforeGanttReady", function () {
        if (t.getDatastore(t.config.resource_store)) return;
        const a = t.config.resources
          ? t.config.resources.resource_store
          : void 0;
        let r = a ? a.fetchTasks : void 0;
        t.config.resources &&
          t.config.resources.editable_resource_diagram &&
          (r = !0);
        let s = function (l) {
          return (
            (l.parent = l.parent || t.config.root_id),
            (l[t.config.resource_property] = l.parent),
            (l.open = !0),
            l
          );
        };
        a && a.initItem && (s = a.initItem);
        const o = a && a.type ? a.type : "treeDatastore";
        (t.$resourcesStore = t.createDatastore({
          name: t.config.resource_store,
          type: o,
          fetchTasks: r !== void 0 && r,
          initItem: s,
        })),
          (t.$data.resourcesStore = t.$resourcesStore),
          t.$resourcesStore.attachEvent("onParse", function () {
            let l,
              d = function (c) {
                const u = [];
                return (
                  c.forEach(function (h) {
                    const _ = t.copy(h);
                    (_.key = h.id), (_.label = h.text), u.push(_);
                  }),
                  u
                );
              };
            t.config.resources &&
              t.config.resources.lightbox_resources &&
              (d = t.config.resources.lightbox_resources),
              t.config.resources && t.config.resources.editable_resource_diagram
                ? (l = d(
                    t.$resourcesStore.getItems().filter((c) => {
                      let u = t.getResourceAssignments(c.id);
                      if (!t.$resourcesStore.hasChild(c.id) || (u && u.length))
                        return !c.$resource_id || !c.$task_id;
                    })
                  ))
                : (l = d(t.$resourcesStore.getItems())),
              t.updateCollection("resourceOptions", l);
          });
      }),
      (t.getTaskBy = n.getTaskBy),
      (t.getResourceAssignments = n.getResourceAssignments),
      (t.config.resource_property = "owner_id"),
      (t.config.resource_store = "resource"),
      (t.config.resource_render_empty_cells = !1),
      (t.templates.histogram_cell_class = function (a, r, s, o, l) {}),
      (t.templates.histogram_cell_label = function (a, r, s, o, l) {
        return o.length + "/3";
      }),
      (t.templates.histogram_cell_allocated = function (a, r, s, o, l) {
        return o.length / 3;
      }),
      (t.templates.histogram_cell_capacity = function (a, r, s, o, l) {
        return 0;
      });
    const e = function (a, r, s, o, l) {
        return o.length <= 1
          ? "gantt_resource_marker_ok"
          : "gantt_resource_marker_overtime";
      },
      i = function (a, r, s, o, l) {
        return 8 * o.length;
      };
    (t.templates.resource_cell_value = i),
      (t.templates.resource_cell_class = e),
      t.attachEvent("onBeforeGanttReady", function () {
        t.config.resources &&
          t.config.resources.editable_resource_diagram &&
          ((t.config.resource_render_empty_cells = !0),
          t.templates.resource_cell_value === i &&
            (t.templates.resource_cell_value =
              t.ext.resources.editableResourceCellTemplate),
          t.templates.resource_cell_class === e &&
            (t.templates.resource_cell_class =
              t.ext.resources.editableResourceCellClass),
          t.ext.resources.initEditableDiagram(t));
      });
  }
  function Bi(t) {
    var n = "$resourceAssignments";
    (t.config.resource_assignment_store = "resourceAssignments"),
      (t.config.process_resource_assignments = !0);
    var e = "auto",
      i = "singleValue",
      a = "valueArray",
      r = "resourceValueArray",
      s = "assignmentsArray",
      o = e,
      l = "fixedDates",
      d = "fixedDuration",
      c = "default";
    function u(p, k) {
      p.start_date
        ? (p.start_date = t.date.parseDate(p.start_date, "parse_date"))
        : (p.start_date = null),
        p.end_date
          ? (p.end_date = t.date.parseDate(p.end_date, "parse_date"))
          : (p.end_date = null);
      var w = Number(p.delay),
        x = !1;
      if (
        (isNaN(w) ? ((p.delay = 0), (x = !0)) : (p.delay = w),
        t.defined(p.value) || (p.value = null),
        !p.task_id || !p.resource_id)
      )
        return !1;
      if (
        ((p.mode = p.mode || c),
        p.mode === d &&
          (isNaN(Number(p.duration)) &&
            ((k = k || t.getTask(p.task_id)),
            (p.duration = t.calculateDuration({
              start_date: p.start_date,
              end_date: p.end_date,
              id: k,
            }))),
          x &&
            ((k = k || t.getTask(p.task_id)),
            (p.delay = t.calculateDuration({
              start_date: k.start_date,
              end_date: p.start_date,
              id: k,
            })))),
        p.mode !== l && (k || t.isTaskExists(p.task_id)))
      ) {
        var $ = _(p, (k = k || t.getTask(p.task_id)));
        (p.start_date = $.start_date),
          (p.end_date = $.end_date),
          (p.duration = $.duration);
      }
    }
    var h = t.createDatastore({
      name: t.config.resource_assignment_store,
      initItem: function (p) {
        return p.id || (p.id = t.uid()), u(p), p;
      },
    });
    function _(p, k) {
      if (p.mode === l)
        return {
          start_date: p.start_date,
          end_date: p.end_date,
          duration: p.duration,
        };
      var w,
        x,
        $ = p.delay
          ? t.calculateEndDate({
              start_date: k.start_date,
              duration: p.delay,
              task: k,
            })
          : new Date(k.start_date);
      return (
        p.mode === d
          ? ((w = t.calculateEndDate({
              start_date: $,
              duration: p.duration,
              task: k,
            })),
            (x = p.duration))
          : ((w = new Date(k.end_date)), (x = k.duration - p.delay)),
        { start_date: $, end_date: w, duration: x }
      );
    }
    function f(p) {
      const k = t.config.resource_property;
      let w = p[k];
      const x = [];
      let $ = o === e;
      if (t.defined(w) && w) {
        Array.isArray(w) || ((w = [w]), $ && ((o = i), ($ = !1)));
        const S = {};
        w.forEach(function (T) {
          T.resource_id || ((T = { resource_id: T }), $ && ((o = a), ($ = !1))),
            $ &&
              (T.id && T.resource_id
                ? ((o = s), ($ = !1))
                : ((o = r), ($ = !1)));
          let E,
            C = c;
          T.mode ||
            (((T.start_date && T.end_date) || (T.start_date && T.duration)) &&
              (C = d)),
            (E =
              T.id || !T.$id || S[T.$id]
                ? T.id && !S[T.id]
                  ? T.id
                  : t.uid()
                : T.$id),
            (S[E] = !0);
          const D = {
            id: E,
            start_date: T.start_date,
            duration: T.duration,
            end_date: T.end_date,
            delay: T.delay,
            task_id: p.id,
            resource_id: T.resource_id,
            value: T.value,
            mode: T.mode || C,
          };
          Object.keys(T).forEach((A) => {
            A != "$id" && (D[A] = T[A]);
          }),
            (D.start_date &&
              D.start_date.getMonth &&
              D.end_date &&
              D.end_date.getMonth &&
              typeof D.duration == "number") ||
              u(D, p),
            x.push(D);
        });
      }
      return x;
    }
    function y(p) {
      if (t.isTaskExists(p)) {
        var k = t.getTask(p);
        v(k, t.getTaskAssignments(k.id));
      }
    }
    function v(p, k) {
      k.sort(function (w, x) {
        return w.start_date &&
          x.start_date &&
          w.start_date.valueOf() != x.start_date.valueOf()
          ? w.start_date - x.start_date
          : 0;
      }),
        o == s
          ? (p[t.config.resource_property] = k)
          : o == r &&
            (p[t.config.resource_property] = k.map(function (w) {
              return {
                $id: w.id,
                start_date: w.start_date,
                duration: w.duration,
                end_date: w.end_date,
                delay: w.delay,
                resource_id: w.resource_id,
                value: w.value,
                mode: w.mode,
              };
            })),
        (p[n] = k);
    }
    function b(p) {
      var k = f(p);
      return (
        k.forEach(function (w) {
          w.id = w.id || t.uid();
        }),
        k
      );
    }
    function g(p, k) {
      var w = (function (x, $) {
        var S = { inBoth: [], inTaskNotInStore: [], inStoreNotInTask: [] };
        if (o == i) {
          var T = x[0],
            E = T ? T.resource_id : null,
            C = !1;
          $.forEach(function (M) {
            M.resource_id != E
              ? S.inStoreNotInTask.push(M)
              : M.resource_id == E &&
                (S.inBoth.push({ store: M, task: T }), (C = !0));
          }),
            !C && T && S.inTaskNotInStore.push(T);
        } else if (o == a) {
          var D = {},
            A = {},
            I = {};
          x.forEach(function (M) {
            D[M.resource_id] = M;
          }),
            $.forEach(function (M) {
              A[M.resource_id] = M;
            }),
            x.concat($).forEach(function (M) {
              if (!I[M.resource_id]) {
                I[M.resource_id] = !0;
                var L = D[M.resource_id],
                  N = A[M.resource_id];
                L && N
                  ? S.inBoth.push({ store: N, task: L })
                  : L && !N
                  ? S.inTaskNotInStore.push(L)
                  : !L && N && S.inStoreNotInTask.push(N);
              }
            });
        } else
          (o != s && o != r) ||
            ((D = {}),
            (A = {}),
            (I = {}),
            x.forEach(function (M) {
              D[M.id || M.$id] = M;
            }),
            $.forEach(function (M) {
              A[M.id] = M;
            }),
            x.concat($).forEach(function (M) {
              var L = M.id || M.$id;
              if (!I[L]) {
                I[L] = !0;
                var N = D[L],
                  P = A[L];
                N && P
                  ? S.inBoth.push({ store: P, task: N })
                  : N && !P
                  ? S.inTaskNotInStore.push(N)
                  : !N && P && S.inStoreNotInTask.push(P);
              }
            }));
        return S;
      })(f(p), k);
      w.inStoreNotInTask.forEach(function (x) {
        h.removeItem(x.id);
      }),
        w.inTaskNotInStore.forEach(function (x) {
          h.addItem(x);
        }),
        w.inBoth.forEach(function (x) {
          if (
            (function (S, T) {
              var E = { id: !0 };
              for (var C in S)
                if (!E[C] && String(S[C]) !== String(T[C])) return !0;
              return !1;
            })(x.task, x.store)
          )
            (function (S, T) {
              var E = { id: !0 };
              for (var C in S) E[C] || (T[C] = S[C]);
            })(x.task, x.store),
              h.updateItem(x.store.id);
          else if (x.task.start_date && x.task.end_date && x.task.mode !== l) {
            var $ = _(x.store, p);
            (x.store.start_date.valueOf() == $.start_date.valueOf() &&
              x.store.end_date.valueOf() == $.end_date.valueOf()) ||
              ((x.store.start_date = $.start_date),
              (x.store.end_date = $.end_date),
              (x.store.duration = $.duration),
              h.updateItem(x.store.id));
          }
        }),
        y(p.id);
    }
    function m(p) {
      var k =
        p[n] ||
        h.find(function (w) {
          return w.task_id == p.id;
        });
      g(p, k);
    }
    (t.$data.assignmentsStore = h),
      t.attachEvent(
        "onGanttReady",
        function () {
          if (t.config.process_resource_assignments) {
            t.attachEvent("onParse", function () {
              t.silent(function () {
                h.clearAll();
                var E = [];
                t.eachTask(function (C) {
                  if (C.type !== t.config.types.project) {
                    var D = b(C);
                    v(C, D),
                      D.forEach(function (A) {
                        E.push(A);
                      });
                  }
                }),
                  h.parse(E);
              });
            });
            var p = !1,
              k = !1,
              w = {},
              x = !1;
            t.attachEvent("onBeforeBatchUpdate", function () {
              p = !0;
            }),
              t.attachEvent("onAfterBatchUpdate", function () {
                if (k) {
                  var E = {};
                  for (var C in w) E[C] = t.getTaskAssignments(w[C].id);
                  for (var C in (t.config.process_resource_assignments &&
                    o === "resourceValueArray" &&
                    (T = null),
                  w))
                    g(w[C], E[C]);
                }
                (k = !1), (p = !1), (w = {});
              }),
              t.attachEvent("onTaskCreated", function (E) {
                var C = b(E);
                return h.parse(C), v(E, C), !0;
              }),
              t.attachEvent("onAfterTaskUpdate", function (E, C) {
                p ? ((k = !0), (w[E] = C)) : C.unscheduled || m(C);
              }),
              t.attachEvent("onAfterTaskAdd", function (E, C) {
                p ? ((k = !0), (w[E] = C)) : m(C);
              }),
              t.attachEvent("onRowDragEnd", function (E) {
                m(t.getTask(E));
              }),
              t.$data.tasksStore.attachEvent(
                "onAfterDeleteConfirmed",
                function (E, C) {
                  var D,
                    A = [E];
                  t.eachTask(function (I) {
                    A.push(I.id);
                  }, E),
                    (D = {}),
                    A.forEach(function (I) {
                      D[I] = !0;
                    }),
                    h
                      .find(function (I) {
                        return D[I.task_id];
                      })
                      .forEach(function (I) {
                        h.removeItem(I.id);
                      });
                }
              ),
              t.$data.tasksStore.attachEvent("onClearAll", function () {
                return ($ = null), (S = null), (T = null), h.clearAll(), !0;
              }),
              t.attachEvent("onTaskIdChange", function (E, C) {
                h
                  .find(function (D) {
                    return D.task_id == E;
                  })
                  .forEach(function (D) {
                    (D.task_id = C), h.updateItem(D.id);
                  }),
                  y(C);
              }),
              t.attachEvent("onBeforeUndo", function (E) {
                return (x = !0), !0;
              }),
              t.attachEvent("onAfterUndo", function (E) {
                x = !0;
              });
            var $ = null,
              S = null,
              T = null;
            h.attachEvent("onStoreUpdated", function () {
              return (p && !x) || (($ = null), (S = null), (T = null)), !0;
            }),
              (t.getResourceAssignments = function (E, C) {
                var D = t.defined(C) && C !== null;
                return (
                  $ === null &&
                    (($ = {}),
                    (S = {}),
                    h.eachItem(function (A) {
                      $[A.resource_id] || ($[A.resource_id] = []),
                        $[A.resource_id].push(A);
                      var I = A.resource_id + "-" + A.task_id;
                      S[I] || (S[I] = []), S[I].push(A);
                    })),
                  D ? (S[E + "-" + C] || []).slice() : ($[E] || []).slice()
                );
              }),
              (t.getTaskAssignments = function (E) {
                if (T === null) {
                  var C = [];
                  (T = {}),
                    h.eachItem(function (D) {
                      T[D.task_id] || (T[D.task_id] = []),
                        T[D.task_id].push(D),
                        D.task_id == E && C.push(D);
                    });
                }
                return (T[E] || []).slice();
              }),
              (t.getTaskResources = function (E) {
                const C = t.getDatastore("resource"),
                  D = t.getTaskAssignments(E),
                  A = {};
                D.forEach(function (M) {
                  A[M.resource_id] || (A[M.resource_id] = M.resource_id);
                });
                const I = [];
                for (const M in A) {
                  const L = C.getItem(A[M]);
                  L && I.push(L);
                }
                return I;
              }),
              (t.updateTaskAssignments = y);
          }
        },
        { once: !0 }
      );
  }
  function zi(t) {
    function n(o) {
      return function () {
        return !t.config.placeholder_task || o.apply(this, arguments);
      };
    }
    function e() {
      var o = t.getTaskBy("type", t.config.types.placeholder);
      if (!o.length || !t.isTaskExists(o[0].id)) {
        var l = {
          unscheduled: !0,
          type: t.config.types.placeholder,
          duration: 0,
          text: t.locale.labels.new_task,
        };
        if (t.callEvent("onTaskCreated", [l]) === !1) return;
        t.addTask(l);
      }
    }
    function i(o) {
      var l = t.getTask(o);
      l.type == t.config.types.placeholder &&
        (l.start_date && l.end_date && l.unscheduled && (l.unscheduled = !1),
        t.batchUpdate(function () {
          var d = t.copy(l);
          t.silent(function () {
            t.deleteTask(l.id);
          }),
            delete d["!nativeeditor_status"],
            (d.type = t.config.types.task),
            (d.id = t.uid()),
            t.addTask(d);
        }));
    }
    (t.config.types.placeholder = "placeholder"),
      t.attachEvent(
        "onDataProcessorReady",
        n(function (o) {
          o &&
            !o._silencedPlaceholder &&
            ((o._silencedPlaceholder = !0),
            o.attachEvent(
              "onBeforeUpdate",
              n(function (l, d, c) {
                return (
                  c.type != t.config.types.placeholder ||
                  (o.setUpdated(l, !1), !1)
                );
              })
            ));
        })
      );
    var a = !1;
    function r(o) {
      return !!(
        t.config.types.placeholder &&
        t.isTaskExists(o) &&
        t.getTask(o).type == t.config.types.placeholder
      );
    }
    function s(o) {
      return !(!r(o.source) && !r(o.target));
    }
    t.attachEvent("onGanttReady", function () {
      a ||
        ((a = !0),
        t.attachEvent("onAfterTaskUpdate", n(i)),
        t.attachEvent(
          "onAfterTaskAdd",
          n(function (o, l) {
            l.type != t.config.types.placeholder &&
              (t
                .getTaskBy("type", t.config.types.placeholder)
                .forEach(function (d) {
                  t.silent(function () {
                    t.isTaskExists(d.id) && t.deleteTask(d.id);
                  });
                }),
              e());
          })
        ),
        t.attachEvent("onParse", n(e)));
    }),
      t.attachEvent("onLinkValidation", function (o) {
        return !s(o);
      }),
      t.attachEvent("onBeforeLinkAdd", function (o, l) {
        return !s(l);
      }),
      t.attachEvent("onBeforeUndoStack", function (o) {
        for (var l = 0; l < o.commands.length; l++) {
          var d = o.commands[l];
          d.entity === "task" &&
            d.value.type === t.config.types.placeholder &&
            (o.commands.splice(l, 1), l--);
        }
        return !0;
      });
  }
  function ji(t) {
    function n(c) {
      return function () {
        return (
          !t.config.auto_types ||
          t.getTaskType(t.config.types.project) != t.config.types.project ||
          c.apply(this, arguments)
        );
      };
    }
    function e(c, u) {
      var h = t.getTask(c),
        _ = r(h);
      _ !== !1 &&
        t.getTaskType(h) !== _ &&
        ((u.$needsUpdate = !0), (u[h.id] = { task: h, type: _ }));
    }
    function i(c) {
      if (!t.getState().group_mode) {
        var u = (function (h, _) {
          return (
            e(h, (_ = _ || {})),
            t.eachParent(function (f) {
              e(f.id, _);
            }, h),
            _
          );
        })(c);
        u.$needsUpdate &&
          t.batchUpdate(function () {
            (function (h) {
              for (var _ in h)
                if (h[_] && h[_].task) {
                  var f = h[_].task;
                  (f.type = h[_].type), t.updateTask(f.id);
                }
            })(u);
          });
      }
    }
    var a;
    function r(c) {
      var u = t.config.types,
        h = t.hasChild(c.id),
        _ = t.getTaskType(c.type);
      return h && _ === u.task ? u.project : !h && _ === u.project && u.task;
    }
    var s,
      o,
      l = !0;
    function d(c) {
      c != t.config.root_id && t.isTaskExists(c) && i(c);
    }
    t.attachEvent(
      "onParse",
      n(function () {
        (l = !1),
          t.getState().group_mode ||
            (t.batchUpdate(function () {
              t.eachTask(function (c) {
                var u = r(c);
                u !== !1 &&
                  (function (h, _) {
                    t.getState().group_mode ||
                      ((h.type = _), t.updateTask(h.id));
                  })(c, u);
              });
            }),
            (l = !0));
      })
    ),
      t.attachEvent(
        "onAfterTaskAdd",
        n(function (c) {
          l && i(c);
        })
      ),
      t.attachEvent(
        "onAfterTaskUpdate",
        n(function (c) {
          l && i(c);
        })
      ),
      t.attachEvent(
        "onBeforeTaskDelete",
        n(function (c, u) {
          return (a = t.getParent(c)), !0;
        })
      ),
      t.attachEvent(
        "onAfterTaskDelete",
        n(function (c, u) {
          d(a);
        })
      ),
      t.attachEvent(
        "onRowDragStart",
        n(function (c, u, h) {
          return (s = t.getParent(c)), !0;
        })
      ),
      t.attachEvent(
        "onRowDragEnd",
        n(function (c, u) {
          d(s), i(c);
        })
      ),
      t.attachEvent(
        "onBeforeTaskMove",
        n(function (c, u, h) {
          return (o = t.getParent(c)), !0;
        })
      ),
      t.attachEvent(
        "onAfterTaskMove",
        n(function (c, u, h) {
          document.querySelector(".gantt_drag_marker") || (d(o), i(c));
        })
      );
  }
  const ce = class ce {
    constructor(n = null) {
      (this.canParse = (e) => {
        let i = "";
        const a = this._config.labels;
        for (const r in a) {
          const s = a[r];
          i += `${s.full}|${s.plural}|${s.short}|`;
        }
        return new RegExp(`^([+-]? *[0-9.]{1,}\\s*(${i})\\s*)*$`).test(
          (e || "").trim()
        );
      }),
        (this.format = (e) => {
          const i = this._config.store,
            a = this._config.format,
            r = this._config.short;
          let s = this.transferUnits[i].toMinutes(e),
            o = a;
          if (
            (o && o === "auto" && (o = this._selectFormatForValue(s)),
            o || (o = "day"),
            a === "auto" && !e)
          )
            return "";
          o = Array.isArray(o) ? o : [o];
          let l = "";
          const d = o.length - 1;
          for (let c = 0; c < o.length; c++) {
            const u = o[c],
              h = this._getValueFromMinutes(s, u, c === d);
            (s -= this._getValueInMinutes(h, u)),
              (l += `${this._getLabelForConvert(h, u, r)}${
                c === d ? "" : " "
              }`);
          }
          return l;
        }),
        (this.parse = (e) => {
          if (this.canParse(e)) {
            let i = "",
              a = !1,
              r = !1,
              s = 0;
            const o = (e = (e || "").trim()).length - 1,
              l = /^[+\-0-9\. ]$/;
            for (let d = 0; d < e.length; d++) {
              const c = e[d];
              l.test(c) ? (r = a) : (a = !0),
                (r || o === d) &&
                  (r || (i += c),
                  (s += this._getNumericValue(i)),
                  (a = r = !1),
                  (i = "")),
                (i += c);
            }
            if (s) {
              const d = this._config.store;
              return Math.round(
                this.transferUnits[d].fromMinutes(Math.ceil(s))
              );
            }
          }
          return null;
        }),
        (this._getValueInMinutes = (e, i) =>
          this.transferUnits[i] && this.transferUnits[i].toMinutes
            ? this.transferUnits[i].toMinutes(e)
            : 0),
        (this._getLabelForConvert = (e, i, a) => {
          const r = this._config.labels[i];
          return a
            ? `${e}${r.short}`
            : `${e} ${e !== 1 && e !== -1 ? r.plural : r.full}`;
        }),
        (this._getValueFromMinutes = (e, i, a) => {
          if (this.transferUnits[i] && this.transferUnits[i].fromMinutes) {
            const r = this.transferUnits[i].fromMinutes(e);
            return a ? parseFloat(r.toFixed(2)) : parseInt(r.toString(), 10);
          }
          return null;
        }),
        (this._isUnitName = (e, i) => (
          (i = i.toLowerCase()),
          e.full.toLowerCase() === i ||
            e.plural.toLowerCase() === i ||
            e.short.toLowerCase() === i
        )),
        (this._getUnitName = (e) => {
          const i = this._config.labels;
          let a,
            r = !1;
          for (a in i)
            if (this._isUnitName(i[a], e)) {
              r = !0;
              break;
            }
          return r ? a : this._config.enter;
        }),
        (this._config = this._defaultSettings(n)),
        (this.transferUnits = {
          minute: { toMinutes: (e) => e, fromMinutes: (e) => e },
          hour: {
            toMinutes: (e) => e * this._config.minutesPerHour,
            fromMinutes: (e) => e / this._config.minutesPerHour,
          },
          day: {
            toMinutes: (e) =>
              e * this._config.minutesPerHour * this._config.hoursPerDay,
            fromMinutes: (e) =>
              e / (this._config.minutesPerHour * this._config.hoursPerDay),
          },
          week: {
            toMinutes: (e) =>
              e * this._config.minutesPerHour * this._config.hoursPerWeek,
            fromMinutes: (e) =>
              e / (this._config.minutesPerHour * this._config.hoursPerWeek),
          },
          month: {
            toMinutes: (e) =>
              e *
              this._config.minutesPerHour *
              this._config.hoursPerDay *
              this._config.daysPerMonth,
            fromMinutes: (e) =>
              e /
              (this._config.minutesPerHour *
                this._config.hoursPerDay *
                this._config.daysPerMonth),
          },
          year: {
            toMinutes: (e) =>
              e *
              this._config.minutesPerHour *
              this._config.hoursPerDay *
              this._config.daysPerYear,
            fromMinutes: (e) =>
              e /
              (this._config.minutesPerHour *
                this._config.hoursPerDay *
                this._config.daysPerYear),
          },
        });
    }
    _defaultSettings(n = null) {
      const e = {
        enter: "day",
        store: "hour",
        format: "auto",
        short: !1,
        minutesPerHour: 60,
        hoursPerDay: 8,
        hoursPerWeek: 40,
        daysPerMonth: 30,
        daysPerYear: 365,
        labels: {
          minute: { full: "minute", plural: "minutes", short: "min" },
          hour: { full: "hour", plural: "hours", short: "h" },
          day: { full: "day", plural: "days", short: "d" },
          week: { full: "week", plural: "weeks", short: "wk" },
          month: { full: "month", plural: "months", short: "mon" },
          year: { full: "year", plural: "years", short: "y" },
        },
      };
      if (n) {
        for (const i in n) n[i] !== void 0 && i !== "labels" && (e[i] = n[i]);
        if (n.labels) for (const i in n.labels) e.labels[i] = n.labels[i];
      }
      return e;
    }
    _selectFormatForValue(n) {
      const e = ["year", "month", "day", "hour", "minute"],
        i = [];
      for (let a = 0; a < e.length; a++)
        i[a] = Math.abs(this.transferUnits[e[a]].fromMinutes(n));
      for (let a = 0; a < i.length; a++)
        if (!(i[a] < 1 && a < i.length - 1)) return e[a];
      return "day";
    }
    _getNumericValue(n) {
      const e = parseFloat(n.replace(/ /g, "")) || 0,
        i = n.match(new RegExp("\\p{L}", "gu"))
          ? n.match(new RegExp("\\p{L}", "gu")).join("")
          : "",
        a = this._getUnitName(i);
      return e && a ? this._getValueInMinutes(e, a) : 0;
    }
  };
  ce.create = (n = null) => new ce(n);
  let Me = ce;
  const ue = class ue {
    constructor(n) {
      (this.format = (e) => this._getWBSCode(e.source)),
        (this.canParse = (e) => this._linkReg.test(e)),
        (this.parse = (e) => {
          if (!this.canParse(e)) return null;
          const i = this._linkReg.exec(e)[0].trim();
          return {
            id: void 0,
            source: this._findSource(i) || null,
            target: null,
            type: this._gantt.config.links.finish_to_start,
            lag: 0,
          };
        }),
        (this._getWBSCode = (e) => {
          const i = this._gantt.getTask(e);
          return this._gantt.getWBSCode(i);
        }),
        (this._findSource = (e) => {
          const i = new RegExp("^[0-9.]+", "i");
          if (i.exec(e)) {
            const a = i.exec(e)[0],
              r = this._gantt.getTaskByWBSCode(a);
            if (r) return r.id;
          }
          return null;
        }),
        (this._linkReg = /^[0-9\.]+/),
        (this._gantt = n);
    }
  };
  ue.create = (n = null, e) => new ue(e);
  let Ie = ue;
  const he = class he extends Ie {
    constructor(n, e) {
      super(e),
        (this.format = (i) => {
          const a = this._getFormattedLinkType(this._getLinkTypeName(i.type)),
            r = this._getWBSCode(i.source),
            s = this._getLagString(i.lag);
          return i.type !== this._gantt.config.links.finish_to_start || i.lag
            ? `${r}${a}${s}`
            : r;
        }),
        (this.parse = (i) => {
          if (!this.canParse(i)) return null;
          const a = this._linkReg.exec(i)[0].trim(),
            r = i.replace(a, "").trim(),
            s = this._findTypeFormat(a),
            o = this._getLinkTypeNumber(s);
          return {
            id: void 0,
            source: this._findSource(a) || null,
            target: null,
            type: o,
            lag: this._parseLag(r),
          };
        }),
        (this._getLinkTypeName = (i) => {
          let a = "";
          for (a in this._config.labels)
            if (
              String(this._gantt.config.links[a]).toLowerCase() ===
              String(i).toLowerCase()
            )
              break;
          return a;
        }),
        (this._getLinkTypeNumber = (i) => {
          let a = "";
          for (a in this._gantt.config.links)
            if (a.toLowerCase() === i.toLowerCase()) break;
          return this._gantt.config.links[a];
        }),
        (this._getFormattedLinkType = (i) => this._config.labels[i] || ""),
        (this._getLagString = (i) => {
          if (!i) return "";
          const a = this._config.durationFormatter.format(i);
          return i < 0 ? a : `+${a}`;
        }),
        (this._findTypeFormat = (i) => {
          const a = i.replace(/[^a-zA-Z]/gi, "");
          let r = "finish_to_start";
          for (const s in this._config.labels)
            this._config.labels[s].toLowerCase() === a.toLowerCase() && (r = s);
          return r;
        }),
        (this._parseLag = (i) =>
          i ? this._config.durationFormatter.parse(i) : 0),
        (this._config = this._defaultSettings(n)),
        (this._linkReg = /^[0-9\.]+[a-zA-Z]*/);
    }
    _defaultSettings(n = null) {
      const e = {
        durationFormatter: this._gantt.ext.formatters.durationFormatter(),
        labels: {
          finish_to_finish: "FF",
          finish_to_start: "FS",
          start_to_start: "SS",
          start_to_finish: "SF",
        },
      };
      if (
        (n &&
          n.durationFormatter &&
          (e.durationFormatter = n.durationFormatter),
        n && n.labels)
      )
        for (const i in n.labels) e.labels[i] = n.labels[i];
      return e;
    }
  };
  he.create = (n = null, e) => new he(n, e);
  let Le = he;
  function Fi(t) {
    t.ext.formatters = {
      durationFormatter: function (n) {
        return (
          n || (n = {}),
          n.store || (n.store = t.config.duration_unit),
          n.enter || (n.enter = t.config.duration_unit),
          Me.create(n, t)
        );
      },
      linkFormatter: function (n) {
        return Le.create(n, t);
      },
    };
  }
  function Wi(t) {
    (t.ext = t.ext || {}),
      (t.config.show_empty_state = !1),
      (t.ext.emptyStateElement = t.ext.emptyStateElement || {
        isEnabled: () => t.config.show_empty_state === !0,
        isGanttEmpty: () => !t.getTaskByTime().length,
        renderContent(n) {
          const e = `<div class='gantt_empty_state'><div class='gantt_empty_state_image'></div>${`<div class='gantt_empty_state_text'>
    <div class='gantt_empty_state_text_link' data-empty-state-create-task>${t.locale.labels.empty_state_text_link}</div>
    <div class='gantt_empty_state_text_description'>${t.locale.labels.empty_state_text_description}</div>
    </div>`}</div>`;
          n.innerHTML = e;
        },
        clickEvents: [],
        attachAddTaskEvent() {
          const n = t.attachEvent("onEmptyClick", function (e) {
            t.utils.dom.closest(e.target, "[data-empty-state-create-task]") &&
              t.createTask({ id: t.uid(), text: "New Task" });
          });
          this.clickEvents.push(n);
        },
        detachAddTaskEvents() {
          this.clickEvents.forEach(function (n) {
            t.detachEvent(n);
          }),
            (this.clickEvents = []);
        },
        getContainer() {
          if (t.$container) {
            const n = t.utils.dom;
            if (t.$container.contains(t.$grid_data))
              return n.closest(t.$grid_data, ".gantt_layout_content");
            if (t.$container.contains(t.$task_data))
              return n.closest(t.$task_data, ".gantt_layout_content");
          }
          return null;
        },
        getNode() {
          const n = this.getContainer();
          return n ? n.querySelector(".gantt_empty_state_wrapper") : null;
        },
        show() {
          const n = this.getContainer();
          if (!n && this.isGanttEmpty()) return null;
          const e = document.createElement("div");
          (e.className = "gantt_empty_state_wrapper"),
            (e.style.marginTop = t.config.scale_height - n.offsetHeight + "px");
          const i = t.$container.querySelectorAll(".gantt_empty_state_wrapper");
          Array.prototype.forEach.call(i, function (a) {
            a.parentNode.removeChild(a);
          }),
            this.detachAddTaskEvents(),
            this.attachAddTaskEvent(),
            n.appendChild(e),
            this.renderContent(e);
        },
        hide() {
          const n = this.getNode();
          if (!n) return !1;
          n.parentNode.removeChild(n);
        },
        init() {},
      }),
      t.attachEvent("onDataRender", function () {
        const n = t.ext.emptyStateElement;
        n.isEnabled() && n.isGanttEmpty() ? n.show() : n.hide();
      });
  }
  const Ne = function (t, n) {
      const e = n.baselines && n.baselines.length,
        i =
          t.config.baselines.render_mode == "separateRow" ||
          t.config.baselines.render_mode == "individualRow";
      if (e && i) return !0;
    },
    Ft = function (t, n) {
      let e = !1;
      return (
        t.eachTask(function (i) {
          e || (e = Ne(t, i));
        }, n),
        e
      );
    },
    ft = function (t) {
      return t.render && t.render == "split" && !t.$open;
    },
    ee = function (t, n, e, i) {
      let a = i || n.$task_data.scrollHeight,
        r = !1,
        s = !1;
      return (
        t.eachParent(function (o) {
          if (ft(o)) {
            s = !0;
            const l = n.getItemPosition(o).rowHeight;
            l < a && ((a = l), (r = !0));
          }
        }, e.id),
        { maxHeight: a, shrinkHeight: r, splitChild: s }
      );
    },
    Mn = function (t) {
      return Math.sqrt(2 * t * t);
    },
    In = function (t) {
      return Math.round(t / Math.sqrt(2));
    },
    Ln = function (t, n, e, i, a, r) {
      const s = Ne(t, a),
        o = ee(t, n, a);
      let l = o.maxHeight,
        d = e.height,
        c = d > i,
        u = e.rowHeight >= i && !o.splitChild && !s;
      (c || u) && (d = i), l < d && (d = l);
      let h = Math.floor((e.rowHeight - d) / 2);
      if ((o.splitChild && (h = Math.floor((l - d) / 2)), r || s)) {
        let _ = Math.min(e.height, l) - d,
          f = 2,
          y = s && a.bar_height >= a.row_height,
          v = o.splitChild && e.height >= l;
        (y || v) && (f = 0), (h = Math.floor(_ / 2) + f), e.rowHeight;
      }
      return { height: d, marginTop: h };
    };
  function Vi(t) {
    t.config.baselines = {
      datastore: "baselines",
      render_mode: !1,
      dataprocessor_baselines: !1,
      row_height: 16,
      bar_height: 8,
    };
    const n = t.createDatastore({
      name: t.config.baselines.datastore,
      initItem: function (a) {
        return (
          a.id || (a.id = t.uid()),
          (function (r) {
            if (!r.task_id || (!r.start_date && !r.end_date)) return !1;
            r.start_date
              ? (r.start_date = t.date.parseDate(r.start_date, "parse_date"))
              : (r.start_date = null),
              r.end_date
                ? (r.end_date = t.date.parseDate(r.end_date, "parse_date"))
                : (r.end_date = null),
              (r.duration = r.duration || 1),
              r.start_date && !r.end_date
                ? (r.end_date = t.calculateEndDate(r.start_date, r.duration))
                : r.end_date &&
                  !r.start_date &&
                  (r.start_date = t.calculateEndDate(r.end_date, -r.duration));
          })(a),
          a
        );
      },
    });
    function e(a) {
      let r = 0;
      t.adjustTaskHeightForBaselines(a),
        t.eachTask(function (s) {
          let o = s.row_height || t.config.row_height;
          (r = r || o), o > r && (r = o);
        }, a.id),
        a.row_height < r && (a.row_height = r);
    }
    function i(a) {
      t.eachParent(function (r) {
        if (ft(r)) {
          const s =
            r.row_height || t.getLayoutView("timeline").getBarHeight(r.id);
          let o = a.row_height;
          t.getChildren(r.id).forEach(function (l) {
            const d = t.getTask(l);
            if (d.id == a.id) return;
            const c =
              d.row_height || t.getLayoutView("timeline").getBarHeight(d.id);
            (o = o || c), c > o && (o = c);
          }),
            (r.row_height = o),
            (r.bar_height = r.bar_height || s);
        }
      }, a.id);
    }
    (t.$data.baselineStore = n),
      (t.adjustTaskHeightForBaselines = function (a) {
        let r,
          s,
          o = (a.baselines && a.baselines.length) || 0;
        const l = t.config.baselines.row_height,
          d = t.getLayoutView("timeline");
        if (d && t.config.show_chart)
          switch (t.config.baselines.render_mode) {
            case "taskRow":
            default:
              a.row_height = a.bar_height + 8;
              break;
            case "separateRow":
              (r = d.getBarHeight(a.id)),
                o
                  ? ((a.bar_height = a.bar_height || r),
                    a.bar_height > r && (r = a.bar_height),
                    (a.row_height = r + l))
                  : a.bar_height && (a.row_height = a.bar_height + 4),
                i(a);
              break;
            case "individualRow":
              (r = d.getBarHeight(a.id)),
                o
                  ? ((a.bar_height = a.bar_height || r),
                    a.bar_height > r && (r = a.bar_height),
                    (s = l * o),
                    (a.row_height = r + s + 2))
                  : a.bar_height && (a.row_height = a.bar_height + 4),
                i(a);
          }
      }),
      t.attachEvent(
        "onGanttReady",
        function () {
          t.config.baselines &&
            (t.attachEvent("onParse", function () {
              n.eachItem(function (a) {
                const r = a.task_id;
                if (t.isTaskExists(r)) {
                  const s = t.getTask(r);
                  s.baselines = s.baselines || [];
                  let o = !0;
                  for (let l = 0; l < s.baselines.length; l++) {
                    let d = s.baselines[l];
                    if (d.id == a.id) {
                      (o = !1), t.mixin(d, a, !0);
                      break;
                    }
                  }
                  o && s.baselines.push(a),
                    K(t) || (ft(s) ? e(s) : t.adjustTaskHeightForBaselines(s));
                }
              });
            }),
            t.attachEvent("onBeforeTaskUpdate", function (a, r) {
              return (
                (function (s) {
                  let o = !1;
                  const l = {},
                    d = s.baselines || [],
                    c = t.getTaskBaselines(s.id);
                  d.length != c.length && (o = !0),
                    d.forEach(function (u) {
                      l[u.id] = !0;
                      const h = n.getItem(u.id);
                      if (h) {
                        const _ = +h.start_date != +u.start_date,
                          f = +h.end_date != +u.end_date;
                        (_ || f) && n.updateItem(u.id, u);
                      } else n.addItem(u);
                    }),
                    c.forEach(function (u) {
                      l[u.id] || n.removeItem(u.id);
                    }),
                    o &&
                      (ft(s) ? e(s) : t.adjustTaskHeightForBaselines(s),
                      t.render());
                })(r),
                !0
              );
            }),
            t.attachEvent("onAfterUndo", function (a) {
              if (
                (t.config.baselines.render_mode == "separateRow" ||
                  t.config.baselines.render_mode == "individualRow") &&
                a
              ) {
                let r = !1;
                a.commands.forEach(function (s) {
                  if (s.entity == "task") {
                    const o = s.value.id;
                    if (t.isTaskExists(o)) {
                      const l = t.getTask(o);
                      if (l.parent && t.isTaskExists(l.parent)) {
                        const d = t.getTask(l.parent);
                        ft(d) && (e(d), (r = !0));
                      }
                    }
                  }
                }),
                  r && t.render();
              }
            }),
            t.attachEvent("onAfterTaskDelete", function (a, r) {
              if (Ne && r.parent && t.isTaskExists(r.parent)) {
                const s = t.getTask(r.parent);
                ft(s) && e(s);
              }
              n.eachItem(function (s) {
                t.isTaskExists(s.task_id) || n.removeItem(s.id);
              });
            }),
            (t.getTaskBaselines = function (a) {
              const r = [];
              return (
                n.eachItem(function (s) {
                  s.task_id == a && r.push(s);
                }),
                r
              );
            }),
            t.$data.baselineStore.attachEvent("onClearAll", function () {
              return (
                t.eachTask(function (a) {
                  a.baselines && delete a.baselines;
                }),
                !0
              );
            }),
            t.$data.tasksStore.attachEvent("onClearAll", function () {
              return n.clearAll(), !0;
            }),
            t.attachEvent("onTaskIdChange", function (a, r) {
              n.find(function (s) {
                return s.task_id == a;
              }).forEach(function (s) {
                (s.task_id = r), n.updateItem(s.id);
              });
            }));
        },
        { once: !0 }
      );
  }
  function Nn(t) {
    var n = {},
      e = {},
      i = null,
      a = -1,
      r = null,
      s = (function (o) {
        var l = -1,
          d = -1;
        return {
          resetCache: function () {
            (l = -1), (d = -1);
          },
          _getRowHeight: function () {
            return l === -1 && (l = o.$getConfig().row_height), l;
          },
          _refreshState: function () {
            this.resetCache(), (d = !0);
            var c = o.$config.rowStore;
            if (c)
              for (
                var u = this._getRowHeight(), h = 0;
                h < c.fullOrder.length;
                h++
              ) {
                var _ = c.getItem(c.fullOrder[h]);
                if (_ && _.row_height && _.row_height !== u) {
                  d = !1;
                  break;
                }
              }
          },
          canUseSimpleCalculation: function () {
            return d === -1 && this._refreshState(), d;
          },
          getRowTop: function (c) {
            return o.$config.rowStore ? c * this._getRowHeight() : 0;
          },
          getItemHeight: function (c) {
            return this._getRowHeight();
          },
          getTotalHeight: function () {
            return o.$config.rowStore
              ? o.$config.rowStore.countVisible() * this._getRowHeight()
              : 0;
          },
          getItemIndexByTopPosition: function (c) {
            return o.$config.rowStore
              ? Math.floor(c / this._getRowHeight())
              : 0;
          },
        };
      })(t);
    return {
      _resetTopPositionHeight: function () {
        (n = {}), (e = {}), s.resetCache();
      },
      _resetHeight: function () {
        var o = this.$config.rowStore,
          l = this.getCacheStateTotalHeight(o);
        r
          ? this.shouldClearHeightCache(r, l) && ((r = l), (i = null))
          : (r = l),
          (a = -1),
          s.resetCache();
      },
      getRowTop: function (o) {
        if (s.canUseSimpleCalculation()) return s.getRowTop(o);
        var l = this.$config.rowStore;
        if (!l) return 0;
        if (e[o] !== void 0) return e[o];
        for (var d = l.getIndexRange(), c = 0, u = 0, h = 0; h < d.length; h++)
          (e[h] = c), (c += this.getItemHeight(d[h].id)), h < o && (u = c);
        return u;
      },
      getItemTop: function (o) {
        if (this.$config.rowStore) {
          if (n[o] !== void 0) return n[o];
          var l = this.$config.rowStore;
          if (!l) return 0;
          var d = l.getIndexById(o);
          if (d === -1 && l.getParent && l.exists(o)) {
            var c = l.getParent(o);
            if (l.exists(c)) {
              var u = l.getItem(c);
              if (this.$gantt.isSplitTask(u)) return this.getItemTop(c);
            }
          }
          return (n[o] = this.getRowTop(d)), n[o];
        }
        return 0;
      },
      getItemHeight: function (o) {
        if (s.canUseSimpleCalculation()) return s.getItemHeight(o);
        if (
          (!i &&
            this.$config.rowStore &&
            this._fillHeightCache(this.$config.rowStore),
          i[o] !== void 0)
        )
          return i[o];
        var l = this.$getConfig().row_height;
        if (this.$config.rowStore) {
          var d = this.$config.rowStore;
          if (!d) return l;
          var c = d.getItem(o);
          return (i[o] = (c && c.row_height) || l);
        }
        return l;
      },
      _fillHeightCache: function (o) {
        if (o) {
          i = {};
          var l = this.$getConfig().row_height;
          o.eachItem(function (d) {
            return (i[d.id] = (d && d.row_height) || l);
          });
        }
      },
      getCacheStateTotalHeight: function (o) {
        var l = this.$getConfig().row_height,
          d = {},
          c = [],
          u = 0;
        return (
          o &&
            o.eachItem(function (h) {
              c.push(h), (d[h.id] = h.row_height), (u += h.row_height || l);
            }),
          { globalHeight: l, items: c, count: c.length, sumHeight: u }
        );
      },
      shouldClearHeightCache: function (o, l) {
        if (
          o.count != l.count ||
          o.globalHeight != l.globalHeight ||
          o.sumHeight != l.sumHeight
        )
          return !0;
        for (var d in o.items) {
          var c = l.items[d];
          if (c !== void 0 && c != o.items[d]) return !0;
        }
        return !1;
      },
      getTotalHeight: function () {
        if (s.canUseSimpleCalculation()) return s.getTotalHeight();
        if (a != -1) return a;
        if (this.$config.rowStore) {
          var o = this.$config.rowStore;
          this._fillHeightCache(o);
          var l = this.getItemHeight.bind(this),
            d = o.getVisibleItems(),
            c = 0;
          return (
            d.forEach(function (u) {
              c += l(u.id);
            }),
            (a = c),
            c
          );
        }
        return 0;
      },
      getItemIndexByTopPosition: function (o) {
        if (this.$config.rowStore) {
          if (s.canUseSimpleCalculation())
            return s.getItemIndexByTopPosition(o);
          for (
            var l = this.$config.rowStore, d = 0;
            d < l.countVisible();
            d++
          ) {
            var c = this.getRowTop(d),
              u = this.getRowTop(d + 1);
            if (!u) {
              var h = l.getIdByIndex(d);
              u = c + this.getItemHeight(h);
            }
            if (o >= c && o < u) return d;
          }
          return l.countVisible() + 2;
        }
        return 0;
      },
    };
  }
  class Ui {
    constructor(n) {
      this._scrollOrder = 0;
      const { gantt: e, grid: i, dnd: a, getCurrentX: r } = n;
      (this.$gantt = e),
        (this.$grid = i),
        (this._dnd = a),
        (this.getCurrentX = r),
        (this._scrollView = this.$gantt.$ui.getView(
          this.$grid.$config.scrollX
        )),
        this.attachEvents();
    }
    attachEvents() {
      this.isScrollable() &&
        (this._dnd.attachEvent("onDragMove", (n, e) => {
          const i = this.$grid.$grid.getBoundingClientRect(),
            a = i.right,
            r = i.left,
            s = this.getCurrentX(e.clientX);
          return (
            s >= a - 20 && (this.autoscrollRight(), this.autoscrollStart()),
            s <= r + 20 && (this.autoscrollLeft(), this.autoscrollStart()),
            s < a - 20 && s > r + 20 && this.autoscrollStop(),
            !0
          );
        }),
        this._dnd.attachEvent("onDragEnd", () => {
          this.autoscrollStop();
        }));
    }
    autoscrollStart() {
      if (this._scrollOrder === 0) return;
      const n = 10 * this._scrollOrder,
        e = this._scrollView.getScrollState();
      this._scrollView.scrollTo(e.position + n),
        setTimeout(() => {
          this.autoscrollStart();
        }, 50);
    }
    autoscrollRight() {
      this._scrollOrder = 1;
    }
    autoscrollLeft() {
      this._scrollOrder = -1;
    }
    autoscrollStop() {
      this._scrollOrder = 0;
    }
    getCorrection() {
      return this.isScrollable()
        ? this._scrollView.getScrollState().position
        : 0;
    }
    isScrollable() {
      return !!this.$grid.$config.scrollable;
    }
  }
  const Pn = "data-column-id";
  class Gi {
    constructor(n, e) {
      (this._targetMarker = null),
        (this.calculateCurrentPosition = (i) => {
          const a = this.$grid.$grid.getBoundingClientRect(),
            r = a.right,
            s = a.left;
          let o = i;
          return o > r && (o = r), o < s && (o = s), o;
        }),
        (this.$gantt = n),
        (this.$grid = e);
    }
    init() {
      const n = this.$gantt.$services.getService("dnd");
      (this._dnd = new n(this.$grid.$grid_scale, { updates_per_second: 60 })),
        (this._scrollableGrid = new Ui({
          gantt: this.$gantt,
          grid: this.$grid,
          dnd: this._dnd,
          getCurrentX: this.calculateCurrentPosition,
        })),
        this.attachEvents();
    }
    attachEvents() {
      this._dnd.attachEvent("onBeforeDragStart", (n, e) => {
        if (
          ((this._draggedCell = this.$gantt.utils.dom.closest(
            e.target,
            ".gantt_grid_head_cell"
          )),
          !this._draggedCell)
        )
          return;
        const i = this.$grid.$getConfig().columns,
          a = this._draggedCell.getAttribute(Pn);
        let r, s;
        return (
          i.map(function (o, l) {
            o.name === a && ((r = o), (s = l));
          }),
          this.$grid.callEvent("onBeforeColumnDragStart", [
            { draggedColumn: r, draggedIndex: s },
          ]) !== !1 &&
            !(!this._draggedCell || !r) &&
            ((this._gridConfig = this.$grid.$getConfig()),
            (this._originAutoscroll = this.$gantt.config.autoscroll),
            (this.$gantt.config.autoscroll = !1),
            !0)
        );
      }),
        this._dnd.attachEvent("onAfterDragStart", (n, e) => {
          this._draggedCell &&
            ((this._dnd.config.column = this._draggedCell.getAttribute(Pn)),
            (this._dnd.config.marker.innerHTML = this._draggedCell.outerHTML),
            this._dnd.config.marker.classList.add("gantt_column_drag_marker"),
            (this._dnd.config.marker.style.height =
              this._gridConfig.scale_height + "px"),
            (this._dnd.config.marker.style.lineHeight =
              this._gridConfig.scale_height + "px"),
            this._draggedCell.classList.add("gantt_grid_head_cell_dragged"));
        }),
        this._dnd.attachEvent("onDragMove", (n, e) => {
          if (!this._draggedCell) return;
          this._dragX = e.clientX;
          const i = this.calculateCurrentPosition(e.clientX),
            a = this.findColumnsIndexes();
          return this.setMarkerPosition(i), this.drawTargetMarker(a), !0;
        }),
        this._dnd.attachEvent("onDragEnd", () => {
          if (!this._draggedCell) return;
          const n = this.findColumnsIndexes(),
            e = n.targetIndex,
            i = n.draggedIndex,
            a = this.$grid.$getConfig().columns,
            r = a[i],
            s = a[e];
          if (
            this.$grid.callEvent("onColumnDragMove", [
              {
                draggedColumn: r,
                targetColumn: s,
                draggedIndex: i,
                targetIndex: e,
              },
            ]) === !1
          )
            return this.cleanTargetMarker(), void this.$gantt.render();
          (this.$gantt.config.autoscroll = this._originAutoscroll),
            this._draggedCell.classList.remove("gantt_grid_head_cell_dragged"),
            this.cleanTargetMarker(),
            this.reorderColumns();
        });
    }
    reorderColumns() {
      const { targetIndex: n, draggedIndex: e } = this.findColumnsIndexes(),
        i = this.$grid.$getConfig().columns,
        a = i[e],
        r = i[n];
      this.$grid.callEvent("onBeforeColumnReorder", [
        { draggedColumn: a, targetColumn: r, draggedIndex: e, targetIndex: n },
      ]) !== !1 &&
        n !== e &&
        (i.splice(e, 1),
        i.splice(n, 0, a),
        this.$gantt.render(),
        this.$grid.callEvent("onAfterColumnReorder", [
          {
            draggedColumn: a,
            targetColumn: r,
            draggedIndex: e,
            targetIndex: n,
          },
        ]));
    }
    findColumnsIndexes() {
      const n = this._dnd.config.column,
        e = this.$grid.$getConfig().columns;
      let i, a, r, s;
      const o = { startX: 0, endX: 0 };
      let l,
        d = 0,
        c = e.length - 1,
        u = (f, y) => f <= y,
        h = (f) => ++f;
      this.$gantt.config.rtl &&
        ((d = e.length - 1), (c = 0), (u = (f, y) => f >= y), (h = (f) => --f));
      const _ =
        this._dragX -
        this.$grid.$grid.getBoundingClientRect().left +
        this._scrollableGrid.getCorrection();
      for (let f = d; u(f, c) && (i === void 0 || a === void 0); f = h(f))
        e[f].hide ||
          ((o.startX = o.endX),
          (o.endX += e[f].width),
          _ >= o.startX &&
            (_ <= o.endX || !u(h(f), c)) &&
            ((i = f),
            (r = o.startX),
            (s = o.endX),
            (l = (_ - o.startX) / (o.endX - o.startX))),
          n === e[f].name && (a = f));
      return {
        targetIndex: i,
        draggedIndex: a,
        xBefore: r,
        xAfter: s,
        columnRelativePos: l,
      };
    }
    setMarkerPosition(n, e = 10) {
      const { marker: i } = this._dnd.config,
        a = this._dnd._obj.getBoundingClientRect();
      (i.style.top = `${a.y + e}px`), (i.style.left = `${n}px`);
    }
    drawTargetMarker({
      targetIndex: n,
      draggedIndex: e,
      xBefore: i,
      xAfter: a,
      columnRelativePos: r,
    }) {
      let s;
      this._targetMarker ||
        ((this._targetMarker = document.createElement("div")),
        $t(this._targetMarker, "gantt_grid_target_marker"),
        (this._targetMarker.style.display = "none"),
        (this._targetMarker.style.height = `${this._gridConfig.scale_height}px`)),
        this._targetMarker.parentNode ||
          this.$grid.$grid_scale.appendChild(this._targetMarker),
        (s = n > e ? a : n < e ? i : r > 0.5 ? a : i),
        (this._targetMarker.style.left = `${s}px`),
        (this._targetMarker.style.display = "block");
    }
    cleanTargetMarker() {
      this._targetMarker &&
        this._targetMarker.parentNode &&
        this.$grid.$grid_scale.removeChild(this._targetMarker),
        (this._targetMarker = null);
    }
  }
  function Pe(t) {
    var n = [];
    return {
      delegate: function (e, i, a, r) {
        n.push([e, i, a, r]),
          t.$services.getService("mouseEvents").delegate(e, i, a, r);
      },
      destructor: function () {
        for (
          var e = t.$services.getService("mouseEvents"), i = 0;
          i < n.length;
          i++
        ) {
          var a = n[i];
          e.detach(a[0], a[1], a[2], a[3]);
        }
        n = [];
      },
    };
  }
  var ne = function (t, n, e, i) {
    (this.$config = O({}, n || {})),
      (this.$gantt = i),
      (this.$parent = t),
      ct(this),
      (this.$state = {}),
      O(this, Nn(this));
  };
  function qi(t) {
    function n(e) {
      throw (
        (t.assert(
          !1,
          "Can't parse data: incorrect value of gantt.parse or gantt.load method. Actual argument value: " +
            JSON.stringify(e)
        ),
        new Error(
          "Invalid argument for gantt.parse or gantt.load. An object or a JSON string of format https://docs.dhtmlx.com/gantt/desktop__supported_data_formats.html#json is expected. Actual argument value: " +
            JSON.stringify(e)
        ))
      );
    }
    (t.load = function () {
      throw new Error(
        "gantt.load() method is not available in the node.js, use gantt.parse() instead"
      );
    }),
      (t.parse = function (e, i) {
        this.on_load({ xmlDoc: { responseText: e } }, i);
      }),
      (t.serialize = function (e) {
        return this[(e = e || "json")].serialize();
      }),
      (t.on_load = function (e, i) {
        if (e.xmlDoc && e.xmlDoc.status === 404)
          this.assert(
            !1,
            "Failed to load the data from <a href='" +
              e.xmlDoc.responseURL +
              "' target='_blank'>" +
              e.xmlDoc.responseURL +
              "</a>, server returns 404"
          );
        else if (!t.$destroyed) {
          this.callEvent("onBeforeParse", []),
            i || (i = "json"),
            this.assert(this[i], "Invalid data type:'" + i + "'");
          var a = e.xmlDoc.responseText,
            r = this[i].parse(a, e);
          this._process_loading(r);
        }
      }),
      (t._process_loading = function (e) {
        e.collections && this._load_collections(e.collections),
          e.resources &&
            this.$data.resourcesStore &&
            this.$data.resourcesStore.parse(e.resources),
          t.config.baselines &&
            e.baselines &&
            this.$data.baselineStore &&
            this.$data.baselineStore.parse(e.baselines);
        const i = e.data || e.tasks;
        e.assignments &&
          (function (r, s) {
            const o = {};
            s.forEach((l) => {
              o[l.task_id] || (o[l.task_id] = []), o[l.task_id].push(l);
            }),
              r.forEach((l) => {
                l[t.config.resource_property] = o[l.id] || [];
              });
          })(i, e.assignments),
          this.$data.tasksStore.parse(i);
        var a =
          e.links ||
          (e.collections && e.collections.links ? e.collections.links : []);
        this.$data.linksStore.parse(a),
          this.callEvent("onParse", []),
          this.render();
      }),
      (t._load_collections = function (e) {
        var i = !1;
        for (var a in e)
          if (e.hasOwnProperty(a)) {
            i = !0;
            var r = e[a];
            this.serverList[a] = this.serverList[a] || [];
            var s = this.serverList[a];
            if (!s) continue;
            s.splice(0, s.length);
            for (var o = 0; o < r.length; o++) {
              var l = r[o],
                d = this.copy(l);
              for (var c in ((d.key = d.value), l))
                if (l.hasOwnProperty(c)) {
                  if (c == "value" || c == "label") continue;
                  d[c] = l[c];
                }
              s.push(d);
            }
          }
        i && this.callEvent("onOptionsLoad", []);
      }),
      t.attachEvent("onBeforeTaskDisplay", function (e, i) {
        return !i.$ignore;
      }),
      (t.json = {
        parse: function (e) {
          if ((e || n(e), typeof e == "string"))
            if (typeof JSON != null)
              try {
                e = JSON.parse(e);
              } catch {
                n(e);
              }
            else t.assert(!1, "JSON is not supported");
          return (
            e.data || e.tasks || n(e),
            e.dhx_security && (t.security_key = e.dhx_security),
            e
          );
        },
        serializeTask: function (e) {
          return this._copyObject(e);
        },
        serializeLink: function (e) {
          return this._copyLink(e);
        },
        _copyLink: function (e) {
          var i = {};
          for (var a in e) i[a] = e[a];
          return i;
        },
        _copyObject: function (e) {
          var i = {};
          for (var a in e)
            a.charAt(0) != "$" &&
              ((i[a] = e[a]),
              nt(i[a]) &&
                (i[a] = t.defined(t.templates.xml_format)
                  ? t.templates.xml_format(i[a])
                  : t.templates.format_date(i[a])));
          return i;
        },
        serialize: function () {
          var e = [],
            i = [];
          let a = [];
          t.eachTask(
            function (o) {
              t.resetProjectDates(o), e.push(this.serializeTask(o));
            },
            t.config.root_id,
            this
          );
          for (var r = t.getLinks(), s = 0; s < r.length; s++)
            i.push(this.serializeLink(r[s]));
          return (
            t.getDatastore("baselines").eachItem(function (o) {
              const l = t.json.serializeTask(o);
              a.push(l);
            }),
            { data: e, links: i, baselines: a }
          );
        },
      }),
      (t.xml = {
        _xmlNodeToJSON: function (e, i) {
          for (var a = {}, r = 0; r < e.attributes.length; r++)
            a[e.attributes[r].name] = e.attributes[r].value;
          if (!i) {
            for (r = 0; r < e.childNodes.length; r++) {
              var s = e.childNodes[r];
              s.nodeType == 1 &&
                (a[s.tagName] = s.firstChild ? s.firstChild.nodeValue : "");
            }
            a.text || (a.text = e.firstChild ? e.firstChild.nodeValue : "");
          }
          return a;
        },
        _getCollections: function (e) {
          for (
            var i = {}, a = t.ajax.xpath("//coll_options", e), r = 0;
            r < a.length;
            r++
          )
            for (
              var s = (i[a[r].getAttribute("for")] = []),
                o = t.ajax.xpath(".//item", a[r]),
                l = 0;
              l < o.length;
              l++
            ) {
              for (
                var d = o[l].attributes,
                  c = {
                    key: o[l].getAttribute("value"),
                    label: o[l].getAttribute("label"),
                  },
                  u = 0;
                u < d.length;
                u++
              ) {
                var h = d[u];
                h.nodeName != "value" &&
                  h.nodeName != "label" &&
                  (c[h.nodeName] = h.nodeValue);
              }
              s.push(c);
            }
          return i;
        },
        _getXML: function (e, i, a) {
          (a = a || "data"), i.getXMLTopNode || (i = t.ajax.parse(i));
          var r = t.ajax.xmltop(a, i.xmlDoc);
          (r && r.tagName == a) ||
            (function (o) {
              throw (
                (t.assert(
                  !1,
                  "Can't parse data: incorrect value of gantt.parse or gantt.load method. Actual argument value: " +
                    JSON.stringify(o)
                ),
                new Error(
                  "Invalid argument for gantt.parse or gantt.load. An XML of format https://docs.dhtmlx.com/gantt/desktop__supported_data_formats.html#xmldhtmlxgantt20 is expected. Actual argument value: " +
                    JSON.stringify(o)
                ))
              );
            })(e);
          var s = r.getAttribute("dhx_security");
          return s && (t.security_key = s), r;
        },
        parse: function (e, i) {
          i = this._getXML(e, i);
          for (
            var a = {}, r = (a.data = []), s = t.ajax.xpath("//task", i), o = 0;
            o < s.length;
            o++
          )
            r[o] = this._xmlNodeToJSON(s[o]);
          return (a.collections = this._getCollections(i)), a;
        },
        _copyLink: function (e) {
          return (
            "<item id='" +
            e.id +
            "' source='" +
            e.source +
            "' target='" +
            e.target +
            "' type='" +
            e.type +
            "' />"
          );
        },
        _copyObject: function (e) {
          return (
            "<task id='" +
            e.id +
            "' parent='" +
            (e.parent || "") +
            "' start_date='" +
            e.start_date +
            "' duration='" +
            e.duration +
            "' open='" +
            !!e.open +
            "' progress='" +
            e.progress +
            "' end_date='" +
            e.end_date +
            "'><![CDATA[" +
            e.text +
            "]]></task>"
          );
        },
        serialize: function () {
          for (
            var e = [],
              i = [],
              a = t.json.serialize(),
              r = 0,
              s = a.data.length;
            r < s;
            r++
          )
            e.push(this._copyObject(a.data[r]));
          for (r = 0, s = a.links.length; r < s; r++)
            i.push(this._copyLink(a.links[r]));
          return (
            "<data>" +
            e.join("") +
            "<coll_options for='links'>" +
            i.join("") +
            "</coll_options></data>"
          );
        },
      }),
      (t.oldxml = {
        parse: function (e, i) {
          i = t.xml._getXML(e, i, "projects");
          for (
            var a = { collections: { links: [] } },
              r = (a.data = []),
              s = t.ajax.xpath("//task", i),
              o = 0;
            o < s.length;
            o++
          ) {
            r[o] = t.xml._xmlNodeToJSON(s[o]);
            var l = s[o].parentNode;
            l.tagName == "project"
              ? (r[o].parent = "project-" + l.getAttribute("id"))
              : (r[o].parent = l.parentNode.getAttribute("id"));
          }
          for (s = t.ajax.xpath("//project", i), o = 0; o < s.length; o++)
            ((d = t.xml._xmlNodeToJSON(s[o], !0)).id = "project-" + d.id),
              r.push(d);
          for (o = 0; o < r.length; o++) {
            var d;
            ((d = r[o]).start_date = d.startdate || d.est),
              (d.end_date = d.enddate),
              (d.text = d.name),
              (d.duration = d.duration / 8),
              (d.open = 1),
              d.duration || d.end_date || (d.duration = 1),
              d.predecessortasks &&
                a.collections.links.push({
                  target: d.id,
                  source: d.predecessortasks,
                  type: t.config.links.finish_to_start,
                });
          }
          return a;
        },
        serialize: function () {
          t.message("Serialization to 'old XML' is not implemented");
        },
      }),
      (t.serverList = function (e, i) {
        return (
          i
            ? (this.serverList[e] = i.slice(0))
            : this.serverList[e] || (this.serverList[e] = []),
          this.serverList[e]
        );
      });
  }
  function Re(t, n, e, i, a) {
    return (
      (this.date = t),
      (this.unit = n),
      (this.task = e),
      (this.id = i),
      (this.calendar = a),
      this
    );
  }
  function He(t, n, e, i, a, r) {
    return (
      (this.date = t),
      (this.dir = n),
      (this.unit = e),
      (this.task = i),
      (this.id = a),
      (this.calendar = r),
      this
    );
  }
  function Oe(t, n, e, i, a, r, s) {
    return (
      (this.start_date = t),
      (this.duration = n),
      (this.unit = e),
      (this.step = i),
      (this.task = a),
      (this.id = r),
      (this.calendar = s),
      this
    );
  }
  function Yi(t, n, e, i) {
    return (
      (this.start_date = t),
      (this.end_date = n),
      (this.task = e),
      (this.calendar = i),
      (this.unit = null),
      (this.step = null),
      this
    );
  }
  ne.prototype = {
    init: function (t) {
      var n = this.$gantt,
        e = n._waiAria.gridAttrString(),
        i = n._waiAria.gridDataAttrString(),
        a = this.$getConfig(),
        r = a.reorder_grid_columns || !1;
      this.$config.reorder_grid_columns !== void 0 &&
        (r = this.$config.reorder_grid_columns),
        (t.innerHTML =
          "<div class='gantt_grid' style='height:inherit;width:inherit;' " +
          e +
          "></div>"),
        (this.$grid = t.childNodes[0]),
        (this.$grid.innerHTML =
          "<div class='gantt_grid_scale' " +
          n._waiAria.gridScaleRowAttrString() +
          "></div><div class='gantt_grid_data' " +
          i +
          "></div>"),
        (this.$grid_scale = this.$grid.childNodes[0]),
        (this.$grid_data = this.$grid.childNodes[1]);
      var s = a[this.$config.bind + "_attribute"];
      if (
        (!s && this.$config.bind && (s = "data-" + this.$config.bind + "-id"),
        (this.$config.item_attribute = s || null),
        !this.$config.layers)
      ) {
        var o = this._createLayerConfig();
        this.$config.layers = o;
      }
      var l = (function (c, u) {
        var h = {
          column_before_start: c.bind(function (_, f, y) {
            var v = u.$getConfig(),
              b = Q(y, v.grid_resizer_column_attribute);
            if (!b || !dt(b, ".gantt_grid_column_resize_wrap")) return !1;
            var g = this.locate(y, v.grid_resizer_column_attribute),
              m = u.getGridColumns()[g];
            return u.callEvent("onColumnResizeStart", [g, m]) !== !1 && void 0;
          }, c),
          column_after_start: c.bind(function (_, f, y) {
            var v = u.$getConfig(),
              b = this.locate(y, v.grid_resizer_column_attribute);
            (_.config.marker.innerHTML = ""),
              (_.config.marker.className += " gantt_grid_resize_area"),
              (_.config.marker.style.height = u.$grid.offsetHeight + "px"),
              (_.config.marker.style.top = "0px"),
              (_.config.drag_index = b);
          }, c),
          column_drag_move: c.bind(function (_, f, y) {
            var v = u.$getConfig(),
              b = _.config,
              g = u.getGridColumns(),
              m = parseInt(b.drag_index, 10),
              p = g[m],
              k = Y(u.$grid_scale),
              w = parseInt(b.marker.style.left, 10),
              x = p.min_width ? p.min_width : v.min_grid_column_width,
              $ = u.$grid_data.offsetWidth,
              S = 0,
              T = 0;
            v.rtl ? (w = k.x + k.width - 1 - w) : (w -= k.x - 1);
            for (var E = 0; E < m; E++) (x += g[E].width), (S += g[E].width);
            if ((w < x && (w = x), v.keep_grid_width)) {
              var C = 0;
              for (E = m + 1; E < g.length; E++)
                g[E].min_width
                  ? ($ -= g[E].min_width)
                  : v.min_grid_column_width && ($ -= v.min_grid_column_width),
                  g[E].max_width && C !== !1 ? (C += g[E].max_width) : (C = !1);
              C && (x = u.$grid_data.offsetWidth - C),
                w < x && (w = x),
                w > $ && (w = $);
            } else if (!u.$config.scrollable) {
              var D = w,
                A = c.$container.offsetWidth,
                I = 0;
              if (u.$grid_data.offsetWidth <= A - 25)
                for (E = m + 1; E < g.length; E++) I += g[E].width;
              else {
                for (E = m + 1; E >= 0; E--) I += g[E].width;
                I = A - I;
              }
              I > A && (I -= A);
              var M = u.$parent.$parent;
              if (M && M.$config.mode == "y") {
                var L = M.$lastSize.x;
                A = Math.min(A, L - (M.$cells.length - 1));
              }
              D + I > A && (w = A - I);
            }
            return (
              (b.left = w - 1),
              (T = Math.abs(w - S)),
              p.max_width && T > p.max_width && (T = p.max_width),
              v.rtl && (S = k.width - S + 2 - T),
              (b.marker.style.top = k.y + "px"),
              (b.marker.style.left = k.x - 1 + S + "px"),
              (b.marker.style.width = T + "px"),
              u.callEvent("onColumnResize", [m, g[m], T - 1]),
              !0
            );
          }, c),
          column_drag_end: c.bind(function (_, f, y) {
            for (
              var v = u.$getConfig(),
                b = u.getGridColumns(),
                g = 0,
                m = parseInt(_.config.drag_index, 10),
                p = b[m],
                k = 0;
              k < m;
              k++
            )
              g += b[k].width;
            var w =
              p.min_width && _.config.left - g < p.min_width
                ? p.min_width
                : _.config.left - g;
            if (
              (p.max_width && p.max_width < w && (w = p.max_width),
              u.callEvent("onColumnResizeEnd", [m, p, w]) !== !1 &&
                p.width != w)
            ) {
              if (((p.width = w), v.keep_grid_width)) g = v.grid_width;
              else {
                k = m;
                for (var x = b.length; k < x; k++) g += b[k].width;
              }
              u.callEvent("onColumnResizeComplete", [
                b,
                u._setColumnsWidth(g, m),
              ]),
                u.$config.scrollable ||
                  c.$layout._syncCellSizes(u.$config.group, {
                    value: v.grid_width,
                    isGravity: !1,
                  }),
                this.render();
            }
          }, c),
        };
        return {
          init: function () {
            var _ = c.$services.getService("dnd"),
              f = u.$getConfig(),
              y = new _(u.$grid_scale, { updates_per_second: 60 });
            c.defined(f.dnd_sensitivity) &&
              (y.config.sensitivity = f.dnd_sensitivity),
              y.attachEvent("onBeforeDragStart", function (v, b) {
                return h.column_before_start(y, v, b);
              }),
              y.attachEvent("onAfterDragStart", function (v, b) {
                return h.column_after_start(y, v, b);
              }),
              y.attachEvent("onDragMove", function (v, b) {
                return h.column_drag_move(y, v, b);
              }),
              y.attachEvent("onDragEnd", function (v, b) {
                return h.column_drag_end(y, v, b);
              });
          },
          doOnRender: function () {
            for (
              var _ = u.getGridColumns(),
                f = u.$getConfig(),
                y = 0,
                v = u.$config.width,
                b = f.scale_height,
                g = 0;
              g < _.length;
              g++
            ) {
              var m,
                p = _[g];
              if (
                ((y += p.width),
                (m = f.rtl ? v - y : y),
                p.resize && g != _.length - 1)
              ) {
                var k = document.createElement("div");
                (k.className = "gantt_grid_column_resize_wrap"),
                  (k.style.top = "0px"),
                  (k.style.height = b + "px"),
                  (k.innerHTML =
                    "<div class='gantt_grid_column_resize'></div>"),
                  k.setAttribute(f.grid_resizer_column_attribute, g),
                  k.setAttribute("column_index", g),
                  c._waiAria.gridSeparatorAttr(k),
                  u.$grid_scale.appendChild(k),
                  (k.style.left = Math.max(0, m) + "px");
              }
            }
          },
        };
      })(n, this);
      l.init(),
        (this._renderHeaderResizers = l.doOnRender),
        (this._mouseDelegates = Pe(n));
      var d = (function (c, u) {
        var h = {
          row_before_start: c.bind(function (_, f, y) {
            var v = u.$getConfig(),
              b = u.$config.rowStore;
            if (!Q(y, v.task_grid_row_resizer_attribute)) return !1;
            var g = this.locate(y, v.task_grid_row_resizer_attribute),
              m = b.getItem(g);
            return u.callEvent("onBeforeRowResize", [m]) !== !1 && void 0;
          }, c),
          row_after_start: c.bind(function (_, f, y) {
            var v = u.$getConfig(),
              b = this.locate(y, v.task_grid_row_resizer_attribute);
            (_.config.marker.innerHTML = ""),
              (_.config.marker.className += " gantt_row_grid_resize_area"),
              (_.config.marker.style.width = u.$grid.offsetWidth + "px"),
              (_.config.drag_id = b);
          }, c),
          row_drag_move: c.bind(function (_, f, y) {
            var v = u.$config.rowStore,
              b = u.$getConfig(),
              g = _.config,
              m = g.drag_id,
              p = u.getItemHeight(m),
              k = u.getItemTop(m) - f.scrollTop,
              w = Y(u.$grid_data),
              x = parseInt(g.marker.style.top, 10),
              $ = k + w.y,
              S = 0,
              T = b.min_task_grid_row_height;
            return (
              (S = x - $) < T && (S = T),
              (g.marker.style.left = w.x + "px"),
              (g.marker.style.top = $ - 1 + "px"),
              (g.marker.style.height = Math.abs(S) + 1 + "px"),
              (g.marker_height = S),
              u.callEvent("onRowResize", [m, v.getItem(m), S + p]),
              !0
            );
          }, c),
          row_drag_end: c.bind(function (_, f, y) {
            var v = u.$config.rowStore,
              b = _.config,
              g = b.drag_id,
              m = v.getItem(g),
              p = u.getItemHeight(g),
              k = b.marker_height;
            u.callEvent("onBeforeRowResizeEnd", [g, m, k]) !== !1 &&
              m.row_height != k &&
              ((m.row_height = k),
              v.updateItem(g),
              u.callEvent("onAfterRowResize", [g, m, p, k]),
              this.render());
          }, c),
        };
        return {
          init: function () {
            var _ = c.$services.getService("dnd"),
              f = u.$getConfig(),
              y = new _(u.$grid_data, { updates_per_second: 60 });
            c.defined(f.dnd_sensitivity) &&
              (y.config.sensitivity = f.dnd_sensitivity),
              y.attachEvent("onBeforeDragStart", function (v, b) {
                return h.row_before_start(y, v, b);
              }),
              y.attachEvent("onAfterDragStart", function (v, b) {
                return h.row_after_start(y, v, b);
              }),
              y.attachEvent("onDragMove", function (v, b) {
                return h.row_drag_move(y, v, b);
              }),
              y.attachEvent("onDragEnd", function (v, b) {
                return h.row_drag_end(y, v, b);
              });
          },
        };
      })(n, this);
      d.init(),
        this._addLayers(this.$gantt),
        this._initEvents(),
        r && ((this._columnDND = new Gi(n, this)), this._columnDND.init()),
        this.callEvent("onReady", []);
    },
    _validateColumnWidth: function (t, n) {
      var e = t[n];
      if (e && e != "*") {
        var i = this.$gantt,
          a = 1 * e;
        isNaN(a)
          ? i.assert(!1, "Wrong " + n + " value of column " + t.name)
          : (t[n] = a);
      }
    },
    setSize: function (t, n) {
      (this.$config.width = this.$state.width = t),
        (this.$config.height = this.$state.height = n);
      for (
        var e,
          i = this.getGridColumns(),
          a = 0,
          r = (d = this.$getConfig()).grid_elastic_columns,
          s = 0,
          o = i.length;
        s < o;
        s++
      )
        this._validateColumnWidth(i[s], "min_width"),
          this._validateColumnWidth(i[s], "max_width"),
          this._validateColumnWidth(i[s], "width"),
          (a += 1 * i[s].width);
      if (
        ((!isNaN(a) && this.$config.scrollable) ||
          (a = e = this._setColumnsWidth(t + 1)),
        this.$config.scrollable && r && !isNaN(a))
      ) {
        let u = "width";
        r == "min_width" && (u = "min_width");
        let h = 0;
        i.forEach(function (_) {
          h += _[u] || d.min_grid_column_width;
        });
        var l = Math.max(h, t);
        (a = this._setColumnsWidth(l)), (e = t);
      }
      this.$config.scrollable
        ? ((this.$grid_scale.style.width = a + "px"),
          (this.$grid_data.style.width = a + "px"))
        : ((this.$grid_scale.style.width = "inherit"),
          (this.$grid_data.style.width = "inherit")),
        (this.$config.width -= 1);
      var d = this.$getConfig();
      e !== t &&
        (e !== void 0
          ? ((d.grid_width = e), (this.$config.width = e - 1))
          : isNaN(a) ||
            (this._setColumnsWidth(a),
            (d.grid_width = a),
            (this.$config.width = a - 1)));
      var c = Math.max(this.$state.height - d.scale_height, 0);
      (this.$grid_data.style.height = c + "px"), this.refresh();
    },
    getSize: function () {
      var t = this.$getConfig(),
        n = this.$config.rowStore ? this.getTotalHeight() : 0,
        e = this._getGridWidth();
      return {
        x: this.$state.width,
        y: this.$state.height,
        contentX: this.isVisible() ? e : 0,
        contentY: this.isVisible() ? t.scale_height + n : 0,
        scrollHeight: this.isVisible() ? n : 0,
        scrollWidth: this.isVisible() ? e : 0,
      };
    },
    _bindStore: function () {
      if (this.$config.bind) {
        var t = this.$gantt.getDatastore(this.$config.bind);
        if (((this.$config.rowStore = t), t && !t._gridCacheAttached)) {
          var n = this;
          t._gridCacheAttached = t.attachEvent("onBeforeFilter", function () {
            n._resetTopPositionHeight();
          });
        }
      }
    },
    _unbindStore: function () {
      if (this.$config.bind) {
        var t = this.$gantt.getDatastore(this.$config.bind);
        t &&
          t._gridCacheAttached &&
          (t.detachEvent(t._gridCacheAttached), (t._gridCacheAttached = !1));
      }
    },
    refresh: function () {
      this._bindStore(),
        this._resetTopPositionHeight(),
        this._resetHeight(),
        this._initSmartRenderingPlaceholder(),
        this._calculateGridWidth(),
        this._renderGridHeader();
    },
    getViewPort: function () {
      var t = this.$config.scrollLeft || 0,
        n = this.$config.scrollTop || 0,
        e = this.$config.height || 0,
        i = this.$config.width || 0;
      return { y: n, y_end: n + e, x: t, x_end: t + i, height: e, width: i };
    },
    scrollTo: function (t, n) {
      if (this.isVisible()) {
        var e = !1;
        (this.$config.scrollTop = this.$config.scrollTop || 0),
          (this.$config.scrollLeft = this.$config.scrollLeft || 0),
          1 * t == t &&
            ((this.$config.scrollLeft =
              this.$state.scrollLeft =
              this.$grid.scrollLeft =
                t),
            (e = !0)),
          1 * n == n &&
            ((this.$config.scrollTop =
              this.$state.scrollTop =
              this.$grid_data.scrollTop =
                n),
            (e = !0)),
          e &&
            this.callEvent("onScroll", [
              this.$config.scrollLeft,
              this.$config.scrollTop,
            ]);
      }
    },
    getColumnIndex: function (t, n) {
      for (var e = this.$getConfig().columns, i = 0, a = 0; a < e.length; a++)
        if ((n && e[a].hide && i++, e[a].name == t)) return a - i;
      return null;
    },
    getColumn: function (t) {
      var n = this.getColumnIndex(t);
      return n === null ? null : this.$getConfig().columns[n];
    },
    getGridColumns: function () {
      return this.$getConfig().columns.slice();
    },
    isVisible: function () {
      return this.$parent && this.$parent.$config
        ? !this.$parent.$config.hidden
        : this.$grid.offsetWidth;
    },
    _createLayerConfig: function () {
      var t = this.$gantt,
        n = this;
      return [
        {
          renderer: t.$ui.layers.gridLine(),
          container: this.$grid_data,
          filter: [
            function () {
              return n.isVisible();
            },
          ],
        },
        {
          renderer: t.$ui.layers.gridTaskRowResizer(),
          container: this.$grid_data,
          append: !0,
          filter: [
            function () {
              return t.config.resize_rows;
            },
          ],
        },
      ];
    },
    _addLayers: function (t) {
      if (this.$config.bind) {
        this._taskLayers = [];
        var n = this,
          e = this.$gantt.$services.getService("layers"),
          i = e.getDataRender(this.$config.bind);
        i ||
          (i = e.createDataRender({
            name: this.$config.bind,
            defaultContainer: function () {
              return n.$grid_data;
            },
          }));
        for (var a = this.$config.layers, r = 0; a && r < a.length; r++) {
          var s = a[r];
          s.view = this;
          var o = i.addLayer(s);
          this._taskLayers.push(o);
        }
        this._bindStore(), this._initSmartRenderingPlaceholder();
      }
    },
    _refreshPlaceholderOnStoreUpdate: function (t) {
      var n = this.$getConfig(),
        e = this.$config.rowStore;
      if (e && t === null && this.isVisible() && n.smart_rendering) {
        var i;
        if (this.$config.scrollY) {
          var a = this.$gantt.$ui.getView(this.$config.scrollY);
          a && (i = a.getScrollState().scrollSize);
        }
        if ((i || (i = e ? this.getTotalHeight() : 0), i)) {
          this.$rowsPlaceholder &&
            this.$rowsPlaceholder.parentNode &&
            this.$rowsPlaceholder.parentNode.removeChild(this.$rowsPlaceholder);
          var r = (this.$rowsPlaceholder = document.createElement("div"));
          (r.style.visibility = "hidden"),
            (r.style.height = i + "px"),
            (r.style.width = "1px"),
            this.$grid_data.appendChild(r);
        }
      }
    },
    _initSmartRenderingPlaceholder: function () {
      var t = this.$config.rowStore;
      t &&
        ((this._initSmartRenderingPlaceholder = function () {}),
        (this._staticBgHandler = t.attachEvent(
          "onStoreUpdated",
          z(this._refreshPlaceholderOnStoreUpdate, this)
        )));
    },
    _initEvents: function () {
      var t = this.$gantt;
      this._mouseDelegates.delegate(
        "click",
        "gantt_close",
        t.bind(function (n, e, i) {
          var a = this.$config.rowStore;
          if (!a) return !0;
          var r = Q(n, this.$config.item_attribute);
          return r && a.close(r.getAttribute(this.$config.item_attribute)), !1;
        }, this),
        this.$grid
      ),
        this._mouseDelegates.delegate(
          "click",
          "gantt_open",
          t.bind(function (n, e, i) {
            var a = this.$config.rowStore;
            if (!a) return !0;
            var r = Q(n, this.$config.item_attribute);
            return r && a.open(r.getAttribute(this.$config.item_attribute)), !1;
          }, this),
          this.$grid
        );
    },
    _clearLayers: function (t) {
      var n = this.$gantt.$services
        .getService("layers")
        .getDataRender(this.$config.bind);
      if (this._taskLayers)
        for (var e = 0; e < this._taskLayers.length; e++)
          n.removeLayer(this._taskLayers[e]);
      this._taskLayers = [];
    },
    _getColumnWidth: function (t, n, e) {
      var i = t.min_width || n.min_grid_column_width,
        a = Math.max(e, i || 10);
      return t.max_width && (a = Math.min(a, t.max_width)), a;
    },
    _checkGridColumnMinWidthLimits: function (t, n) {
      for (var e = 0, i = t.length; e < i; e++) {
        var a = 1 * t[e].width;
        !t[e].min_width && a < n.min_grid_column_width && (t[e].min_width = a);
      }
    },
    _getGridWidthLimits: function () {
      for (
        var t = this.$getConfig(),
          n = this.getGridColumns(),
          e = 0,
          i = 0,
          a = 0;
        a < n.length;
        a++
      )
        (e += n[a].min_width ? n[a].min_width : t.min_grid_column_width),
          i !== void 0 && (i = n[a].max_width ? i + n[a].max_width : void 0);
      return this._checkGridColumnMinWidthLimits(n, t), [e, i];
    },
    _setColumnsWidth: function (t, n) {
      var e = this.$getConfig(),
        i = this.getGridColumns(),
        a = 0,
        r = t;
      n = window.isNaN(n) ? -1 : n;
      for (var s = 0, o = i.length; s < o; s++) a += 1 * i[s].width;
      if (window.isNaN(a))
        for (this._calculateGridWidth(), a = 0, s = 0, o = i.length; s < o; s++)
          a += 1 * i[s].width;
      var l = r - a,
        d = 0;
      for (s = 0; s < n + 1; s++) d += i[s].width;
      for (a -= d, s = n + 1; s < i.length; s++) {
        var c = i[s],
          u = Math.round(l * (c.width / a));
        l < 0
          ? c.min_width && c.width + u < c.min_width
            ? (u = c.min_width - c.width)
            : !c.min_width &&
              e.min_grid_column_width &&
              c.width + u < e.min_grid_column_width &&
              (u = e.min_grid_column_width - c.width)
          : c.max_width &&
            c.width + u > c.max_width &&
            (u = c.max_width - c.width),
          (a -= c.width),
          (c.width += u),
          (l -= u);
      }
      for (
        var h = l > 0 ? 1 : -1;
        (l > 0 && h === 1) || (l < 0 && h === -1);

      ) {
        var _ = l;
        for (s = n + 1; s < i.length; s++) {
          var f;
          if (
            ((f = i[s].width + h) == this._getColumnWidth(i[s], e, f) &&
              ((l -= h), (i[s].width = f)),
            !l)
          )
            break;
        }
        if (_ == l) break;
      }
      return (
        l &&
          n > -1 &&
          (f = i[n].width + l) == this._getColumnWidth(i[n], e, f) &&
          (i[n].width = f),
        this._getColsTotalWidth()
      );
    },
    _getColsTotalWidth: function () {
      for (var t = this.getGridColumns(), n = 0, e = 0; e < t.length; e++) {
        var i = parseFloat(t[e].width);
        if (window.isNaN(i)) return !1;
        n += i;
      }
      return n;
    },
    _calculateGridWidth: function () {
      for (
        var t = this.$getConfig(),
          n = this.getGridColumns(),
          e = 0,
          i = [],
          a = [],
          r = 0;
        r < n.length;
        r++
      ) {
        var s = parseFloat(n[r].width);
        window.isNaN(s) && ((s = t.min_grid_column_width || 10), i.push(r)),
          (a[r] = s),
          (e += s);
      }
      var o = this._getGridWidth() + 1;
      if (t.autofit || i.length) {
        var l = o - e;
        if (t.autofit && !t.grid_elastic_columns)
          for (r = 0; r < a.length; r++) {
            var d = Math.round(l / (a.length - r));
            (a[r] += d),
              (c = this._getColumnWidth(n[r], t, a[r])) != a[r] &&
                ((d = c - a[r]), (a[r] = c)),
              (l -= d);
          }
        else if (i.length)
          for (r = 0; r < i.length; r++) {
            d = Math.round(l / (i.length - r));
            var c,
              u = i[r];
            (a[u] += d),
              (c = this._getColumnWidth(n[u], t, a[u])) != a[u] &&
                ((d = c - a[u]), (a[u] = c)),
              (l -= d);
          }
        for (r = 0; r < a.length; r++) n[r].width = a[r];
      } else {
        var h = o != e;
        (this.$config.width = e - 1),
          (t.grid_width = e),
          h && this.$parent._setContentSize(this.$config.width, null);
      }
    },
    _renderGridHeader: function () {
      var t = this.$gantt,
        n = this.$getConfig(),
        e = this.$gantt.locale,
        i = this.$gantt.templates,
        a = this.getGridColumns();
      n.rtl && (a = a.reverse());
      var r = [],
        s = 0,
        o = e.labels,
        l = n.scale_height - 1;
      const d = {};
      for (var c = 0; c < a.length; c++) {
        var u = c == a.length - 1,
          h = a[c];
        h.name || (h.name = t.uid() + "");
        var _ = 1 * h.width,
          f = this._getGridWidth();
        u && f > s + _ && (h.width = _ = f - s), (s += _);
        var y =
            t._sort && h.name == t._sort.name
              ? `<div data-column-id="${h.name}" class="gantt_sort gantt_${t._sort.direction}"></div>`
              : "",
          v = [
            "gantt_grid_head_cell",
            "gantt_grid_head_" + h.name,
            u ? "gantt_last_cell" : "",
            i.grid_header_class(h.name, h),
          ].join(" "),
          b = "width:" + (_ - (u ? 1 : 0)) + "px;",
          g = h.label || o["column_" + h.name] || o[h.name];
        typeof g == "function" && (g = g.call(t, h.name, h)), (g = g || "");
        let p = !1;
        t.config.external_render &&
          t.config.external_render.isElement(g) &&
          ((p = !0), (d[h.name] = g));
        var m =
          "<div class='" +
          v +
          "' style='" +
          b +
          "' " +
          t._waiAria.gridScaleCellAttrString(h, g) +
          " data-column-id='" +
          h.name +
          "' column_id='" +
          h.name +
          "' data-column-name='" +
          h.name +
          "' data-column-index='" +
          c +
          "'>" +
          (p ? "<div data-component-container></div>" : g) +
          y +
          "</div>";
        r.push(m);
      }
      (this.$grid_scale.style.height = n.scale_height + "px"),
        (this.$grid_scale.style.lineHeight = l + "px"),
        (this.$grid_scale.innerHTML = r.join(""));
      for (let p in d)
        t.config.external_render.renderElement(
          d[p],
          this.$grid_scale.querySelector(
            "[data-column-id='" + p + "'] [data-component-container]"
          )
        );
      this._renderHeaderResizers && this._renderHeaderResizers();
    },
    _getGridWidth: function () {
      return this.$config.width;
    },
    destructor: function () {
      this._clearLayers(this.$gantt),
        this._mouseDelegates &&
          (this._mouseDelegates.destructor(), (this._mouseDelegates = null)),
        this._unbindStore(),
        (this.$grid = null),
        (this.$grid_scale = null),
        (this.$grid_data = null),
        (this.$gantt = null),
        this.$config.rowStore &&
          (this.$config.rowStore.detachEvent(this._staticBgHandler),
          (this.$config.rowStore = null)),
        this.callEvent("onDestroy", []),
        this.detachAllEvents();
    },
  };
  var Rn = function (t) {
    return {
      getWorkHoursArguments: function () {
        var n = arguments[0];
        if (!Tt((n = nt(n) ? { date: n } : O({}, n)).date))
          throw (
            (t.assert(!1, "Invalid date argument for getWorkHours method"),
            new Error("Invalid date argument for getWorkHours method"))
          );
        return n;
      },
      setWorkTimeArguments: function () {
        return arguments[0];
      },
      unsetWorkTimeArguments: function () {
        return arguments[0];
      },
      isWorkTimeArguments: function () {
        var n,
          e = arguments[0];
        if (e instanceof Re) return e;
        if (
          (((n = e.date
            ? new Re(e.date, e.unit, e.task, null, e.calendar)
            : new Re(
                arguments[0],
                arguments[1],
                arguments[2],
                null,
                arguments[3]
              )).unit = n.unit || t.config.duration_unit),
          !Tt(n.date))
        )
          throw (
            (t.assert(!1, "Invalid date argument for isWorkTime method"),
            new Error("Invalid date argument for isWorkTime method"))
          );
        return n;
      },
      getClosestWorkTimeArguments: function (n) {
        var e,
          i = arguments[0];
        if (i instanceof He) return i;
        if (
          ((e = nt(i)
            ? new He(i)
            : new He(i.date, i.dir, i.unit, i.task, null, i.calendar)),
          i.id && (e.task = i),
          (e.dir = i.dir || "any"),
          (e.unit = i.unit || t.config.duration_unit),
          !Tt(e.date))
        )
          throw (
            (t.assert(
              !1,
              "Invalid date argument for getClosestWorkTime method"
            ),
            new Error("Invalid date argument for getClosestWorkTime method"))
          );
        return e;
      },
      _getStartEndConfig: function (n) {
        var e,
          i = Yi;
        if (n instanceof i) return n;
        if (
          (nt(n)
            ? (e = new i(
                arguments[0],
                arguments[1],
                arguments[2],
                arguments[3]
              ))
            : ((e = new i(n.start_date, n.end_date, n.task)),
              n.id !== null && n.id !== void 0 && (e.task = n)),
          (e.unit = e.unit || t.config.duration_unit),
          (e.step = e.step || t.config.duration_step),
          (e.start_date = e.start_date || e.start || e.date),
          !Tt(e.start_date))
        )
          throw (
            (t.assert(!1, "Invalid start_date argument for getDuration method"),
            new Error("Invalid start_date argument for getDuration method"))
          );
        if (!Tt(e.end_date))
          throw (
            (t.assert(!1, "Invalid end_date argument for getDuration method"),
            new Error("Invalid end_date argument for getDuration method"))
          );
        return e;
      },
      getDurationArguments: function (n, e, i, a) {
        return this._getStartEndConfig.apply(this, arguments);
      },
      hasDurationArguments: function (n, e, i, a) {
        return this._getStartEndConfig.apply(this, arguments);
      },
      calculateEndDateArguments: function (n, e, i, a) {
        var r,
          s = arguments[0];
        if (s instanceof Oe) return s;
        if (
          ((r = nt(s)
            ? new Oe(
                arguments[0],
                arguments[1],
                arguments[2],
                void 0,
                arguments[3],
                void 0,
                arguments[4]
              )
            : new Oe(
                s.start_date,
                s.duration,
                s.unit,
                s.step,
                s.task,
                null,
                s.calendar
              )),
          s.id !== null &&
            s.id !== void 0 &&
            ((r.task = s), (r.unit = null), (r.step = null)),
          (r.unit = r.unit || t.config.duration_unit),
          (r.step = r.step || t.config.duration_step),
          !Tt(r.start_date))
        )
          throw (
            (t.assert(
              !1,
              "Invalid start_date argument for calculateEndDate method"
            ),
            new Error(
              "Invalid start_date argument for calculateEndDate method"
            ))
          );
        return r;
      },
    };
  };
  function Hn() {}
  Hn.prototype = {
    _getIntervals: function (t) {
      for (var n = [], e = 0; e < t.length; e += 2)
        n.push({ start: t[e], end: t[e + 1] });
      return n;
    },
    _toHoursArray: function (t) {
      var n = [];
      function e(a) {
        var r,
          s = Math.floor(a / 3600),
          o = a - 60 * s * 60,
          l = Math.floor(o / 60);
        return s + ":" + ((r = String(l)).length < 2 && (r = "0" + r), r);
      }
      for (var i = 0; i < t.length; i++)
        n.push(e(t[i].start) + "-" + e(t[i].end));
      return n;
    },
    _intersectHourRanges: function (t, n) {
      var e = [],
        i = t.length > n.length ? t : n,
        a = t === i ? n : t;
      (i = i.slice()), (a = a.slice()), (e = []);
      for (var r = 0; r < i.length; r++)
        for (var s = i[r], o = 0; o < a.length; o++) {
          var l = a[o];
          l.start < s.end &&
            l.end > s.start &&
            (e.push({
              start: Math.max(s.start, l.start),
              end: Math.min(s.end, l.end),
            }),
            s.end > l.end && (a.splice(o, 1), o--, r--));
        }
      return e;
    },
    _mergeAdjacentIntervals: function (t) {
      var n = t.slice();
      n.sort(function (r, s) {
        return r.start - s.start;
      });
      for (var e = n[0], i = 1; i < n.length; i++) {
        var a = n[i];
        a.start <= e.end
          ? (a.end > e.end && (e.end = a.end), n.splice(i, 1), i--)
          : (e = a);
      }
      return n;
    },
    _mergeHoursConfig: function (t, n) {
      return this._mergeAdjacentIntervals(this._intersectHourRanges(t, n));
    },
    merge: function (t, n) {
      const e = X(t.getConfig()),
        i = X(n.getConfig()),
        a = e.parsed,
        r = i.parsed;
      (a.customWeeks = e.customWeeks), (r.customWeeks = i.customWeeks);
      var s = {
        hours: this._toHoursArray(this._mergeHoursConfig(a.hours, r.hours)),
        dates: {},
        customWeeks: {},
      };
      const o = (d, c) => {
        for (let u in d.dates) {
          const h = d.dates[u];
          +u > 1e3 && (s.dates[u] = !1);
          for (const _ in c.dates) {
            const f = c.dates[_];
            if ((_ == u && (s.dates[u] = !(!h || !f)), Array.isArray(h))) {
              const y = Array.isArray(f) ? f : c.hours;
              s.dates[u] = this._toHoursArray(this._mergeHoursConfig(h, y));
            }
          }
        }
      };
      if ((o(a, r), o(r, a), a.customWeeks))
        for (var l in a.customWeeks) s.customWeeks[l] = a.customWeeks[l];
      if (r.customWeeks)
        for (var l in r.customWeeks)
          s.customWeeks[l]
            ? (s.customWeeks[l + "_second"] = r.customWeeks[l])
            : (s.customWeeks[l] = r.customWeeks[l]);
      return s;
    },
  };
  class Ji {
    constructor() {
      this.clear();
    }
    getItem(n, e, i) {
      if (this._cache.has(n)) {
        const a = this._cache.get(n)[i.getFullYear()];
        if (a && a.has(e)) return a.get(e);
      }
      return -1;
    }
    setItem(n, e, i, a) {
      if (!n || !e) return;
      const r = this._cache,
        s = a.getFullYear();
      let o;
      r.has(n) ? (o = r.get(n)) : ((o = []), r.set(n, o));
      let l = o[s];
      l || (l = o[s] = new Map()), l.set(e, i);
    }
    clear() {
      this._cache = new Map();
    }
  }
  class Ki {
    constructor() {
      this.clear();
    }
    getItem(n, e, i) {
      const a = this._cache;
      if (a && a[n]) {
        const r = a[n];
        if (r === void 0) return -1;
        const s = r[i.getFullYear()];
        if (s && s[e] !== void 0) return s[e];
      }
      return -1;
    }
    setItem(n, e, i, a) {
      if (!n || !e) return;
      const r = this._cache;
      if (!r) return;
      r[n] || (r[n] = []);
      const s = r[n],
        o = a.getFullYear();
      let l = s[o];
      l || (l = s[o] = {}), (l[e] = i);
    }
    clear() {
      this._cache = {};
    }
  }
  class Xi {
    constructor(n) {
      (this.getMinutesPerWeek = (e) => {
        const i = e.valueOf();
        if (this._weekCache.has(i)) return this._weekCache.get(i);
        const a = this._calendar,
          r = this._calendar.$gantt;
        let s = 0,
          o = r.date.week_start(new Date(e));
        for (let l = 0; l < 7; l++)
          (s += 60 * a.getHoursPerDay(o)), (o = r.date.add(o, 1, "day"));
        return this._weekCache.set(i, s), s;
      }),
        (this.getMinutesPerMonth = (e) => {
          const i = e.valueOf();
          if (this._monthCache.has(i)) return this._monthCache.get(i);
          const a = this._calendar,
            r = this._calendar.$gantt;
          let s = 0,
            o = r.date.week_start(new Date(e));
          const l = r.date.add(o, 1, "month").valueOf();
          for (; o.valueOf() < l; )
            (s += 60 * a.getHoursPerDay(o)), (o = r.date.add(o, 1, "day"));
          return this._monthCache.set(i, s), s;
        }),
        (this.clear = () => {
          (this._weekCache = new Map()), (this._monthCache = new Map());
        }),
        this.clear(),
        (this._calendar = n);
    }
  }
  class Zi {
    constructor() {
      this.clear();
    }
    _getCacheObject(n, e, i) {
      const a = this._cache;
      a[e] || (a[e] = []);
      let r = a[e];
      r || (r = a[e] = {});
      let s = r[i];
      s || (s = r[i] = {});
      const o = n.getFullYear();
      let l = s[o];
      return l || (l = s[o] = { durations: {}, endDates: {} }), l;
    }
    _endDateCacheKey(n, e) {
      return String(n) + "-" + String(e);
    }
    _durationCacheKey(n, e) {
      return String(n) + "-" + String(e);
    }
    getEndDate(n, e, i, a, r) {
      const s = this._getCacheObject(n, i, a),
        o = n.valueOf(),
        l = this._endDateCacheKey(o, e);
      let d;
      if (s.endDates[l] === void 0) {
        const c = r(),
          u = c.valueOf();
        (s.endDates[l] = u),
          (s.durations[this._durationCacheKey(o, u)] = e),
          (d = c);
      } else d = new Date(s.endDates[l]);
      return d;
    }
    getDuration(n, e, i, a, r) {
      const s = this._getCacheObject(n, i, a),
        o = n.valueOf(),
        l = e.valueOf(),
        d = this._durationCacheKey(o, l);
      let c;
      if (s.durations[d] === void 0) {
        const u = r();
        (s.durations[d] = u.valueOf()), (c = u);
      } else c = s.durations[d];
      return c;
    }
    clear() {
      this._cache = {};
    }
  }
  function Be(t, n) {
    (this.argumentsHelper = n),
      (this.$gantt = t),
      (this._workingUnitsCache = typeof Map < "u" ? new Ji() : new Ki()),
      (this._largeUnitsCache = new Xi(this)),
      (this._dateDurationCache = new Zi()),
      (this._worktime = null),
      (this._cached_timestamps = {}),
      (this._cached_timestamps_count = 0);
  }
  Be.prototype = {
    units: ["year", "month", "week", "day", "hour", "minute"],
    _clearCaches: function () {
      this._workingUnitsCache.clear(),
        this._largeUnitsCache.clear(),
        this._dateDurationCache.clear();
    },
    _getUnitOrder: function (t) {
      for (var n = 0, e = this.units.length; n < e; n++)
        if (this.units[n] == t) return n;
    },
    _resetTimestampCache: function () {
      (this._cached_timestamps = {}), (this._cached_timestamps_count = 0);
    },
    _timestamp: function (t) {
      this._cached_timestamps_count > 1e6 && this._resetTimestampCache();
      var n = null;
      if (t.day || t.day === 0) n = t.day;
      else if (t.date) {
        var e = String(t.date.valueOf());
        this._cached_timestamps[e]
          ? (n = this._cached_timestamps[e])
          : ((n = Date.UTC(
              t.date.getFullYear(),
              t.date.getMonth(),
              t.date.getDate()
            )),
            (this._cached_timestamps[e] = n),
            this._cached_timestamps_count++);
      }
      return n;
    },
    _checkIfWorkingUnit: function (t, n) {
      if (!this["_is_work_" + n]) {
        const e = this.$gantt.date[`${n}_start`](new Date(t)),
          i = this.$gantt.date.add(e, 1, n);
        return this.hasDuration(e, i);
      }
      return this["_is_work_" + n](t);
    },
    _is_work_day: function (t) {
      var n = this._getWorkHours(t);
      return !!Array.isArray(n) && n.length > 0;
    },
    _is_work_hour: function (t) {
      for (
        var n = this._getWorkHours(t), e = t.getHours(), i = 0;
        i < n.length;
        i++
      )
        if (e >= n[i].startHour && e < n[i].endHour) return !0;
      return !1;
    },
    _getTimeOfDayStamp: function (t, n) {
      var e = t.getHours();
      return (
        t.getHours() || t.getMinutes() || !n || (e = 24),
        60 * e * 60 + 60 * t.getMinutes()
      );
    },
    _is_work_minute: function (t) {
      for (
        var n = this._getWorkHours(t), e = this._getTimeOfDayStamp(t), i = 0;
        i < n.length;
        i++
      )
        if (e >= n[i].start && e < n[i].end) return !0;
      return !1;
    },
    _nextDate: function (t, n, e) {
      return this.$gantt.date.add(t, e, n);
    },
    _getWorkUnitsBetweenGeneric: function (t, n, e, i) {
      var a = this.$gantt.date,
        r = new Date(t),
        s = new Date(n);
      i = i || 1;
      var o,
        l,
        d = 0,
        c = null,
        u = !1;
      (o = a[e + "_start"](new Date(r))).valueOf() != r.valueOf() && (u = !0);
      var h = !1;
      (l = a[e + "_start"](new Date(n))).valueOf() != n.valueOf() && (h = !0);
      for (var _ = !1; r.valueOf() < s.valueOf(); ) {
        if (
          ((_ = (c = this._nextDate(r, e, i)).valueOf() > s.valueOf()),
          this._isWorkTime(r, e))
        )
          (u || (h && _)) &&
            ((o = a[e + "_start"](new Date(r))), (l = a.add(o, i, e))),
            u
              ? ((u = !1),
                (c = this._nextDate(o, e, i)),
                (d +=
                  (l.valueOf() - r.valueOf()) / (l.valueOf() - o.valueOf())))
              : h && _
              ? ((h = !1),
                (d +=
                  (s.valueOf() - r.valueOf()) / (l.valueOf() - o.valueOf())))
              : d++;
        else {
          var f = this._getUnitOrder(e),
            y = this.units[f - 1];
          y &&
            !this._isWorkTime(r, y) &&
            (c = this._getClosestWorkTimeFuture(r, y));
        }
        r = c;
      }
      return d;
    },
    _getMinutesPerHour: function (t) {
      var n = this._getTimeOfDayStamp(t),
        e = this._getTimeOfDayStamp(this._nextDate(t, "hour", 1));
      e === 0 && (e = 86400);
      for (var i = this._getWorkHours(t), a = 0; a < i.length; a++) {
        var r = i[a];
        if (n >= r.start && e <= r.end) return 60;
        if (n < r.end && e > r.start)
          return (Math.min(e, r.end) - Math.max(n, r.start)) / 60;
      }
      return 0;
    },
    _getMinutesPerDay: function (t) {
      var n = this._getWorkHours(t),
        e = 0;
      return (
        n.forEach(function (i) {
          e += i.durationMinutes;
        }),
        e
      );
    },
    getHoursPerDay: function (t) {
      var n = this._getWorkHours(t),
        e = 0;
      return (
        n.forEach(function (i) {
          e += i.durationHours;
        }),
        e
      );
    },
    _getWorkUnitsForRange: function (t, n, e, i) {
      var a,
        r = 0,
        s = new Date(t),
        o = new Date(n);
      for (
        a = z(
          e == "minute" ? this._getMinutesPerDay : this.getHoursPerDay,
          this
        );
        s.valueOf() < o.valueOf();

      )
        if (o - s > 27648e5 && s.getDate() === 0) {
          var l = this._largeUnitsCache.getMinutesPerMonth(s);
          e == "hour" && (l /= 60),
            (r += l),
            (s = this.$gantt.date.add(s, 1, "month"));
        } else {
          if (o - s > 13824e5) {
            var d = this.$gantt.date.week_start(new Date(s));
            if (s.valueOf() === d.valueOf()) {
              (l = this._largeUnitsCache.getMinutesPerWeek(s)),
                e == "hour" && (l /= 60),
                (r += l),
                (s = this.$gantt.date.add(s, 7, "day"));
              continue;
            }
          }
          (r += a(s)), (s = this._nextDate(s, "day", 1));
        }
      return r / i;
    },
    _getMinutesBetweenSingleDay: function (t, n) {
      for (
        var e = this._getIntervalTimestamp(t, n),
          i = this._getWorkHours(t),
          a = 0,
          r = 0;
        r < i.length;
        r++
      ) {
        var s = i[r];
        if (e.end >= s.start && e.start <= s.end) {
          var o = Math.max(s.start, e.start),
            l = Math.min(s.end, e.end);
          (a += (l - o) / 60), (e.start = l);
        }
      }
      return Math.floor(a);
    },
    _getMinutesBetween: function (t, n, e, i) {
      var a = new Date(t),
        r = new Date(n);
      i = i || 1;
      var s = new Date(a),
        o = this.$gantt.date.add(
          this.$gantt.date.day_start(new Date(a)),
          1,
          "day"
        );
      if (r.valueOf() <= o.valueOf())
        return this._getMinutesBetweenSingleDay(t, n);
      var l = this.$gantt.date.day_start(new Date(r)),
        d = r,
        c = this._getMinutesBetweenSingleDay(s, o),
        u = this._getMinutesBetweenSingleDay(l, d);
      return c + this._getWorkUnitsForRange(o, l, e, i) + u;
    },
    _getHoursBetween: function (t, n, e, i) {
      var a = new Date(t),
        r = new Date(n);
      i = i || 1;
      var s = new Date(a),
        o = this.$gantt.date.add(
          this.$gantt.date.day_start(new Date(a)),
          1,
          "day"
        );
      if (r.valueOf() <= o.valueOf())
        return Math.round(this._getMinutesBetweenSingleDay(t, n) / 60);
      var l = this.$gantt.date.day_start(new Date(r)),
        d = r,
        c = this._getMinutesBetweenSingleDay(s, o, e, i) / 60,
        u = this._getMinutesBetweenSingleDay(l, d, e, i) / 60,
        h = c + this._getWorkUnitsForRange(o, l, e, i) + u;
      return Math.round(h);
    },
    getConfig: function () {
      return this._worktime;
    },
    _setConfig: function (t) {
      (this._worktime = t), this._parseSettings(), this._clearCaches();
    },
    _parseSettings: function () {
      var t = this.getConfig();
      for (var n in ((t.parsed = {
        dates: {},
        hours: null,
        haveCustomWeeks: !1,
        customWeeks: {},
        customWeeksRangeStart: null,
        customWeeksRangeEnd: null,
        customWeeksBoundaries: [],
      }),
      (t.parsed.hours = this._parseHours(t.hours)),
      t.dates))
        t.parsed.dates[n] = this._parseHours(t.dates[n]);
      if (t.customWeeks) {
        var e = null,
          i = null;
        for (var n in t.customWeeks) {
          var a = t.customWeeks[n];
          if (a.from && a.to) {
            var r = a.from,
              s = a.to;
            (!e || e > r.valueOf()) && (e = r.valueOf()),
              (!i || i < s.valueOf()) && (i = s.valueOf()),
              t.parsed.customWeeksBoundaries.push({
                from: r.valueOf(),
                fromReadable: new Date(r),
                to: s.valueOf(),
                toReadable: new Date(s),
                name: n,
              }),
              (t.parsed.haveCustomWeeks = !0);
            var o = (t.parsed.customWeeks[n] = {
              from: a.from,
              to: a.to,
              hours: this._parseHours(a.hours),
              dates: {},
            });
            if (a.days && !a.dates) {
              for (a.dates = a.dates || {}, n = 0; n < a.days.length; n++)
                (a.dates[n] = a.days[n]),
                  a.days[n] instanceof Array || (a.dates[n] = !!a.days[n]);
              delete a.days;
            }
            for (var l in a.dates) o.dates[l] = this._parseHours(a.dates[l]);
          }
        }
        (t.parsed.customWeeksRangeStart = e),
          (t.parsed.customWeeksRangeEnd = i);
      }
    },
    _tryChangeCalendarSettings: function (t) {
      var n = JSON.stringify(this.getConfig());
      return (
        t(),
        !!this.hasWorkTime() ||
          (this._setConfig(JSON.parse(n)), this._clearCaches(), !1)
      );
    },
    _arraysEqual: function (t, n) {
      if (t === n) return !0;
      if (!t || !n || t.length != n.length) return !1;
      for (var e = 0; e < t.length; ++e) if (t[e] !== n[e]) return !1;
      return !0;
    },
    _compareSettings: function (t, n) {
      if (!this._arraysEqual(t.hours, n.hours)) return !1;
      var e = Object.keys(t.dates),
        i = Object.keys(n.dates);
      if ((e.sort(), i.sort(), !this._arraysEqual(e, i))) return !1;
      for (var a = 0; a < e.length; a++) {
        var r = e[a],
          s = t.dates[r],
          o = t.dates[r];
        if (
          s !== o &&
          !(Array.isArray(s) && Array.isArray(o) && this._arraysEqual(s, o))
        )
          return !1;
      }
      return !0;
    },
    equals: function (t) {
      if (!(t instanceof Be)) return !1;
      var n = this.getConfig(),
        e = t.getConfig();
      if (!this._compareSettings(n, e)) return !1;
      if (n.parsed.haveCustomWeeks && e.parsed.haveCustomWeeks) {
        if (
          n.parsed.customWeeksBoundaries.length !=
          e.parsed.customWeeksBoundaries.length
        )
          return !1;
        for (var i in n.parsed.customWeeks) {
          var a = n.parsed.customWeeks[i],
            r = e.parsed.customWeeks[i];
          if (!r || !this._compareSettings(a, r)) return !1;
        }
      } else if (n.parse.haveCustomWeeks !== e.parsed.haveCustomWeeks)
        return !1;
      return !0;
    },
    getWorkHours: function () {
      var t = this.argumentsHelper.getWorkHoursArguments.apply(
        this.argumentsHelper,
        arguments
      );
      return this._getWorkHours(t.date, !1);
    },
    _getWorkHours: function (t, n) {
      var e = this.getConfig();
      if ((n !== !1 && (e = e.parsed), !t)) return e.hours;
      var i = this._timestamp({ date: t });
      if (
        e.haveCustomWeeks &&
        e.customWeeksRangeStart <= i &&
        e.customWeeksRangeEnd > i
      ) {
        for (var a = 0; a < e.customWeeksBoundaries.length; a++)
          if (
            e.customWeeksBoundaries[a].from <= i &&
            e.customWeeksBoundaries[a].to > i
          ) {
            e = e.customWeeks[e.customWeeksBoundaries[a].name];
            break;
          }
      }
      var r = !0;
      return (
        e.dates[i] !== void 0
          ? (r = e.dates[i])
          : e.dates[t.getDay()] !== void 0 && (r = e.dates[t.getDay()]),
        r === !0 ? e.hours : r || []
      );
    },
    _getIntervalTimestamp: function (t, n) {
      var e = { start: 0, end: 0 };
      e.start = 60 * t.getHours() * 60 + 60 * t.getMinutes() + t.getSeconds();
      var i = n.getHours();
      return (
        !i &&
          !n.getMinutes() &&
          !n.getSeconds() &&
          t.valueOf() < n.valueOf() &&
          (i = 24),
        (e.end = 60 * i * 60 + 60 * n.getMinutes() + n.getSeconds()),
        e
      );
    },
    _parseHours: function (t) {
      if (Array.isArray(t)) {
        var n = [];
        t.forEach(function (o) {
          typeof o == "number"
            ? n.push(60 * o * 60)
            : typeof o == "string" &&
              o
                .split("-")
                .map(function (l) {
                  return l.trim();
                })
                .forEach(function (l) {
                  var d = l.split(":").map(function (u) {
                      return u.trim();
                    }),
                    c = parseInt(60 * d[0] * 60);
                  d[1] && (c += parseInt(60 * d[1])),
                    d[2] && (c += parseInt(d[2])),
                    n.push(c);
                });
        });
        for (var e = [], i = 0; i < n.length; i += 2) {
          var a = n[i],
            r = n[i + 1],
            s = r - a;
          e.push({
            start: a,
            end: r,
            startHour: Math.floor(a / 3600),
            startMinute: Math.floor(a / 60),
            endHour: Math.ceil(r / 3600),
            endMinute: Math.ceil(r / 60),
            durationSeconds: s,
            durationMinutes: s / 60,
            durationHours: s / 3600,
          });
        }
        return e;
      }
      return t;
    },
    setWorkTime: function (t) {
      return this._tryChangeCalendarSettings(
        z(function () {
          var n = t.hours === void 0 || t.hours,
            e = this._timestamp(t),
            i = this.getConfig();
          if (
            (e !== null ? (i.dates[e] = n) : t.customWeeks || (i.hours = n),
            t.customWeeks)
          ) {
            if (
              (i.customWeeks || (i.customWeeks = {}),
              typeof t.customWeeks == "string")
            )
              e !== null
                ? (i.customWeeks[t.customWeeks].dates[e] = n)
                : t.customWeeks || (i.customWeeks[t.customWeeks].hours = n);
            else if (
              typeof t.customWeeks == "object" &&
              t.customWeeks.constructor === Object
            )
              for (var a in t.customWeeks) i.customWeeks[a] = t.customWeeks[a];
          }
          this._parseSettings(), this._clearCaches();
        }, this)
      );
    },
    unsetWorkTime: function (t) {
      return this._tryChangeCalendarSettings(
        z(function () {
          if (t) {
            var n = this._timestamp(t);
            n !== null && delete this.getConfig().dates[n];
          } else this.reset_calendar();
          this._parseSettings(), this._clearCaches();
        }, this)
      );
    },
    _isWorkTime: function (t, n) {
      var e,
        i = -1;
      return (
        (e = String(t.valueOf())),
        (i = this._workingUnitsCache.getItem(n, e, t)) == -1 &&
          ((i = this._checkIfWorkingUnit(t, n)),
          this._workingUnitsCache.setItem(n, e, i, t)),
        i
      );
    },
    isWorkTime: function () {
      var t = this.argumentsHelper.isWorkTimeArguments.apply(
        this.argumentsHelper,
        arguments
      );
      return this._isWorkTime(t.date, t.unit);
    },
    calculateDuration: function () {
      var t = this.argumentsHelper.getDurationArguments.apply(
        this.argumentsHelper,
        arguments
      );
      if (!t.unit) return !1;
      var n = this;
      return this._dateDurationCache.getDuration(
        t.start_date,
        t.end_date,
        t.unit,
        t.step,
        function () {
          return n._calculateDuration(t.start_date, t.end_date, t.unit, t.step);
        }
      );
    },
    _calculateDuration: function (t, n, e, i) {
      var a = 0,
        r = 1;
      if (t.valueOf() > n.valueOf()) {
        var s = n;
        (n = t), (t = s), (r = -1);
      }
      return (
        (a =
          e == "hour" && i == 1
            ? this._getHoursBetween(t, n, e, i)
            : e == "minute" && i == 1
            ? this._getMinutesBetween(t, n, e, i)
            : this._getWorkUnitsBetweenGeneric(t, n, e, i)),
        r * Math.round(a)
      );
    },
    hasDuration: function () {
      var t = this.argumentsHelper.getDurationArguments.apply(
          this.argumentsHelper,
          arguments
        ),
        n = t.start_date,
        e = t.end_date,
        i = t.unit,
        a = t.step;
      if (!i) return !1;
      var r = new Date(n),
        s = new Date(e);
      for (a = a || 1; r.valueOf() < s.valueOf(); ) {
        if (this._isWorkTime(r, i)) return !0;
        r = this._nextDate(r, i, a);
      }
      return !1;
    },
    calculateEndDate: function () {
      var t = this.argumentsHelper.calculateEndDateArguments.apply(
          this.argumentsHelper,
          arguments
        ),
        n = t.start_date,
        e = t.duration,
        i = t.unit,
        a = t.step;
      if (!i) return !1;
      var r = t.duration >= 0 ? 1 : -1;
      e = Math.abs(1 * e);
      var s = this;
      return this._dateDurationCache.getEndDate(n, e, i, a * r, function () {
        return s._calculateEndDate(n, e, i, a * r);
      });
    },
    _calculateEndDate: function (t, n, e, i) {
      return (
        !!e &&
        (i == 1 && e == "minute"
          ? this._calculateMinuteEndDate(t, n, i)
          : i == -1 && e == "minute"
          ? this._subtractMinuteDate(t, n, i)
          : i == 1 && e == "hour"
          ? this._calculateHourEndDate(t, n, i)
          : this._addInterval(t, n, e, i, null).end)
      );
    },
    _addInterval: function (t, n, e, i, a) {
      for (var r = 0, s = t, o = !1; r < n && (!a || !a(s)); ) {
        var l = this._nextDate(s, e, i);
        e == "day" &&
          (o = o || (!s.getHours() && l.getHours())) &&
          (l.setHours(0), l.getHours() || (o = !1));
        var d = new Date(l.valueOf() + 1);
        i > 0 && (d = new Date(l.valueOf() - 1)),
          this._isWorkTime(d, e) && !o && r++,
          (s = l);
      }
      return { end: s, start: t, added: r };
    },
    _addHoursUntilDayEnd: function (t, n) {
      for (
        var e = this.$gantt.date.add(
            this.$gantt.date.day_start(new Date(t)),
            1,
            "day"
          ),
          i = 0,
          a = n,
          r = this._getIntervalTimestamp(t, e),
          s = this._getWorkHours(t),
          o = 0;
        o < s.length && i < n;
        o++
      ) {
        var l = s[o];
        if (r.end >= l.start && r.start <= l.end) {
          var d = Math.max(l.start, r.start),
            c = Math.min(l.end, r.end),
            u = (c - d) / 3600;
          u > a && ((u = a), (c = d + 60 * a * 60));
          var h = Math.round((c - d) / 3600);
          (i += h), (a -= h), (r.start = c);
        }
      }
      var _ = e;
      return (
        i === n &&
          (_ = new Date(
            t.getFullYear(),
            t.getMonth(),
            t.getDate(),
            0,
            0,
            r.start
          )),
        { added: i, end: _ }
      );
    },
    _calculateHourEndDate: function (t, n, e) {
      var i = new Date(t),
        a = 0;
      (e = e || 1), (n = Math.abs(1 * n));
      var r = this._addHoursUntilDayEnd(i, n);
      if (((a = r.added), (i = r.end), (d = n - a))) {
        for (var s = i; a < n; ) {
          var o = this._nextDate(s, "day", e);
          o.setHours(0), o.setMinutes(0), o.setSeconds(0);
          var l = 0;
          if (
            a +
              (l =
                e > 0
                  ? this.getHoursPerDay(new Date(o.valueOf() - 1))
                  : this.getHoursPerDay(new Date(o.valueOf() + 1))) >=
            n
          )
            break;
          (a += l), (s = o);
        }
        i = s;
      }
      if (a < n) {
        var d = n - a;
        i = (r = this._addHoursUntilDayEnd(i, d)).end;
      }
      return i;
    },
    _addMinutesUntilHourEnd: function (t, n) {
      if (t.getMinutes() === 0) return { added: 0, end: new Date(t) };
      for (
        var e = this.$gantt.date.add(
            this.$gantt.date.hour_start(new Date(t)),
            1,
            "hour"
          ),
          i = 0,
          a = n,
          r = this._getIntervalTimestamp(t, e),
          s = this._getWorkHours(t),
          o = 0;
        o < s.length && i < n;
        o++
      ) {
        var l = s[o];
        if (r.end >= l.start && r.start <= l.end) {
          var d = Math.max(l.start, r.start),
            c = Math.min(l.end, r.end),
            u = (c - d) / 60;
          u > a && ((u = a), (c = d + 60 * a));
          var h = Math.round((c - d) / 60);
          (a -= h), (i += h), (r.start = c);
        }
      }
      var _ = e;
      return (
        i === n &&
          (_ = new Date(
            t.getFullYear(),
            t.getMonth(),
            t.getDate(),
            0,
            0,
            r.start
          )),
        { added: i, end: _ }
      );
    },
    _subtractMinutesUntilHourStart: function (t, n) {
      for (
        var e = this.$gantt.date.hour_start(new Date(t)),
          i = 0,
          a = n,
          r = 60 * e.getHours() * 60 + 60 * e.getMinutes() + e.getSeconds(),
          s = 60 * t.getHours() * 60 + 60 * t.getMinutes() + t.getSeconds(),
          o = this._getWorkHours(t),
          l = o.length - 1;
        l >= 0 && i < n;
        l--
      ) {
        var d = o[l];
        if (s > d.start && r <= d.end) {
          var c = Math.min(s, d.end),
            u = Math.max(r, d.start),
            h = (c - u) / 60;
          h > a && ((h = a), (u = c - 60 * a));
          var _ = Math.abs(Math.round((c - u) / 60));
          (a -= _), (i += _), (s = u);
        }
      }
      var f = e;
      return (
        i === n &&
          (f = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, 0, s)),
        { added: i, end: f }
      );
    },
    _subtractMinuteDate: function (t, n, e) {
      var i = this.getClosestWorkTime({ date: t, dir: "past", unit: "minute" }),
        a = 0;
      (e = e || -1), (n = Math.abs(1 * n)), (n = Math.round(n));
      const r = this._isMinutePrecision(i);
      let s = this._subtractMinutesUntilHourStart(i, n);
      (a += s.added), (i = s.end);
      for (var o = 0, l = [], d = 0; a < n; ) {
        var c = this.$gantt.date.day_start(new Date(i)),
          u = !1;
        i.valueOf() === c.valueOf() &&
          ((c = this.$gantt.date.add(c, -1, "day")), (u = !0));
        var h = new Date(
          c.getFullYear(),
          c.getMonth(),
          c.getDate(),
          23,
          59,
          59,
          999
        ).valueOf();
        h !== o &&
          ((l = this._getWorkHours(c)),
          (d = this._getMinutesPerDay(c)),
          (o = h));
        var _ = n - a,
          f = this._getTimeOfDayStamp(i, u);
        if (l.length && d)
          if (l[l.length - 1].end <= f && _ > d)
            (a += d), (i = this.$gantt.date.add(i, -1, "day"));
          else {
            for (var y = !1, v = null, b = null, g = l.length - 1; g >= 0; g--)
              if (l[g].start < f - 1 && l[g].end >= f - 1) {
                (y = !0), (v = l[g]), (b = l[g - 1]);
                break;
              }
            if (y)
              if (f === v.end && _ >= v.durationMinutes)
                (a += v.durationMinutes),
                  (i = this.$gantt.date.add(i, -v.durationMinutes, "minute"));
              else if (!r && _ <= f / 60 - v.startMinute)
                (a += _), (i = this.$gantt.date.add(i, -_, "minute"));
              else if (r)
                _ <= f / 60 - v.startMinute
                  ? ((a += _), (i = this.$gantt.date.add(i, -_, "minute")))
                  : ((a += f / 60 - v.startMinute),
                    (i = b
                      ? new Date(
                          i.getFullYear(),
                          i.getMonth(),
                          i.getDate(),
                          0,
                          0,
                          b.end
                        )
                      : this.$gantt.date.day_start(i)));
              else {
                var m = this._getMinutesPerHour(i);
                m <= _
                  ? ((a += m), (i = this._nextDate(i, "hour", e)))
                  : ((s = this._subtractMinutesUntilHourStart(i, _)),
                    (a += s.added),
                    (i = s.end));
              }
            else if (
              i.getHours() === 0 &&
              i.getMinutes() === 0 &&
              i.getSeconds() === 0
            ) {
              if (
                (p = this._getClosestWorkTimePast(i, "hour")).valueOf() ===
                i.valueOf()
              ) {
                var p = this.$gantt.date.add(i, -1, "day"),
                  k = this._getWorkHours(p);
                if (k.length) {
                  var w = k[k.length - 1];
                  p.setSeconds(w.durationSeconds);
                }
              }
              i = p;
            } else i = this._getClosestWorkTimePast(new Date(i - 1), "hour");
          }
        else i = this.$gantt.date.add(i, -1, "day");
      }
      if (a < n) {
        var x = n - a;
        (s = this._subtractMinutesUntilHourStart(i, x)),
          (a += s.added),
          (i = s.end);
      }
      return i;
    },
    _calculateMinuteEndDate: function (t, n, e) {
      var i = new Date(t),
        a = 0;
      (e = e || 1), (n = Math.abs(1 * n)), (n = Math.round(n));
      var r = this._addMinutesUntilHourEnd(i, n);
      (a += r.added), (i = r.end);
      for (var s = 0, o = [], l = 0, d = this._isMinutePrecision(i); a < n; ) {
        var c = this.$gantt.date.day_start(new Date(i)).valueOf();
        c !== s &&
          ((o = this._getWorkHours(i)),
          (l = this._getMinutesPerDay(i)),
          (s = c));
        var u = n - a,
          h = this._getTimeOfDayStamp(i);
        if (o.length && l)
          if (o[0].start >= h && u >= l) {
            if (((a += l), u == l)) {
              i = new Date(
                i.getFullYear(),
                i.getMonth(),
                i.getDate(),
                0,
                0,
                o[o.length - 1].end
              );
              break;
            }
            (i = this.$gantt.date.add(i, 1, "day")),
              (i = this.$gantt.date.day_start(i));
          } else {
            for (var _ = !1, f = null, y = 0; y < o.length; y++)
              if (o[y].start <= h && o[y].end > h) {
                (_ = !0), (f = o[y]);
                break;
              }
            if (_)
              if (h === f.start && u >= f.durationMinutes)
                (a += f.durationMinutes),
                  (i = this.$gantt.date.add(i, f.durationMinutes, "minute"));
              else if (u <= f.endMinute - h / 60)
                (a += u), (i = this.$gantt.date.add(i, u, "minute"));
              else {
                var v = this._getMinutesPerHour(i);
                v <= u
                  ? ((a += v),
                    (i = d
                      ? this.$gantt.date.add(i, v, "minute")
                      : this._nextDate(i, "hour", e)))
                  : ((a += (r = this._addMinutesUntilHourEnd(i, u)).added),
                    (i = r.end));
              }
            else i = this._getClosestWorkTimeFuture(i, "hour");
          }
        else i = this.$gantt.date.add(this.$gantt.date.day_start(i), 1, "day");
      }
      if (a < n) {
        var b = n - a;
        (a += (r = this._addMinutesUntilHourEnd(i, b)).added), (i = r.end);
      }
      return i;
    },
    getClosestWorkTime: function () {
      var t = this.argumentsHelper.getClosestWorkTimeArguments.apply(
        this.argumentsHelper,
        arguments
      );
      return this._getClosestWorkTime(t.date, t.unit, t.dir);
    },
    _getClosestWorkTime: function (t, n, e) {
      var i = new Date(t);
      if (this._isWorkTime(i, n)) return i;
      if (((i = this.$gantt.date[n + "_start"](i)), e != "any" && e))
        i =
          e == "past"
            ? this._getClosestWorkTimePast(i, n)
            : this._getClosestWorkTimeFuture(i, n);
      else {
        var a = this._getClosestWorkTimeFuture(i, n),
          r = this._getClosestWorkTimePast(i, n);
        i = Math.abs(a - t) <= Math.abs(t - r) ? a : r;
      }
      return i;
    },
    _getClosestWorkTimeFuture: function (t, n) {
      return this._getClosestWorkTimeGeneric(t, n, 1);
    },
    _getClosestWorkTimePast: function (t, n) {
      var e = this._getClosestWorkTimeGeneric(t, n, -1);
      return this.$gantt.date.add(e, 1, n);
    },
    _findClosestTimeInDay: function (t, n, e) {
      var i = new Date(t),
        a = null,
        r = !1;
      this._getWorkHours(i).length ||
        ((i = this._getClosestWorkTime(i, "day", n < 0 ? "past" : "future")),
        n < 0 && ((i = new Date(i.valueOf() - 1)), (r = !0)),
        (e = this._getWorkHours(i)));
      var s = this._getTimeOfDayStamp(i);
      if (
        (r && (s = this._getTimeOfDayStamp(new Date(i.valueOf() + 1), r)),
        n > 0)
      ) {
        for (var o = 0; o < e.length; o++)
          if (e[o].start >= s) {
            a = new Date(
              i.getFullYear(),
              i.getMonth(),
              i.getDate(),
              0,
              0,
              e[o].start
            );
            break;
          }
      } else
        for (o = e.length - 1; o >= 0; o--) {
          if (e[o].end <= s) {
            a = new Date(
              i.getFullYear(),
              i.getMonth(),
              i.getDate(),
              0,
              0,
              e[o].end
            );
            break;
          }
          if (e[o].end > s && e[o].start <= s) {
            a = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, s);
            break;
          }
        }
      return a;
    },
    _getClosestWorkMinute: function (t, n, e) {
      var i = new Date(t),
        a = this._getWorkHours(i),
        r = this._findClosestTimeInDay(i, e, a);
      return (
        r ||
          (e > 0
            ? ((i = this.calculateEndDate(i, e, n)),
              (i = this.$gantt.date.day_start(i)))
            : ((i = this.calculateEndDate(i, e, "day")),
              (i = this.$gantt.date.day_start(i)),
              (i = this.$gantt.date.add(i, 1, "day")),
              (i = new Date(i.valueOf() - 1))),
          (a = this._getWorkHours(i)),
          (r = this._findClosestTimeInDay(i, e, a))),
        e < 0 && (r = this.$gantt.date.add(r, -1, n)),
        r
      );
    },
    _getClosestWorkTimeGeneric: function (t, n, e) {
      if (n === "hour" || n === "minute")
        return this._getClosestWorkMinute(t, n, e);
      for (
        var i = this._getUnitOrder(n), a = this.units[i - 1], r = t, s = 0;
        !this._isWorkTime(r, n) &&
        (!a ||
          this._isWorkTime(r, a) ||
          ((r =
            e > 0
              ? this._getClosestWorkTimeFuture(r, a)
              : this._getClosestWorkTimePast(r, a)),
          !this._isWorkTime(r, n)));

      ) {
        if (++s > 3e3)
          return this.$gantt.assert(!1, "Invalid working time check"), !1;
        var o = r.getTimezoneOffset();
        (r = this.$gantt.date.add(r, e, n)),
          (r = this.$gantt._correct_dst_change(r, o, e, n)),
          this.$gantt.date[n + "_start"] &&
            (r = this.$gantt.date[n + "_start"](r));
      }
      return r;
    },
    hasWorkTime: function () {
      var t = this.getConfig(),
        n = t.dates;
      for (var e in t.dates);
      var i = this._checkWorkHours(t.hours),
        a = !1;
      return (
        [0, 1, 2, 3, 4, 5, 6].forEach(
          function (r) {
            if (!a) {
              var s = n[r];
              s === !0
                ? (a = i)
                : Array.isArray(s) && (a = this._checkWorkHours(s));
            }
          }.bind(this)
        ),
        a
      );
    },
    _checkWorkHours: function (t) {
      if (t.length === 0) return !1;
      for (var n = !1, e = 0; e < t.length; e += 2)
        t[e] !== t[e + 1] && (n = !0);
      return n;
    },
    _isMinutePrecision: function (t) {
      let n = !1;
      return (
        this._getWorkHours(t).forEach(function (e) {
          (e.startMinute % 60 || e.endMinute % 60) && (n = !0);
        }),
        n
      );
    },
  };
  const Wt = {
      isLegacyResourceCalendarFormat: function (t) {
        if (!t) return !1;
        for (var n in t) if (t[n] && typeof t[n] == "object") return !0;
        return !1;
      },
      getResourceProperty: function (t) {
        var n = t.resource_calendars,
          e = t.resource_property;
        if (this.isLegacyResourceCalendarFormat(n))
          for (var i in t) {
            e = i;
            break;
          }
        return e;
      },
      getCalendarIdFromLegacyConfig: function (t, n) {
        if (n)
          for (var e in n) {
            var i = n[e];
            if (t[e]) {
              var a = i[t[e]];
              if (a) return a;
            }
          }
        return null;
      },
    },
    Qi =
      ((ie = {}),
      {
        getCalendarIdFromMultipleResources: function (t, n) {
          var e = (function (a) {
            return a
              .map(function (r) {
                return r && r.resource_id ? r.resource_id : r;
              })
              .sort()
              .join("-");
          })(t);
          if (t.length) {
            if (t.length === 1) return n.getResourceCalendar(e).id;
            if (ie[e]) return ie[e].id;
            var i = (function (a, r) {
              return r.mergeCalendars(
                a.map(function (s) {
                  var o = s && s.resource_id ? s.resource_id : s;
                  return r.getResourceCalendar(o);
                })
              );
            })(t, n);
            return (ie[e] = i), n.addCalendar(i);
          }
          return null;
        },
      });
  var ie;
  function On(t) {
    (this.$gantt = t),
      (this._calendars = {}),
      (this._legacyConfig = void 0),
      this.$gantt.attachEvent(
        "onGanttReady",
        function () {
          this.$gantt.config.resource_calendars &&
            (this._isLegacyConfig = Wt.isLegacyResourceCalendarFormat(
              this.$gantt.config.resource_calendars
            ));
        }.bind(this)
      ),
      this.$gantt.attachEvent(
        "onBeforeGanttReady",
        function () {
          this.createDefaultCalendars();
        }.bind(this)
      ),
      this.$gantt.attachEvent(
        "onBeforeGanttRender",
        function () {
          this.createDefaultCalendars();
        }.bind(this)
      );
  }
  function ze(t, n) {
    (this.argumentsHelper = n), (this.$gantt = t);
  }
  function Bn(t) {
    (this.$gantt = t.$gantt),
      (this.argumentsHelper = Rn(this.$gantt)),
      (this.calendarManager = t),
      (this.$disabledCalendar = new ze(this.$gantt, this.argumentsHelper));
  }
  (On.prototype = {
    _calendars: {},
    _convertWorkTimeSettings: function (t) {
      var n = t.days;
      if (n && !t.dates) {
        t.dates = t.dates || {};
        for (var e = 0; e < n.length; e++)
          (t.dates[e] = n[e]), n[e] instanceof Array || (t.dates[e] = !!n[e]);
      }
      return delete t.days, t;
    },
    mergeCalendars: function () {
      var t = [],
        n = arguments;
      if (Array.isArray(n[0])) t = n[0].slice();
      else for (var e = 0; e < arguments.length; e++) t.push(arguments[e]);
      var i,
        a = new Hn();
      return (
        t.forEach(
          function (r) {
            i = i ? this._createCalendarFromConfig(a.merge(i, r)) : r;
          }.bind(this)
        ),
        this.createCalendar(i)
      );
    },
    _createCalendarFromConfig: function (t) {
      var n = new Be(this.$gantt, Rn(this.$gantt));
      n.id = String(ut());
      var e = this._convertWorkTimeSettings(t);
      if (e.customWeeks)
        for (var i in e.customWeeks)
          e.customWeeks[i] = this._convertWorkTimeSettings(e.customWeeks[i]);
      return n._setConfig(e), n;
    },
    createCalendar: function (t) {
      var n;
      return (
        t || (t = {}),
        O(
          (n = t.getConfig
            ? X(t.getConfig())
            : t.worktime
            ? X(t.worktime)
            : X(t)),
          X(this.defaults.fulltime.worktime)
        ),
        this._createCalendarFromConfig(n)
      );
    },
    getCalendar: function (t) {
      t = t || "global";
      var n = this._calendars[t];
      return n || (this.createDefaultCalendars(), (n = this._calendars[t])), n;
    },
    getCalendars: function () {
      var t = [];
      for (var n in this._calendars) t.push(this.getCalendar(n));
      return t;
    },
    _getOwnCalendar: function (t) {
      var n = this.$gantt.config;
      if (t[n.calendar_property])
        return this.getCalendar(t[n.calendar_property]);
      if (n.resource_calendars) {
        var e;
        if (
          ((e =
            this._legacyConfig === !1
              ? n.resource_property
              : Wt.getResourceProperty(n)),
          Array.isArray(t[e]) && t[e].length)
        )
          n.dynamic_resource_calendars
            ? (i = Qi.getCalendarIdFromMultipleResources(t[e], this))
            : (a = this.getResourceCalendar(t[e]));
        else if (
          (this._legacyConfig === void 0 &&
            (this._legacyConfig = Wt.isLegacyResourceCalendarFormat(
              n.resource_calendars
            )),
          this._legacyConfig)
        )
          var i = Wt.getCalendarIdFromLegacyConfig(t, n.resource_calendars);
        else if (e && t[e] && n.resource_calendars[t[e]])
          var a = this.getResourceCalendar(t[e]);
        if ((i && (a = this.getCalendar(i)), a)) return a;
      }
      return null;
    },
    getResourceCalendar: function (t) {
      if (t == null) return this.getCalendar();
      var n = null;
      n = typeof t == "number" || typeof t == "string" ? t : t.id || t.key;
      var e = this.$gantt.config,
        i = e.resource_calendars,
        a = null;
      if (
        (Array.isArray(t) &&
          t.length === 1 &&
          (n = typeof t[0] == "object" ? t[0].resource_id : t[0]),
        i)
      ) {
        if (
          (this._legacyConfig === void 0 &&
            (this._legacyConfig = Wt.isLegacyResourceCalendarFormat(
              e.resource_calendars
            )),
          this._legacyConfig)
        ) {
          for (var r in i)
            if (i[r][n]) {
              a = i[r][n];
              break;
            }
        } else a = i[n];
        if (a) return this.getCalendar(a);
      }
      return this.getCalendar();
    },
    getTaskCalendar: function (t) {
      var n,
        e = this.$gantt;
      if (t == null) return this.getCalendar();
      if (
        !(n =
          (typeof t != "number" && typeof t != "string") || !e.isTaskExists(t)
            ? t
            : e.getTask(t))
      )
        return this.getCalendar();
      var i = this._getOwnCalendar(n),
        a = !!e.getState().group_mode;
      if (!i && e.config.inherit_calendar && e.isTaskExists(n.parent)) {
        for (
          var r = n;
          e.isTaskExists(r.parent) &&
          ((r = e.getTask(r.parent)),
          !e.isSummaryTask(r) || !(i = this._getOwnCalendar(r)));

        );
        a &&
          !i &&
          t.$effective_calendar &&
          (i = this.getCalendar(t.$effective_calendar));
      }
      return i || this.getCalendar();
    },
    addCalendar: function (t) {
      if (!this.isCalendar(t)) {
        var n = t.id;
        (t = this.createCalendar(t)).id = n;
      }
      if (t._tryChangeCalendarSettings(function () {})) {
        var e = this.$gantt.config;
        return (
          (t.id = t.id || ut()),
          (this._calendars[t.id] = t),
          e.worktimes || (e.worktimes = {}),
          (e.worktimes[t.id] = t.getConfig()),
          t.id
        );
      }
      return (
        this.$gantt.callEvent("onCalendarError", [
          { message: "Invalid calendar settings, no worktime available" },
          t,
        ]),
        null
      );
    },
    deleteCalendar: function (t) {
      var n = this.$gantt.config;
      return (
        !!t &&
        !!this._calendars[t] &&
        (delete this._calendars[t],
        n.worktimes && n.worktimes[t] && delete n.worktimes[t],
        !0)
      );
    },
    restoreConfigCalendars: function (t) {
      for (var n in t)
        if (!this._calendars[n]) {
          var e = t[n],
            i = this.createCalendar(e);
          (i.id = n), this.addCalendar(i);
        }
    },
    defaults: {
      global: {
        id: "global",
        worktime: { hours: [8, 12, 13, 17], days: [0, 1, 1, 1, 1, 1, 0] },
      },
      fulltime: {
        id: "fulltime",
        worktime: { hours: [0, 24], days: [1, 1, 1, 1, 1, 1, 1] },
      },
    },
    createDefaultCalendars: function () {
      var t = this.$gantt.config;
      this.restoreConfigCalendars(this.defaults),
        this.restoreConfigCalendars(t.worktimes);
    },
    isCalendar: function (t) {
      return [
        t.isWorkTime,
        t.setWorkTime,
        t.getWorkHours,
        t.unsetWorkTime,
        t.getClosestWorkTime,
        t.calculateDuration,
        t.hasDuration,
        t.calculateEndDate,
      ].every(function (n) {
        return n instanceof Function;
      });
    },
  }),
    (ze.prototype = {
      getWorkHours: function () {
        return [0, 24];
      },
      setWorkTime: function () {
        return !0;
      },
      unsetWorkTime: function () {
        return !0;
      },
      isWorkTime: function () {
        return !0;
      },
      getClosestWorkTime: function (t) {
        return this.argumentsHelper.getClosestWorkTimeArguments.apply(
          this.argumentsHelper,
          arguments
        ).date;
      },
      calculateDuration: function () {
        var t = this.argumentsHelper.getDurationArguments.apply(
            this.argumentsHelper,
            arguments
          ),
          n = t.start_date,
          e = t.end_date,
          i = t.unit,
          a = t.step;
        return this._calculateDuration(n, e, i, a);
      },
      _calculateDuration: function (t, n, e, i) {
        var a = this.$gantt.date,
          r = { week: 6048e5, day: 864e5, hour: 36e5, minute: 6e4 },
          s = 0;
        if (r[e]) s = Math.round((n - t) / (i * r[e]));
        else {
          for (
            var o = new Date(t), l = new Date(n);
            o.valueOf() < l.valueOf();

          )
            (s += 1), (o = a.add(o, i, e));
          o.valueOf() != n.valueOf() && (s += (l - o) / (a.add(o, i, e) - o));
        }
        return Math.round(s);
      },
      hasDuration: function () {
        var t = this.argumentsHelper.getDurationArguments.apply(
            this.argumentsHelper,
            arguments
          ),
          n = t.start_date,
          e = t.end_date;
        return (
          !!t.unit &&
          ((n = new Date(n)), (e = new Date(e)), n.valueOf() < e.valueOf())
        );
      },
      hasWorkTime: function () {
        return !0;
      },
      equals: function (t) {
        return t instanceof ze;
      },
      calculateEndDate: function () {
        var t = this.argumentsHelper.calculateEndDateArguments.apply(
            this.argumentsHelper,
            arguments
          ),
          n = t.start_date,
          e = t.duration,
          i = t.unit,
          a = t.step;
        return this.$gantt.date.add(n, a * e, i);
      },
    }),
    (Bn.prototype = {
      _getCalendar: function (t) {
        var n;
        if (this.$gantt.config.work_time) {
          var e = this.calendarManager;
          t.task
            ? (n = e.getTaskCalendar(t.task))
            : t.id
            ? (n = e.getTaskCalendar(t))
            : t.calendar && (n = t.calendar),
            n || (n = e.getTaskCalendar());
        } else n = this.$disabledCalendar;
        return n;
      },
      getWorkHours: function (t) {
        return (
          (t = this.argumentsHelper.getWorkHoursArguments.apply(
            this.argumentsHelper,
            arguments
          )),
          this._getCalendar(t).getWorkHours(t.date)
        );
      },
      setWorkTime: function (t, n) {
        return (
          (t = this.argumentsHelper.setWorkTimeArguments.apply(
            this.argumentsHelper,
            arguments
          )),
          n || (n = this.calendarManager.getCalendar()),
          n.setWorkTime(t)
        );
      },
      unsetWorkTime: function (t, n) {
        return (
          (t = this.argumentsHelper.unsetWorkTimeArguments.apply(
            this.argumentsHelper,
            arguments
          )),
          n || (n = this.calendarManager.getCalendar()),
          n.unsetWorkTime(t)
        );
      },
      isWorkTime: function (t, n, e, i) {
        var a = this.argumentsHelper.isWorkTimeArguments.apply(
          this.argumentsHelper,
          arguments
        );
        return (i = this._getCalendar(a)).isWorkTime(a);
      },
      getClosestWorkTime: function (t) {
        return (
          (t = this.argumentsHelper.getClosestWorkTimeArguments.apply(
            this.argumentsHelper,
            arguments
          )),
          this._getCalendar(t).getClosestWorkTime(t)
        );
      },
      calculateDuration: function () {
        var t = this.argumentsHelper.getDurationArguments.apply(
          this.argumentsHelper,
          arguments
        );
        return this._getCalendar(t).calculateDuration(t);
      },
      hasDuration: function () {
        var t = this.argumentsHelper.hasDurationArguments.apply(
          this.argumentsHelper,
          arguments
        );
        return this._getCalendar(t).hasDuration(t);
      },
      calculateEndDate: function (t) {
        return (
          (t = this.argumentsHelper.calculateEndDateArguments.apply(
            this.argumentsHelper,
            arguments
          )),
          this._getCalendar(t).calculateEndDate(t)
        );
      },
    });
  const ta = function (t, n) {
    return {
      getWorkHours: function (e) {
        return n.getWorkHours(e);
      },
      setWorkTime: function (e) {
        return n.setWorkTime(e);
      },
      unsetWorkTime: function (e) {
        n.unsetWorkTime(e);
      },
      isWorkTime: function (e, i, a) {
        return n.isWorkTime(e, i, a);
      },
      getClosestWorkTime: function (e) {
        return n.getClosestWorkTime(e);
      },
      calculateDuration: function (e, i, a) {
        return n.calculateDuration(e, i, a);
      },
      _hasDuration: function (e, i, a) {
        return n.hasDuration(e, i, a);
      },
      calculateEndDate: function (e, i, a, r) {
        return n.calculateEndDate(e, i, a, r);
      },
      mergeCalendars: z(t.mergeCalendars, t),
      createCalendar: z(t.createCalendar, t),
      addCalendar: z(t.addCalendar, t),
      getCalendar: z(t.getCalendar, t),
      getCalendars: z(t.getCalendars, t),
      getResourceCalendar: z(t.getResourceCalendar, t),
      getTaskCalendar: z(t.getTaskCalendar, t),
      deleteCalendar: z(t.deleteCalendar, t),
    };
  };
  function ea(t) {
    (t.isUnscheduledTask = function (s) {
      return (
        t.assert(
          s && s instanceof Object,
          "Invalid argument <b>task</b>=" +
            s +
            " of gantt.isUnscheduledTask. Task object was expected"
        ),
        !!s.unscheduled || !s.start_date
      );
    }),
      (t._isAllowedUnscheduledTask = function (s) {
        return !(!s.unscheduled || !t.config.show_unscheduled);
      }),
      (t._isTaskInTimelineLimits = function (s) {
        var o = s.start_date ? s.start_date.valueOf() : null,
          l = s.end_date ? s.end_date.valueOf() : null;
        return !!(
          o &&
          l &&
          o <= this._max_date.valueOf() &&
          l >= this._min_date.valueOf()
        );
      }),
      (t.isTaskVisible = function (s) {
        if (!this.isTaskExists(s)) return !1;
        var o = this.getTask(s);
        return (
          !(
            !this._isAllowedUnscheduledTask(o) &&
            !this._isTaskInTimelineLimits(o)
          ) && this.getGlobalTaskIndex(s) >= 0
        );
      }),
      (t._getProjectEnd = function () {
        if (t.config.project_end) return t.config.project_end;
        var s = t.getTaskByTime();
        return (s = s.sort(function (o, l) {
          return +o.end_date > +l.end_date ? 1 : -1;
        })).length
          ? s[s.length - 1].end_date
          : null;
      }),
      (t._getProjectStart = function () {
        if (t.config.project_start) return t.config.project_start;
        if (t.config.start_date) return t.config.start_date;
        if (t.getState().min_date) return t.getState().min_date;
        var s = t.getTaskByTime();
        return (s = s.sort(function (o, l) {
          return +o.start_date > +l.start_date ? 1 : -1;
        })).length
          ? s[0].start_date
          : null;
      });
    var n = function (s, o) {
      var l =
          !!(o && o != t.config.root_id && t.isTaskExists(o)) && t.getTask(o),
        d = null;
      if (l)
        if (t.config.schedule_from_end)
          d = t.calculateEndDate({
            start_date: l.end_date,
            duration: -t.config.duration_step,
            task: s,
          });
        else {
          if (!l.start_date) return n(l, t.getParent(l));
          d = l.start_date;
        }
      else if (t.config.schedule_from_end)
        d = t.calculateEndDate({
          start_date: t._getProjectEnd(),
          duration: -t.config.duration_step,
          task: s,
        });
      else {
        const c = t.getTaskByIndex(0),
          u = t.config.start_date || t.getState().min_date;
        d = c
          ? c.start_date
            ? c.start_date
            : c.end_date
            ? t.calculateEndDate({
                start_date: c.end_date,
                duration: -t.config.duration_step,
                task: s,
              })
            : u
          : u;
      }
      return t.assert(d, "Invalid dates"), new Date(d);
    };
    (t._set_default_task_timing = function (s) {
      (s.start_date = s.start_date || n(s, t.getParent(s))),
        (s.duration = s.duration || t.config.duration_step),
        (s.end_date = s.end_date || t.calculateEndDate(s));
    }),
      (t.createTask = function (s, o, l) {
        if (
          ((s = s || {}),
          t.defined(s.id) || (s.id = t.uid()),
          s.start_date || (s.start_date = n(s, o)),
          s.text === void 0 && (s.text = t.locale.labels.new_task),
          s.duration === void 0 && (s.duration = 1),
          this.isTaskExists(o))
        ) {
          this.setParent(s, o, !0);
          var d = this.getTask(o);
          (d.$open = !0),
            this.config.details_on_create ||
              this.callEvent("onAfterParentExpand", [o, d]);
        }
        return this.callEvent("onTaskCreated", [s])
          ? (this.config.details_on_create
              ? (t.isTaskExists(s.id)
                  ? t.getTask(s.id).$index != s.$index &&
                    (s.start_date &&
                      typeof s.start_date == "string" &&
                      (s.start_date = this.date.parseDate(
                        s.start_date,
                        "parse_date"
                      )),
                    s.end_date &&
                      typeof s.end_date == "string" &&
                      (s.end_date = this.date.parseDate(
                        s.end_date,
                        "parse_date"
                      )),
                    this.$data.tasksStore.updateItem(s.id, s))
                  : ((s.$new = !0),
                    this.silent(function () {
                      t.$data.tasksStore.addItem(s, l);
                    })),
                this.selectTask(s.id),
                this.refreshData(),
                this.showLightbox(s.id))
              : this.addTask(s, o, l) &&
                (this.showTask(s.id), this.selectTask(s.id)),
            s.id)
          : null;
      }),
      (t._update_flags = function (s, o) {
        var l = t.$data.tasksStore;
        s === void 0
          ? ((this._lightbox_id = null),
            l.silent(function () {
              l.unselect();
            }),
            this.getSelectedTasks && this._multiselect.reset(),
            this._tasks_dnd &&
              this._tasks_dnd.drag &&
              (this._tasks_dnd.drag.id = null))
          : (this._lightbox_id == s && (this._lightbox_id = o),
            l.getSelectedId() == s &&
              l.silent(function () {
                l.unselect(s), l.select(o);
              }),
            this._tasks_dnd &&
              this._tasks_dnd.drag &&
              this._tasks_dnd.drag.id == s &&
              (this._tasks_dnd.drag.id = o));
      });
    var e = function (s, o) {
      var l = t.getTaskType(s.type),
        d = { type: l, $no_start: !1, $no_end: !1, scheduled_summary: !1 };
      return (
        l === t.config.types.project &&
          s.auto_scheduling === !1 &&
          (d.scheduled_summary = !0),
        o || l != s.$rendered_type
          ? (l == t.config.types.project
              ? (d.$no_end = d.$no_start = !0)
              : l != t.config.types.milestone &&
                ((d.$no_end = !(s.end_date || s.duration)),
                (d.$no_start = !s.start_date),
                t._isAllowedUnscheduledTask(s) &&
                  (d.$no_end = d.$no_start = !1)),
            d)
          : ((d.$no_start = s.$no_start), (d.$no_end = s.$no_end), d)
      );
    };
    function i(s) {
      (s.$effective_calendar = t.getTaskCalendar(s).id),
        (s.start_date = t.getClosestWorkTime({
          dir: "future",
          date: s.start_date,
          unit: t.config.duration_unit,
          task: s,
        })),
        (s.end_date = t.calculateEndDate(s));
    }
    function a(s, o, l, d) {
      const c = { start: "start_date", end: "end_date" },
        u = { start: "$auto_start_date", end: "$auto_end_date" };
      let h;
      (h =
        s.type === t.config.types.project && s.auto_scheduling === !1 ? u : c),
        o.$no_start && (s[h.start] = l ? new Date(l) : n(s, this.getParent(s))),
        o.$no_end &&
          (s[h.end] = d
            ? new Date(d)
            : this.calculateEndDate({
                start_date: s[h.start],
                duration: this.config.duration_step,
                task: s,
              })),
        (o.$no_start || o.$no_end) && this._init_task_timing(s);
    }
    function r(s) {
      var o = null,
        l = null,
        d = s !== void 0 ? s : t.config.root_id,
        c = [];
      return (
        t.eachTask(function (u) {
          const h =
            t.getTaskType(u.type) == t.config.types.project &&
            u.auto_scheduling === !1;
          (t.getTaskType(u.type) == t.config.types.project && !h) ||
            t.isUnscheduledTask(u) ||
            (u.rollup && c.push(u.id),
            !u.start_date ||
              (u.$no_start && !h) ||
              (o && !(o > u.start_date.valueOf())) ||
              (o = u.start_date.valueOf()),
            !u.end_date ||
              (u.$no_end && !h) ||
              (l && !(l < u.end_date.valueOf())) ||
              (l = u.end_date.valueOf()));
        }, d),
        {
          start_date: o ? new Date(o) : null,
          end_date: l ? new Date(l) : null,
          rollup: c,
        }
      );
    }
    (t._init_task_timing = function (s) {
      var o = e(s, !0),
        l = s.$rendered_type != o.type,
        d = o.type;
      l &&
        ((s.$no_start = o.$no_start),
        (s.$no_end = o.$no_end),
        (s.$rendered_type = o.type)),
        l &&
          d != this.config.types.milestone &&
          d == this.config.types.project &&
          (this._set_default_task_timing(s), (s.$calculate_duration = !1)),
        d == this.config.types.milestone && (s.end_date = s.start_date),
        s.start_date &&
          s.end_date &&
          s.$calculate_duration !== !1 &&
          (s.duration = this.calculateDuration(s)),
        s.$calculate_duration || (s.$calculate_duration = !0),
        s.end_date || (s.end_date = s.start_date),
        (s.duration = s.duration || 0),
        this.config.min_duration === 0 &&
          s.duration === 0 &&
          ((s.$no_end = !1),
          s.type === t.config.types.project &&
            t.hasChild(s.id) &&
            (s.$no_end = !0));
      var c = this.getTaskCalendar(s);
      s.$effective_calendar &&
        s.$effective_calendar !== c.id &&
        (i(s),
        this.config.inherit_calendar &&
          this.isSummaryTask(s) &&
          this.eachTask(function (u) {
            i(u);
          }, s.id)),
        (s.$effective_calendar = c.id);
    }),
      (t.isSummaryTask = function (s) {
        t.assert(
          s && s instanceof Object,
          "Invalid argument <b>task</b>=" +
            s +
            " of gantt.isSummaryTask. Task object was expected"
        );
        var o = e(s);
        return !(!o.$no_end && !o.$no_start);
      }),
      (t.resetProjectDates = function (s) {
        var o = e(s);
        if (o.$no_end || o.$no_start) {
          var l = r(s.id);
          a.call(this, s, o, l.start_date, l.end_date), (s.$rollup = l.rollup);
        }
      }),
      (t.getSubtaskDuration = function (s) {
        var o = 0,
          l = s !== void 0 ? s : t.config.root_id;
        return (
          this.eachTask(function (d) {
            this.getTaskType(d.type) == t.config.types.project ||
              this.isUnscheduledTask(d) ||
              (o += d.duration);
          }, l),
          o
        );
      }),
      (t.getSubtaskDates = function (s) {
        var o = r(s);
        return { start_date: o.start_date, end_date: o.end_date };
      }),
      (t._update_parents = function (s, o, l) {
        if (s) {
          var d = this.getTask(s);
          d.rollup && (l = !0);
          var c = this.getParent(d),
            u = e(d),
            h = !0;
          if (l || (d.start_date && d.end_date && (u.$no_start || u.$no_end))) {
            const y = d.$auto_start_date ? "$auto_start_date" : "start_date",
              v = d.$auto_end_date ? "$auto_end_date" : "end_date";
            var _ = d[y].valueOf(),
              f = d[v].valueOf();
            t.resetProjectDates(d),
              l || _ != d[y].valueOf() || f != d[v].valueOf() || (h = !1),
              h && !o && this.refreshTask(d.id, !0),
              u.scheduled_summary && (h = !0);
          }
          h && c && this.isTaskExists(c) && this._update_parents(c, o, l);
        }
      }),
      (t.roundDate = function (s) {
        var o = t.getScale();
        nt(s) &&
          (s = {
            date: s,
            unit: o ? o.unit : t.config.duration_unit,
            step: o ? o.step : t.config.duration_step,
          });
        var l,
          d,
          c,
          u = s.date,
          h = s.step,
          _ = s.unit;
        if (!o) return u;
        if (
          _ == o.unit &&
          h == o.step &&
          +u >= +o.min_date &&
          +u <= +o.max_date
        )
          (c = Math.floor(t.columnIndexByDate(u))),
            o.trace_x[c] || ((c -= 1), o.rtl && (c = 0)),
            (d = new Date(o.trace_x[c])),
            (l = t.date.add(d, h, _));
        else {
          for (
            c = Math.floor(t.columnIndexByDate(u)),
              l = t.date[_ + "_start"](new Date(o.min_date)),
              o.trace_x[c] && (l = t.date[_ + "_start"](o.trace_x[c]));
            +l < +u;

          ) {
            var f = (l = t.date[_ + "_start"](
              t.date.add(l, h, _)
            )).getTimezoneOffset();
            (l = t._correct_dst_change(l, f, l, _)),
              t.date[_ + "_start"] && (l = t.date[_ + "_start"](l));
          }
          d = t.date.add(l, -1 * h, _);
        }
        return s.dir && s.dir == "future"
          ? l
          : (s.dir && s.dir == "past") || Math.abs(u - d) < Math.abs(l - u)
          ? d
          : l;
      }),
      (t.correctTaskWorkTime = function (s) {
        t.config.work_time &&
          t.config.correct_work_time &&
          (this.isWorkTime(s.start_date, void 0, s)
            ? this.isWorkTime(new Date(+s.end_date - 1), void 0, s) ||
              (s.end_date = this.calculateEndDate(s))
            : ((s.start_date = this.getClosestWorkTime({
                date: s.start_date,
                dir: "future",
                task: s,
              })),
              (s.end_date = this.calculateEndDate(s))));
      }),
      t.attachEvent("onBeforeTaskUpdate", function (s, o) {
        return t._init_task_timing(o), !0;
      }),
      t.attachEvent("onBeforeTaskAdd", function (s, o) {
        return t._init_task_timing(o), !0;
      }),
      t.attachEvent("onAfterTaskMove", function (s, o, l) {
        return t._init_task_timing(t.getTask(s)), !0;
      });
  }
  function zn(t, n) {
    var e,
      i = t.config.container_resize_timeout || 20;
    let a = jn(t);
    if (t.config.container_resize_method == "timeout") l();
    else
      try {
        t.event(n, "resize", function () {
          if (t.$scrollbarRepaint) t.$scrollbarRepaint = null;
          else {
            let d = jn(t);
            if (a.x == d.x && a.y == d.y) return;
            (a = d), r();
          }
        });
      } catch {
        l();
      }
    function r() {
      clearTimeout(e),
        (e = setTimeout(function () {
          t.$destroyed || t.render();
        }, i));
    }
    var s = t.$root.offsetHeight,
      o = t.$root.offsetWidth;
    function l() {
      (t.$root.offsetHeight == s && t.$root.offsetWidth == o) || r(),
        (s = t.$root.offsetHeight),
        (o = t.$root.offsetWidth),
        setTimeout(l, i);
    }
  }
  function jn(t) {
    return { x: t.$root.offsetWidth, y: t.$root.offsetHeight };
  }
  function na(t) {
    t.assert = (function (r) {
      return function (s, o) {
        s ||
          (r.config.show_errors &&
            r.callEvent("onError", [o]) !== !1 &&
            (r.message
              ? r.message({ type: "error", text: o, expire: -1 })
              : console.log(o)));
      };
    })(t);
    var n =
      "Invalid value of the first argument of `gantt.init`. Supported values: HTMLElement, String (element id).This error means that either invalid object is passed into `gantt.init` or that the element with the specified ID doesn't exist on the page when `gantt.init` is called.";
    function e(r) {
      if (
        !r ||
        (typeof r == "string" && document.getElementById(r)) ||
        (function (s) {
          try {
            s.cloneNode(!1);
          } catch {
            return !1;
          }
          return !0;
        })(r)
      )
        return !0;
      throw (t.assert(!1, n), new Error(n));
    }
    (t.init = function (r, s, o) {
      t.env.isNode ? (r = null) : e(r),
        s &&
          o &&
          ((this.config.start_date = this._min_date = new Date(s)),
          (this.config.end_date = this._max_date = new Date(o))),
        this.date.init(),
        (this.init = function (l) {
          t.env.isNode ? (l = null) : e(l),
            this.$container &&
              this.$container.parentNode &&
              (this.$container.parentNode.removeChild(this.$container),
              (this.$container = null)),
            this.$layout && this.$layout.clear(),
            this._reinit(l);
        }),
        this._reinit(r);
    }),
      (t._quickRefresh = function (r) {
        for (var s = this._getDatastores.call(this), o = 0; o < s.length; o++)
          s[o]._quick_refresh = !0;
        for (r(), o = 0; o < s.length; o++) s[o]._quick_refresh = !1;
      });
    var i = function () {
        this._clearTaskLayers && this._clearTaskLayers(),
          this._clearLinkLayers && this._clearLinkLayers(),
          this.$layout &&
            (this.$layout.destructor(),
            (this.$layout = null),
            this.$ui.reset());
      }.bind(t),
      a = function () {
        K(t) ||
          ((this.$root.innerHTML = ""),
          (this.$root.gantt = this),
          De(this),
          (this.config.layout.id = "main"),
          (this.$layout = this.$ui.createView(
            "layout",
            this.$root,
            this.config.layout
          )),
          this.$layout.attachEvent("onBeforeResize", function () {
            for (
              var r = t.$services.getService("datastores"), s = 0;
              s < r.length;
              s++
            )
              t.getDatastore(r[s]).filter(),
                t.$data.tasksStore._skipTaskRecalculation
                  ? t.$data.tasksStore._skipTaskRecalculation != "lightbox" &&
                    (t.$data.tasksStore._skipTaskRecalculation = !1)
                  : t.getDatastore(r[s]).callEvent("onBeforeRefreshAll", []);
          }),
          this.$layout.attachEvent("onResize", function () {
            t._quickRefresh(function () {
              t.refreshData();
            });
          }),
          this.callEvent("onGanttLayoutReady", []),
          this.$layout.render(),
          (this.$container = this.$layout.$container.firstChild),
          (function (r) {
            window.getComputedStyle(r.$root).getPropertyValue("position") ==
              "static" && (r.$root.style.position = "relative");
            var s = document.createElement("iframe");
            (s.className = "gantt_container_resize_watcher"),
              (s.tabIndex = -1),
              r.config.wai_aria_attributes &&
                (s.setAttribute("role", "none"),
                s.setAttribute("aria-hidden", !0)),
              r.env.isSalesforce &&
                (r.config.container_resize_method = "timeout"),
              r.$root.appendChild(s),
              s.contentWindow
                ? zn(r, s.contentWindow)
                : (r.$root.removeChild(s), zn(r, window));
          })(this));
      }.bind(t);
    (t.resetLayout = function () {
      i(), a(), this.render();
    }),
      (t._reinit = function (r) {
        this.callEvent("onBeforeGanttReady", []),
          this._update_flags(),
          this.$services.getService("templateLoader").initTemplates(this),
          i(),
          (this.$root = null),
          r &&
            ((this.$root = ye(r)),
            a(),
            this.$mouseEvents.reset(this.$root),
            (function (s) {
              s.$container &&
                !s.config.autosize &&
                s.$root.offsetHeight < 50 &&
                console.warn(`The Gantt container has a small height, so you cannot see its content. If it is not intended, you need to set the 'height' style rule to the container:
https://docs.dhtmlx.com/gantt/faq.html#theganttchartisntrenderedcorrectly`);
            })(t)),
          this.callEvent("onTemplatesReady", []),
          this.callEvent("onGanttReady", []),
          this.render();
      }),
      (t.$click = {
        buttons: {
          edit: function (r) {
            t.isReadonly(t.getTask(r)) || t.showLightbox(r);
          },
          delete: function (r) {
            var s = t.getTask(r);
            if (!t.isReadonly(s)) {
              var o = t.locale.labels.confirm_deleting,
                l = t.locale.labels.confirm_deleting_title;
              t._delete_task_confirm({
                task: s,
                message: o,
                title: l,
                callback: function () {
                  t.isTaskExists(r) &&
                    (s.$new
                      ? ((t.$data.tasksStore._skipTaskRecalculation =
                          "lightbox"),
                        t.silent(function () {
                          t.deleteTask(r, !0);
                        }),
                        (t.$data.tasksStore._skipTaskRecalculation = !1),
                        t.refreshData())
                      : ((t.$data.tasksStore._skipTaskRecalculation = !0),
                        t.deleteTask(r))),
                    t.hideLightbox();
                },
              });
            }
          },
        },
      }),
      (t.render = function () {
        var r;
        if ((this.callEvent("onBeforeGanttRender", []), !K(t))) {
          !this.config.sort && this._sort && (this._sort = void 0),
            this.$root &&
              (this.config.rtl
                ? (this.$root.classList.add("gantt_rtl"),
                  this.$root.firstChild.classList.add("gantt_rtl"))
                : (this.$root.classList.remove("gantt_rtl"),
                  this.$root.firstChild.classList.remove("gantt_rtl")));
          var s = this.getScrollState(),
            o = s ? s.x : 0;
          this._getHorizontalScrollbar() &&
            (o =
              this._getHorizontalScrollbar().$config.codeScrollLeft || o || 0),
            (r = null),
            o && (r = t.dateFromPos(o + this.config.task_scroll_offset));
        }
        if ((De(this), K(t))) t.refreshData();
        else {
          this.$layout.$config.autosize = this.config.autosize;
          var l = this.config.preserve_scroll;
          if (
            ((this.config.preserve_scroll = !1),
            this.$layout.resize(),
            (this.config.preserve_scroll = l),
            this.config.preserve_scroll && s)
          ) {
            if (o || s.y) {
              var d = t.getScrollState();
              if (+r != +t.dateFromPos(d.x) || d.y != s.y) {
                o = null;
                var c = null;
                r &&
                  (o = Math.max(
                    t.posFromDate(r) - t.config.task_scroll_offset,
                    0
                  )),
                  s.y && (c = s.y),
                  t.scrollTo(o, c);
              }
            }
            this.$layout.getScrollbarsInfo().forEach((u) => {
              const h = t.$ui.getView(u.id),
                _ = t.utils.dom.isChildOf(h.$view, t.$container);
              u.boundViews.forEach((f) => {
                const y = t.$ui.getView(f);
                u.y && u.y != s.y && y && !_ && y.scrollTo(void 0, 0),
                  u.x_pos &&
                    u.x_pos != s.x &&
                    y &&
                    _ &&
                    y.scrollTo(u.x_pos, void 0);
              });
            });
          }
        }
        this.callEvent("onGanttRender", []);
      }),
      (t.setSizes = t.render),
      (t.getTaskRowNode = function (r) {
        for (
          var s = this.$grid_data.childNodes,
            o = this.config.task_attribute,
            l = 0;
          l < s.length;
          l++
        )
          if (s[l].getAttribute && s[l].getAttribute(o) == r) return s[l];
        return null;
      }),
      (t.changeLightboxType = function (r) {
        if (this.getLightboxType() == r) return !0;
        t._silent_redraw_lightbox(r);
      }),
      (t._get_link_type = function (r, s) {
        var o = null;
        return (
          r && s
            ? (o = t.config.links.start_to_start)
            : !r && s
            ? (o = t.config.links.finish_to_start)
            : r || s
            ? r && !s && (o = t.config.links.start_to_finish)
            : (o = t.config.links.finish_to_finish),
          o
        );
      }),
      (t.isLinkAllowed = function (r, s, o, l) {
        var d = null;
        if (
          !(d =
            typeof r == "object"
              ? r
              : { source: r, target: s, type: this._get_link_type(o, l) }) ||
          !(d.source && d.target && d.type) ||
          d.source == d.target
        )
          return !1;
        var c = !0;
        return (
          this.checkEvent("onLinkValidation") &&
            (c = this.callEvent("onLinkValidation", [d])),
          c
        );
      }),
      (t._correct_dst_change = function (r, s, o, l) {
        var d = Jt(l) * o;
        if (d > 3600 && d < 86400) {
          var c = r.getTimezoneOffset() - s;
          c && (r = t.date.add(r, c, "minute"));
        }
        return r;
      }),
      (t.isSplitTask = function (r) {
        return (
          t.assert(
            r && r instanceof Object,
            "Invalid argument <b>task</b>=" +
              r +
              " of gantt.isSplitTask. Task object was expected"
          ),
          this.$data.tasksStore._isSplitItem(r)
        );
      }),
      (t._is_icon_open_click = function (r) {
        if (!r) return !1;
        var s = r.target || r.srcElement;
        if (!s || !s.className) return !1;
        var o = it(s);
        return (
          o.indexOf("gantt_tree_icon") !== -1 &&
          (o.indexOf("gantt_close") !== -1 || o.indexOf("gantt_open") !== -1)
        );
      });
  }
  const ia = {
      date: {
        month_full: [
          " ",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          " ",
          " ",
          " ",
        ],
        month_short: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_short: ["", "", "", "", "", "", ""],
      },
      labels: {
        new_task: " ",
        icon_save: "",
        icon_cancel: "",
        icon_details: "",
        icon_edit: "",
        icon_delete: "",
        confirm_closing: "  ,   ",
        confirm_deleting: "       ",
        section_description: "",
        section_time: " ",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    aa = {
      date: {
        month_full: [
          "",
          "",
          "",
          "",
          "Ma",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        month_short: [
          "",
          "",
          "",
          "",
          "Ma",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_short: ["", "", "", "", "", "", ""],
      },
      labels: {
        new_task: " ",
        icon_save: "",
        icon_cancel: "",
        icon_details: "",
        icon_edit: "",
        icon_delete: "",
        confirm_closing: "",
        confirm_deleting: "   , ?",
        section_description: "",
        section_time: " ",
        section_type: "",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "",
        column_text: "",
        column_start_date: "",
        column_duration: "",
        column_add: "",
        link: "",
        confirm_link_deleting: " ",
        link_start: "()",
        link_end: "()",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "ii",
        hours: "i",
        days: "",
        weeks: "",
        months: "",
        years: "",
        message_ok: "OK",
        message_cancel: "",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    ra = {
      date: {
        month_full: [
          "Gener",
          "Febrer",
          "Mar",
          "Abril",
          "Maig",
          "Juny",
          "Juliol",
          "Agost",
          "Setembre",
          "Octubre",
          "Novembre",
          "Desembre",
        ],
        month_short: [
          "Gen",
          "Feb",
          "Mar",
          "Abr",
          "Mai",
          "Jun",
          "Jul",
          "Ago",
          "Set",
          "Oct",
          "Nov",
          "Des",
        ],
        day_full: [
          "Diumenge",
          "Dilluns",
          "Dimarts",
          "Dimecres",
          "Dijous",
          "Divendres",
          "Dissabte",
        ],
        day_short: ["Dg", "Dl", "Dm", "Dc", "Dj", "Dv", "Ds"],
      },
      labels: {
        new_task: "Nova tasca",
        icon_save: "Guardar",
        icon_cancel: "Cancellar",
        icon_details: "Detalls",
        icon_edit: "Editar",
        icon_delete: "Esborrar",
        confirm_closing: "",
        confirm_deleting:
          "L'esdeveniment s'esborrar definitivament, continuar ?",
        section_description: "Descripci",
        section_time: "Periode de temps",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "Cancellar",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    sa = {
      date: {
        month_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        month_short: [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "10",
          "11",
          "12",
        ],
        day_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_short: ["", "", "", "", "", "", ""],
      },
      labels: {
        new_task: "",
        icon_save: "",
        icon_cancel: "",
        icon_details: "",
        icon_edit: "",
        icon_delete: "",
        confirm_closing: "!",
        confirm_deleting: "?",
        section_description: "",
        section_time: "",
        section_type: "",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "",
        column_text: "",
        column_start_date: "",
        column_duration: "",
        column_add: "",
        link: "",
        confirm_link_deleting: "",
        link_start: " ()",
        link_end: " ()",
        type_task: "",
        type_project: "",
        type_milestone: "",
        minutes: "",
        hours: "",
        days: "",
        weeks: "",
        months: "",
        years: "",
        message_ok: "",
        message_cancel: "",
        section_constraint: "",
        constraint_type: "",
        constraint_date: "",
        asap: "",
        alap: "",
        snet: "",
        snlt: "",
        fnet: "",
        fnlt: "",
        mso: "",
        mfo: "",
        resources_filter_placeholder: "",
        resources_filter_label: "",
        empty_state_text_link: "",
        empty_state_text_description: "",
        baselines_section_placeholder: "",
        baselines_add_button: "",
        baselines_remove_button: "",
        baselines_remove_all_button: "",
        deadline_enable_button: "",
        deadline_disable_button: "",
      },
    },
    oa = {
      date: {
        month_full: [
          "Leden",
          "nor",
          "Bezen",
          "Duben",
          "Kvten",
          "erven",
          "ervenec",
          "Srpen",
          "Z",
          "jen",
          "Listopad",
          "Prosinec",
        ],
        month_short: [
          "Led",
          "n",
          "Be",
          "Dub",
          "Kv",
          "er",
          "ec",
          "Srp",
          "Z",
          "j",
          "List",
          "Pro",
        ],
        day_full: [
          "Nedle",
          "Pondl",
          "ter",
          "Steda",
          "tvrtek",
          "Ptek",
          "Sobota",
        ],
        day_short: ["Ne", "Po", "t", "St", "t", "P", "So"],
      },
      labels: {
        new_task: "Nov prce",
        icon_save: "Uloit",
        icon_cancel: "Zpt",
        icon_details: "Detail",
        icon_edit: "Edituj",
        icon_delete: "Smazat",
        confirm_closing: "",
        confirm_deleting: "Udlost bude trvale smazna, opravdu?",
        section_description: "Poznmky",
        section_time: "Doba platnosti",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "Zpt",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    la = {
      date: {
        month_full: [
          "Januar",
          "Februar",
          "Marts",
          "April",
          "Maj",
          "Juni",
          "Juli",
          "August",
          "September",
          "Oktober",
          "November",
          "December",
        ],
        month_short: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "Maj",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Okt",
          "Nov",
          "Dec",
        ],
        day_full: [
          "Sndag",
          "Mandag",
          "Tirsdag",
          "Onsdag",
          "Torsdag",
          "Fredag",
          "Lrdag",
        ],
        day_short: ["Sn", "Man", "Tir", "Ons", "Tor", "Fre", "Lr"],
      },
      labels: {
        new_task: "Ny opgave",
        icon_save: "Gem",
        icon_cancel: "Fortryd",
        icon_details: "Detaljer",
        icon_edit: "Tilret",
        icon_delete: "Slet",
        confirm_closing: "Dine rettelser vil g tabt.. Er dy sikker?",
        confirm_deleting:
          "Bigivenheden vil blive slettet permanent. Er du sikker?",
        section_description: "Beskrivelse",
        section_time: "Tidsperiode",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "Fortryd",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    da = {
      date: {
        month_full: [
          " Januar",
          " Februar",
          " Mrz ",
          " April",
          " Mai",
          " Juni",
          " Juli",
          " August",
          " September ",
          " Oktober",
          " November ",
          " Dezember",
        ],
        month_short: [
          "Jan",
          "Feb",
          "Mr",
          "Apr",
          "Mai",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Okt",
          "Nov",
          "Dez",
        ],
        day_full: [
          "Sonntag",
          "Montag",
          "Dienstag",
          " Mittwoch",
          " Donnerstag",
          "Freitag",
          "Samstag",
        ],
        day_short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
      },
      labels: {
        new_task: "Neue Aufgabe",
        icon_save: "Speichern",
        icon_cancel: "Abbrechen",
        icon_details: "Details",
        icon_edit: "ndern",
        icon_delete: "Lschen",
        confirm_closing: "",
        confirm_deleting: "Der Eintrag wird gelscht",
        section_description: "Beschreibung",
        section_time: "Zeitspanne",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "PSP",
        column_text: "Task-Namen",
        column_start_date: "Startzeit",
        column_duration: "Dauer",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "werden gelscht",
        link_start: "(starten)",
        link_end: "(ende)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minuten",
        hours: "Stunden",
        days: "Tage",
        weeks: "Wochen",
        months: "Monate",
        years: "Jahre",
        message_ok: "OK",
        message_cancel: "Abbrechen",
        section_constraint: "Regel",
        constraint_type: "Regel",
        constraint_date: "Regel - Datum",
        asap: "So bald wie mglich",
        alap: "So spt wie mglich",
        snet: "Beginn nicht vor",
        snlt: "Beginn nicht spter als",
        fnet: "Fertigstellung nicht vor",
        fnlt: "Fertigstellung nicht spter als",
        mso: "Muss beginnen am",
        mfo: "Muss fertig sein am",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    ca = {
      date: {
        month_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        month_short: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_short: ["", "", "", "", "", "", ""],
      },
      labels: {
        new_task: " ",
        icon_save: "",
        icon_cancel: "",
        icon_details: "",
        icon_edit: "",
        icon_delete: "",
        confirm_closing: "",
        confirm_deleting:
          "    .   ;",
        section_description: "",
        section_time: " ",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    ua = {
      date: {
        month_full: [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December",
        ],
        month_short: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec",
        ],
        day_full: [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
        ],
        day_short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      },
      labels: {
        new_task: "New task",
        icon_save: "Save",
        icon_cancel: "Cancel",
        icon_details: "Details",
        icon_edit: "Edit",
        icon_delete: "Delete",
        confirm_closing: "",
        confirm_deleting: "Task will be deleted permanently, are you sure?",
        section_description: "Description",
        section_time: "Time period",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "Cancel",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    ha = {
      date: {
        month_full: [
          "Enero",
          "Febrero",
          "Marzo",
          "Abril",
          "Mayo",
          "Junio",
          "Julio",
          "Agosto",
          "Septiembre",
          "Octubre",
          "Noviembre",
          "Diciembre",
        ],
        month_short: [
          "Ene",
          "Feb",
          "Mar",
          "Abr",
          "May",
          "Jun",
          "Jul",
          "Ago",
          "Sep",
          "Oct",
          "Nov",
          "Dic",
        ],
        day_full: [
          "Domingo",
          "Lunes",
          "Martes",
          "Mircoles",
          "Jueves",
          "Viernes",
          "Sbado",
        ],
        day_short: ["Dom", "Lun", "Mar", "Mi", "Jue", "Vie", "Sb"],
      },
      labels: {
        new_task: "Nueva tarea",
        icon_save: "Guardar",
        icon_cancel: "Cancelar",
        icon_details: "Detalles",
        icon_edit: "Editar",
        icon_delete: "Eliminar",
        confirm_closing: "",
        confirm_deleting: "El evento se borrar definitivamente, continuar?",
        section_description: "Descripcin",
        section_time: "Perodo",
        section_type: "Tipo",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "EDT",
        column_text: "Tarea",
        column_start_date: "Inicio",
        column_duration: "Duracin",
        column_add: "",
        link: "Enlace",
        confirm_link_deleting: "ser borrada",
        link_start: " (inicio)",
        link_end: " (fin)",
        type_task: "Tarea",
        type_project: "Proyecto",
        type_milestone: "Hito",
        minutes: "Minutos",
        hours: "Horas",
        days: "Das",
        weeks: "Semanas",
        months: "Meses",
        years: "Aos",
        message_ok: "OK",
        message_cancel: "Cancelar",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    _a = {
      date: {
        month_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        month_short: [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "10",
          "11",
          "12",
        ],
        day_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_short: ["", "", "", "", "", "", ""],
      },
      labels: {
        new_task: " ",
        icon_save: "",
        icon_cancel: "",
        icon_details: "",
        icon_edit: "",
        icon_delete: "",
        confirm_closing: "       ",
        confirm_deleting: "         ",
        section_description: "",
        section_time: " ",
        section_type: "",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "",
        column_start_date: " ",
        column_duration: "",
        column_add: "",
        link: "",
        confirm_link_deleting: "  ",
        link_start: " ()",
        link_end: " ()",
        type_task: "",
        type_project: "",
        type_milestone: "",
        minutes: "",
        hours: "",
        days: "",
        weeks: "",
        months: "",
        years: "",
        message_ok: "",
        message_cancel: "",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    ga = {
      date: {
        month_full: [
          "Tammikuu",
          "Helmikuu",
          "Maaliskuu",
          "Huhtikuu",
          "Toukokuu",
          "Kes&auml;kuu",
          "Hein&auml;kuu",
          "Elokuu",
          "Syyskuu",
          "Lokakuu",
          "Marraskuu",
          "Joulukuu",
        ],
        month_short: [
          "Tam",
          "Hel",
          "Maa",
          "Huh",
          "Tou",
          "Kes",
          "Hei",
          "Elo",
          "Syy",
          "Lok",
          "Mar",
          "Jou",
        ],
        day_full: [
          "Sunnuntai",
          "Maanantai",
          "Tiistai",
          "Keskiviikko",
          "Torstai",
          "Perjantai",
          "Lauantai",
        ],
        day_short: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
      },
      labels: {
        new_task: "Uusi tehtv",
        icon_save: "Tallenna",
        icon_cancel: "Peru",
        icon_details: "Tiedot",
        icon_edit: "Muokkaa",
        icon_delete: "Poista",
        confirm_closing: "",
        confirm_deleting: "Haluatko varmasti poistaa tapahtuman?",
        section_description: "Kuvaus",
        section_time: "Aikajakso",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "Peru",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    fa = {
      date: {
        month_full: [
          "Janvier",
          "Fvrier",
          "Mars",
          "Avril",
          "Mai",
          "Juin",
          "Juillet",
          "Aot",
          "Septembre",
          "Octobre",
          "Novembre",
          "Dcembre",
        ],
        month_short: [
          "Jan",
          "Fv",
          "Mar",
          "Avr",
          "Mai",
          "Juin",
          "Juil",
          "Ao",
          "Sep",
          "Oct",
          "Nov",
          "Dc",
        ],
        day_full: [
          "Dimanche",
          "Lundi",
          "Mardi",
          "Mercredi",
          "Jeudi",
          "Vendredi",
          "Samedi",
        ],
        day_short: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
      },
      labels: {
        new_task: "Nouvelle tche",
        icon_save: "Enregistrer",
        icon_cancel: "Annuler",
        icon_details: "Dtails",
        icon_edit: "Modifier",
        icon_delete: "Effacer",
        confirm_closing: "",
        confirm_deleting: "L'vnement sera effac sans appel, tes-vous sr ?",
        section_description: "Description",
        section_time: "Priode",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "OTP",
        column_text: "Nom de la tche",
        column_start_date: "Date initiale",
        column_duration: "Dure",
        column_add: "",
        link: "Le lien",
        confirm_link_deleting: "sera supprim",
        link_start: "(dbut)",
        link_end: "(fin)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Heures",
        days: "Jours",
        weeks: "Semaines",
        months: "Mois",
        years: "Annes",
        message_ok: "OK",
        message_cancel: "Annuler",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    pa = {
      date: {
        month_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        month_short: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_full: ["", "", "", "", "", "", ""],
        day_short: ["", "", "", "", "", "", ""],
      },
      labels: {
        new_task: " ",
        icon_save: "",
        icon_cancel: "",
        icon_details: "",
        icon_edit: "",
        icon_delete: "",
        confirm_closing: "",
        confirm_deleting: "  .?",
        section_description: "",
        section_time: "",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    ma = {
      date: {
        month_full: [
          "Sijeanj",
          "Veljaa",
          "Oujak",
          "Travanj",
          "Svibanj",
          "Lipanj",
          "Srpanj",
          "Kolovoz",
          "Rujan",
          "Listopad",
          "Studeni",
          "Prosinac",
        ],
        month_short: [
          "Sij",
          "Velj",
          "Ou",
          "Tra",
          "Svi",
          "Lip",
          "Srp",
          "Kol",
          "Ruj",
          "Lis",
          "Stu",
          "Pro",
        ],
        day_full: [
          "Nedjelja",
          "Ponedjeljak",
          "Utorak",
          "Srijeda",
          "etvrtak",
          "Petak",
          "Subota",
        ],
        day_short: ["Ned", "Pon", "Uto", "Sri", "et", "Pet", "Sub"],
      },
      labels: {
        new_task: "Novi Zadatak",
        icon_save: "Spremi",
        icon_cancel: "Odustani",
        icon_details: "Detalji",
        icon_edit: "Izmjeni",
        icon_delete: "Obrii",
        confirm_closing: "",
        confirm_deleting: "Zadatak e biti trajno izbrisan, jeste li sigurni?",
        section_description: "Opis",
        section_time: "Vremenski Period",
        section_type: "Tip",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Naziv Zadatka",
        column_start_date: "Poetno Vrijeme",
        column_duration: "Trajanje",
        column_add: "",
        link: "Poveznica",
        confirm_link_deleting: "e biti izbrisan",
        link_start: " (poetak)",
        link_end: " (kraj)",
        type_task: "Zadatak",
        type_project: "Projekt",
        type_milestone: "Milestone",
        minutes: "Minute",
        hours: "Sati",
        days: "Dani",
        weeks: "Tjedni",
        months: "Mjeseci",
        years: "Godine",
        message_ok: "OK",
        message_cancel: "Odustani",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    va = {
      date: {
        month_full: [
          "Janur",
          "Februr",
          "Mrcius",
          "prilis",
          "Mjus",
          "Jnius",
          "Jlius",
          "Augusztus",
          "Szeptember",
          "Oktber",
          "November",
          "December",
        ],
        month_short: [
          "Jan",
          "Feb",
          "Mr",
          "pr",
          "Mj",
          "Jn",
          "Jl",
          "Aug",
          "Sep",
          "Okt",
          "Nov",
          "Dec",
        ],
        day_full: [
          "Vasrnap",
          "Htf",
          "Kedd",
          "Szerda",
          "Cstrtk",
          "Pntek",
          "szombat",
        ],
        day_short: ["Va", "H", "Ke", "Sze", "Cs", "P", "Szo"],
      },
      labels: {
        new_task: "j feladat",
        icon_save: "Ments",
        icon_cancel: "Mgse",
        icon_details: "Rszletek",
        icon_edit: "Szerkeszts",
        icon_delete: "Trls",
        confirm_closing: "",
        confirm_deleting: "Az esemny trlve lesz, biztosan folytatja?",
        section_description: "Lers",
        section_time: "Idszak",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "Mgse",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    ka = {
      date: {
        month_full: [
          "Januari",
          "Februari",
          "Maret",
          "April",
          "Mei",
          "Juni",
          "Juli",
          "Agustus",
          "September",
          "Oktober",
          "November",
          "Desember",
        ],
        month_short: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "Mei",
          "Jun",
          "Jul",
          "Ags",
          "Sep",
          "Okt",
          "Nov",
          "Des",
        ],
        day_full: [
          "Minggu",
          "Senin",
          "Selasa",
          "Rabu",
          "Kamis",
          "Jumat",
          "Sabtu",
        ],
        day_short: ["Ming", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
      },
      labels: {
        new_task: "Tugas baru",
        icon_save: "Simpan",
        icon_cancel: "Batal",
        icon_details: "Detail",
        icon_edit: "Edit",
        icon_delete: "Hapus",
        confirm_closing: "",
        confirm_deleting: "Acara akan dihapus",
        section_description: "Keterangan",
        section_time: "Periode",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "Batal",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    ya = {
      date: {
        month_full: [
          "Gennaio",
          "Febbraio",
          "Marzo",
          "Aprile",
          "Maggio",
          "Giugno",
          "Luglio",
          "Agosto",
          "Settembre",
          "Ottobre",
          "Novembre",
          "Dicembre",
        ],
        month_short: [
          "Gen",
          "Feb",
          "Mar",
          "Apr",
          "Mag",
          "Giu",
          "Lug",
          "Ago",
          "Set",
          "Ott",
          "Nov",
          "Dic",
        ],
        day_full: [
          "Domenica",
          "Luned",
          "Marted",
          "Mercoled",
          "Gioved",
          "Venerd",
          "Sabato",
        ],
        day_short: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
      },
      labels: {
        new_task: "Nuovo compito",
        icon_save: "Salva",
        icon_cancel: "Chiudi",
        icon_details: "Dettagli",
        icon_edit: "Modifica",
        icon_delete: "Elimina",
        confirm_closing: "",
        confirm_deleting: "Sei sicuro di confermare l'eliminazione?",
        section_description: "Descrizione",
        section_time: "Periodo di tempo",
        section_type: "Tipo",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Nome Attivit",
        column_start_date: "Inizio",
        column_duration: "Durata",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "sar eliminato",
        link_start: " (inizio)",
        link_end: " (fine)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minuti",
        hours: "Ore",
        days: "Giorni",
        weeks: "Settimane",
        months: "Mesi",
        years: "Anni",
        message_ok: "OK",
        message_cancel: "Chiudi",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    ba = {
      date: {
        month_full: [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "10",
          "11",
          "12",
        ],
        month_short: [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "10",
          "11",
          "12",
        ],
        day_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_short: ["", "", "", "", "", "", ""],
      },
      labels: {
        new_task: "",
        icon_save: "",
        icon_cancel: "",
        icon_details: "",
        icon_edit: "",
        icon_delete: "",
        confirm_closing: "",
        confirm_deleting: "",
        section_description: "",
        section_time: "",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    $a = {
      date: {
        month_full: [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "10",
          "11",
          "12",
        ],
        month_short: [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "10",
          "11",
          "12",
        ],
        day_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_short: ["", "", "", "", "", "", ""],
      },
      labels: {
        new_task: " ",
        icon_save: "",
        icon_cancel: "",
        icon_details: " ",
        icon_edit: "",
        icon_delete: "",
        confirm_closing: "",
        confirm_deleting: " ?",
        section_description: "",
        section_time: "",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "",
        column_start_date: "",
        column_duration: "",
        column_add: "",
        link: "",
        confirm_link_deleting: " ?",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "",
        type_project: "",
        type_milestone: "",
        minutes: "",
        hours: "",
        days: "",
        weeks: "",
        months: "",
        years: "",
        message_ok: "OK",
        message_cancel: "",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    };
  class xa {
    constructor(n) {
      (this.addLocale = (e, i) => {
        this._locales[e] = i;
      }),
        (this.getLocale = (e) => this._locales[e]),
        (this._locales = {});
      for (const e in n) this._locales[e] = n[e];
    }
  }
  const wa = {
      date: {
        month_full: [
          "Januar",
          "Februar",
          "Mars",
          "April",
          "Mai",
          "Juni",
          "Juli",
          "August",
          "September",
          "Oktober",
          "November",
          "Desember",
        ],
        month_short: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "Mai",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Okt",
          "Nov",
          "Des",
        ],
        day_full: [
          "Sndag",
          "Mandag",
          "Tirsdag",
          "Onsdag",
          "Torsdag",
          "Fredag",
          "Lrdag",
        ],
        day_short: ["Sn", "Mon", "Tir", "Ons", "Tor", "Fre", "Lr"],
      },
      labels: {
        new_task: "Ny oppgave",
        icon_save: "Lagre",
        icon_cancel: "Avbryt",
        icon_details: "Detaljer",
        icon_edit: "Rediger",
        icon_delete: "Slett",
        confirm_closing: "",
        confirm_deleting: "Hendelsen vil bli slettet permanent. Er du sikker?",
        section_description: "Beskrivelse",
        section_time: "Tidsperiode",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "Avbryt",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    Sa = {
      date: {
        month_full: [
          "Januari",
          "Februari",
          "Maart",
          "April",
          "Mei",
          "Juni",
          "Juli",
          "Augustus",
          "September",
          "Oktober",
          "November",
          "December",
        ],
        month_short: [
          "Jan",
          "Feb",
          "mrt",
          "Apr",
          "Mei",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Okt",
          "Nov",
          "Dec",
        ],
        day_full: [
          "Zondag",
          "Maandag",
          "Dinsdag",
          "Woensdag",
          "Donderdag",
          "Vrijdag",
          "Zaterdag",
        ],
        day_short: ["Zo", "Ma", "Di", "Wo", "Do", "Vr", "Za"],
      },
      labels: {
        new_task: "Nieuwe taak",
        icon_save: "Opslaan",
        icon_cancel: "Annuleren",
        icon_details: "Details",
        icon_edit: "Bewerken",
        icon_delete: "Verwijderen",
        confirm_closing: "",
        confirm_deleting: "Item zal permanent worden verwijderd, doorgaan?",
        section_description: "Beschrijving",
        section_time: "Tijd periode",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Taak omschrijving",
        column_start_date: "Startdatum",
        column_duration: "Duur",
        column_add: "",
        link: "Koppeling",
        confirm_link_deleting: "zal worden verwijderd",
        link_start: " (start)",
        link_end: " (eind)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "minuten",
        hours: "uren",
        days: "dagen",
        weeks: "weken",
        months: "maanden",
        years: "jaren",
        message_ok: "OK",
        message_cancel: "Annuleren",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    Ta = {
      date: {
        month_full: [
          "Januar",
          "Februar",
          "Mars",
          "April",
          "Mai",
          "Juni",
          "Juli",
          "August",
          "September",
          "Oktober",
          "November",
          "Desember",
        ],
        month_short: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "Mai",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Okt",
          "Nov",
          "Des",
        ],
        day_full: [
          "Sndag",
          "Mandag",
          "Tirsdag",
          "Onsdag",
          "Torsdag",
          "Fredag",
          "Lrdag",
        ],
        day_short: ["Sn", "Man", "Tir", "Ons", "Tor", "Fre", "Lr"],
      },
      labels: {
        new_task: "Ny oppgave",
        icon_save: "Lagre",
        icon_cancel: "Avbryt",
        icon_details: "Detaljer",
        icon_edit: "Endre",
        icon_delete: "Slett",
        confirm_closing: "Endringer blir ikke lagret, er du sikker?",
        confirm_deleting: "Oppfringen vil bli slettet, er du sikker?",
        section_description: "Beskrivelse",
        section_time: "Tidsperiode",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "Avbryt",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    Ea = {
      date: {
        month_full: [
          "Stycze",
          "Luty",
          "Marzec",
          "Kwiecie",
          "Maj",
          "Czerwiec",
          "Lipiec",
          "Sierpie",
          "Wrzesie",
          "Padziernik",
          "Listopad",
          "Grudzie",
        ],
        month_short: [
          "Sty",
          "Lut",
          "Mar",
          "Kwi",
          "Maj",
          "Cze",
          "Lip",
          "Sie",
          "Wrz",
          "Pa",
          "Lis",
          "Gru",
        ],
        day_full: [
          "Niedziela",
          "Poniedziaek",
          "Wtorek",
          "roda",
          "Czwartek",
          "Pitek",
          "Sobota",
        ],
        day_short: ["Nie", "Pon", "Wto", "ro", "Czw", "Pi", "Sob"],
      },
      labels: {
        new_task: "Nowe zadanie",
        icon_save: "Zapisz",
        icon_cancel: "Anuluj",
        icon_details: "Szczegy",
        icon_edit: "Edytuj",
        icon_delete: "Usu",
        confirm_closing: "",
        confirm_deleting: "Zdarzenie zostanie usunite na zawsze, kontynuowa?",
        section_description: "Opis",
        section_time: "Okres czasu",
        section_type: "Typ",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Nazwa zadania",
        column_start_date: "Pocztek",
        column_duration: "Czas trwania",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "zostanie usunity",
        link_start: " (pocztek)",
        link_end: " (koniec)",
        type_task: "Zadanie",
        type_project: "Projekt",
        type_milestone: "Milestone",
        minutes: "Minuty",
        hours: "Godziny",
        days: "Dni",
        weeks: "Tydzie",
        months: "Miesice",
        years: "Lata",
        message_ok: "OK",
        message_cancel: "Anuluj",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    Ca = {
      date: {
        month_full: [
          "Janeiro",
          "Fevereiro",
          "Maro",
          "Abril",
          "Maio",
          "Junho",
          "Julho",
          "Agosto",
          "Setembro",
          "Outubro",
          "Novembro",
          "Dezembro",
        ],
        month_short: [
          "Jan",
          "Fev",
          "Mar",
          "Abr",
          "Mai",
          "Jun",
          "Jul",
          "Ago",
          "Set",
          "Out",
          "Nov",
          "Dez",
        ],
        day_full: [
          "Domingo",
          "Segunda",
          "Tera",
          "Quarta",
          "Quinta",
          "Sexta",
          "Sbado",
        ],
        day_short: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"],
      },
      labels: {
        new_task: "Nova tarefa",
        icon_save: "Salvar",
        icon_cancel: "Cancelar",
        icon_details: "Detalhes",
        icon_edit: "Editar",
        icon_delete: "Excluir",
        confirm_closing: "",
        confirm_deleting:
          "As tarefas sero excluidas permanentemente, confirme?",
        section_description: "Descrio",
        section_time: "Perodo",
        section_type: "Tipo",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "EAP",
        column_text: "Nome tarefa",
        column_start_date: "Data incio",
        column_duration: "Durao",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "Ser excludo!",
        link_start: " (incio)",
        link_end: " (fim)",
        type_task: "Task",
        type_project: "Projeto",
        type_milestone: "Marco",
        minutes: "Minutos",
        hours: "Horas",
        days: "Dias",
        weeks: "Semanas",
        months: "Meses",
        years: "Anos",
        message_ok: "OK",
        message_cancel: "Cancelar",
        section_constraint: "Restrio",
        constraint_type: "Tipo Restrio",
        constraint_date: "Data restrio",
        asap: "Mais breve possvel",
        alap: "Mais tarde possvel",
        snet: "No comear antes de",
        snlt: "No comear depois de",
        fnet: "No terminar antes de",
        fnlt: "No terminar depois de",
        mso: "Precisa comear em",
        mfo: "Precisa terminar em",
        resources_filter_placeholder: "Tipo de filtros",
        resources_filter_label: "Ocultar vazios",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    Da = {
      date: {
        month_full: [
          "Ianuarie",
          "Februarie",
          "Martie",
          "Aprilie",
          "Mai",
          "Iunie",
          "Iulie",
          "August",
          "Septembrie",
          "Octombrie",
          "November",
          "December",
        ],
        month_short: [
          "Ian",
          "Feb",
          "Mar",
          "Apr",
          "Mai",
          "Iun",
          "Iul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec",
        ],
        day_full: [
          "Duminica",
          "Luni",
          "Marti",
          "Miercuri",
          "Joi",
          "Vineri",
          "Sambata",
        ],
        day_short: ["Du", "Lu", "Ma", "Mi", "Jo", "Vi", "Sa"],
      },
      labels: {
        new_task: "Sarcina noua",
        icon_save: "Salveaza",
        icon_cancel: "Anuleaza",
        icon_details: "Detalii",
        icon_edit: "Editeaza",
        icon_delete: "Sterge",
        confirm_closing: "Schimbarile nu vor fi salvate, esti sigur?",
        confirm_deleting: "Evenimentul va fi sters permanent, esti sigur?",
        section_description: "Descriere",
        section_time: "Interval",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "Anuleaza",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    Aa = {
      date: {
        month_full: [
          "",
          "",
          "",
          "",
          "Ma",
          "",
          "",
          "",
          "",
          "O",
          "",
          "",
        ],
        month_short: [
          "",
          "",
          "Ma",
          "A",
          "Ma",
          "",
          "",
          "A",
          "",
          "",
          "",
          "",
        ],
        day_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_short: ["", "", "", "", "", "", ""],
      },
      labels: {
        new_task: " ",
        icon_save: "",
        icon_cancel: "",
        icon_details: "",
        icon_edit: "",
        icon_delete: "",
        confirm_closing: "",
        confirm_deleting: "   , ?",
        section_description: "",
        section_time: " ",
        section_type: "",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "",
        column_text: "",
        column_start_date: "",
        column_duration: "",
        column_add: "",
        link: "",
        confirm_link_deleting: " ",
        link_start: " ()",
        link_end: " ()",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "",
        hours: "",
        days: "",
        weeks: "",
        months: "",
        years: "",
        message_ok: "OK",
        message_cancel: "",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "    ",
        resources_filter_label: "  ",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    Ma = {
      date: {
        month_full: [
          "Januar",
          "Februar",
          "Marec",
          "April",
          "Maj",
          "Junij",
          "Julij",
          "Avgust",
          "September",
          "Oktober",
          "November",
          "December",
        ],
        month_short: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "Maj",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Okt",
          "Nov",
          "Dec",
        ],
        day_full: [
          "Nedelja",
          "Ponedeljek",
          "Torek",
          "Sreda",
          "etrtek",
          "Petek",
          "Sobota",
        ],
        day_short: ["Ned", "Pon", "Tor", "Sre", "et", "Pet", "Sob"],
      },
      labels: {
        new_task: "Nova naloga",
        icon_save: "Shrani",
        icon_cancel: "Preklii",
        icon_details: "Podrobnosti",
        icon_edit: "Uredi",
        icon_delete: "Izbrii",
        confirm_closing: "",
        confirm_deleting: "Dogodek bo izbrisan. elite nadaljevati?",
        section_description: "Opis",
        section_time: "asovni okvir",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "Preklii",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    Ia = {
      date: {
        month_full: [
          "Janur",
          "Februr",
          "Marec",
          "Aprl",
          "Mj",
          "Jn",
          "Jl",
          "August",
          "September",
          "Oktber",
          "November",
          "December",
        ],
        month_short: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "Mj",
          "Jn",
          "Jl",
          "Aug",
          "Sept",
          "Okt",
          "Nov",
          "Dec",
        ],
        day_full: [
          "Nedea",
          "Pondelok",
          "Utorok",
          "Streda",
          "tvrtok",
          "Piatok",
          "Sobota",
        ],
        day_short: ["Ne", "Po", "Ut", "St", "t", "Pi", "So"],
      },
      labels: {
        new_task: "Nov loha",
        icon_save: "Uloi",
        icon_cancel: "Sp",
        icon_details: "Detail",
        icon_edit: "Edituj",
        icon_delete: "Zmaza",
        confirm_closing: "Vae zmeny nebud uloen. Skutone?",
        confirm_deleting: "Udalos bude natrvalo vymazan. Skutone?",
        section_description: "Poznmky",
        section_time: "Doba platnosti",
        section_type: "Type",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "Sp",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    La = {
      date: {
        month_full: [
          "Januari",
          "Februari",
          "Mars",
          "April",
          "Maj",
          "Juni",
          "Juli",
          "Augusti",
          "September",
          "Oktober",
          "November",
          "December",
        ],
        month_short: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "Maj",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Okt",
          "Nov",
          "Dec",
        ],
        day_full: [
          "Sndag",
          "Mndag",
          "Tisdag",
          "Onsdag",
          "Torsdag",
          "Fredag",
          "Lrdag",
        ],
        day_short: ["Sn", "Mn", "Tis", "Ons", "Tor", "Fre", "Lr"],
      },
      labels: {
        new_task: "Ny uppgift",
        icon_save: "Spara",
        icon_cancel: "Avbryt",
        icon_details: "Detajer",
        icon_edit: "ndra",
        icon_delete: "Ta bort",
        confirm_closing: "",
        confirm_deleting:
          "r du sker p att du vill ta bort hndelsen permanent?",
        section_description: "Beskrivning",
        section_time: "Tid",
        section_type: "Typ",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Uppgiftsnamn",
        column_start_date: "Starttid",
        column_duration: "Varaktighet",
        column_add: "",
        link: "Lnk",
        confirm_link_deleting: "kommer tas bort",
        link_start: " (start)",
        link_end: " (slut)",
        type_task: "Uppgift",
        type_project: "Projekt",
        type_milestone: "Milstolpe",
        minutes: "Minuter",
        hours: "Timmar",
        days: "Dagar",
        weeks: "Veckor",
        months: "Mnader",
        years: "r",
        message_ok: "OK",
        message_cancel: "Avbryt",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    Na = {
      date: {
        month_full: [
          "Ocak",
          "ubat",
          "Mart",
          "Nisan",
          "Mays",
          "Haziran",
          "Temmuz",
          "Austos",
          "Eyll",
          "Ekim",
          "Kasm",
          "Aralk",
        ],
        month_short: [
          "Oca",
          "ub",
          "Mar",
          "Nis",
          "May",
          "Haz",
          "Tem",
          "Au",
          "Eyl",
          "Eki",
          "Kas",
          "Ara",
        ],
        day_full: [
          "Pazar",
          "Pazartesi",
          "Sal",
          "aramba",
          "Perembe",
          "Cuma",
          "Cumartesi",
        ],
        day_short: ["Paz", "Pzt", "Sal", "ar", "Per", "Cum", "Cmt"],
      },
      labels: {
        new_task: "Yeni grev",
        icon_save: "Kaydet",
        icon_cancel: "ptal",
        icon_details: "Detaylar",
        icon_edit: "Dzenle",
        icon_delete: "Sil",
        confirm_closing: "",
        confirm_deleting: "Grev silinecek, emin misiniz?",
        section_description: "Aklama",
        section_time: "Zaman Aral",
        section_type: "Tip",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Grev Ad",
        column_start_date: "Balang",
        column_duration: "Sre",
        column_add: "",
        link: "Balant",
        confirm_link_deleting: "silinecek",
        link_start: " (balang)",
        link_end: " (biti)",
        type_task: "Grev",
        type_project: "Proje",
        type_milestone: "Kilometreta",
        minutes: "Dakika",
        hours: "Saat",
        days: "Gn",
        weeks: "Hafta",
        months: "Ay",
        years: "Yl",
        message_ok: "OK",
        message_cancel: "ptal",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    },
    Pa = {
      date: {
        month_full: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        month_short: [
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
        ],
        day_full: [
          "",
          "",
          "",
          "",
          "",
          "'",
          "",
        ],
        day_short: ["", "", "", "", "", "", ""],
      },
      labels: {
        new_task: " ",
        icon_save: "",
        icon_cancel: "",
        icon_details: "",
        icon_edit: "",
        icon_delete: "",
        confirm_closing: "",
        confirm_deleting: "  .  ?",
        section_description: "",
        section_time: " ",
        section_type: "",
        section_deadline: "Deadline",
        section_baselines: "Baselines",
        column_wbs: "WBS",
        column_text: "Task name",
        column_start_date: "Start time",
        column_duration: "Duration",
        column_add: "",
        link: "Link",
        confirm_link_deleting: "will be deleted",
        link_start: " (start)",
        link_end: " (end)",
        type_task: "Task",
        type_project: "Project",
        type_milestone: "Milestone",
        minutes: "Minutes",
        hours: "Hours",
        days: "Days",
        weeks: "Week",
        months: "Months",
        years: "Years",
        message_ok: "OK",
        message_cancel: "",
        section_constraint: "Constraint",
        constraint_type: "Constraint type",
        constraint_date: "Constraint date",
        asap: "As Soon As Possible",
        alap: "As Late As Possible",
        snet: "Start No Earlier Than",
        snlt: "Start No Later Than",
        fnet: "Finish No Earlier Than",
        fnlt: "Finish No Later Than",
        mso: "Must Start On",
        mfo: "Must Finish On",
        resources_filter_placeholder: "type to filter",
        resources_filter_label: "hide empty",
        empty_state_text_link: "Click here",
        empty_state_text_description: "to create your first task",
        baselines_section_placeholder: "Start adding a new baseline",
        baselines_add_button: "Add Baseline",
        baselines_remove_button: "Remove",
        baselines_remove_all_button: "Remove All",
        deadline_enable_button: "Set",
        deadline_disable_button: "Remove",
      },
    };
  function Ra() {
    (this.constants = $i),
      (this.version = "9.0.15"),
      (this.license = "site"),
      (this.templates = {}),
      (this.ext = {}),
      (this.keys = {
        edit_save: this.constants.KEY_CODES.ENTER,
        edit_cancel: this.constants.KEY_CODES.ESC,
      });
  }
  function Ha(t) {
    var n = new Ra(),
      e = new bn(t),
      i = {};
    (n.plugins = function (l) {
      for (var d in l)
        if (l[d] && !i[d]) {
          var c = e.getExtension(d);
          c && (c(n), (i[d] = !0));
        }
      return i;
    }),
      (n.$services = (function () {
        var l = {};
        return {
          services: {},
          setService: function (d, c) {
            l[d] = c;
          },
          getService: function (d) {
            return l[d] ? l[d]() : null;
          },
          dropService: function (d) {
            l[d] && delete l[d];
          },
          destructor: function () {
            for (var d in l)
              if (l[d]) {
                var c = l[d];
                c && c.destructor && c.destructor();
              }
            l = null;
          },
        };
      })()),
      (n.config = {
        layout: {
          css: "gantt_container",
          rows: [
            {
              cols: [
                { view: "grid", scrollX: "scrollHor", scrollY: "scrollVer" },
                { resizer: !0, width: 1 },
                {
                  view: "timeline",
                  scrollX: "scrollHor",
                  scrollY: "scrollVer",
                },
                { view: "scrollbar", id: "scrollVer" },
              ],
            },
            { view: "scrollbar", id: "scrollHor", height: 20 },
          ],
        },
        links: {
          finish_to_start: "0",
          start_to_start: "1",
          finish_to_finish: "2",
          start_to_finish: "3",
        },
        types: { task: "task", project: "project", milestone: "milestone" },
        auto_types: !1,
        duration_unit: "day",
        work_time: !1,
        correct_work_time: !1,
        skip_off_time: !1,
        cascade_delete: !0,
        autosize: !1,
        autosize_min_width: 0,
        autoscroll: !0,
        autoscroll_speed: 30,
        deepcopy_on_parse: !1,
        show_links: !0,
        show_task_cells: !0,
        static_background: !1,
        static_background_cells: !0,
        branch_loading: !1,
        branch_loading_property: "$has_child",
        show_loading: !1,
        show_chart: !0,
        show_grid: !0,
        min_duration: 36e5,
        date_format: "%d-%m-%Y %H:%i",
        xml_date: void 0,
        start_on_monday: !0,
        server_utc: !1,
        show_progress: !0,
        fit_tasks: !1,
        select_task: !0,
        scroll_on_click: !0,
        smart_rendering: !0,
        preserve_scroll: !0,
        readonly: !1,
        container_resize_timeout: 20,
        deadlines: !0,
        date_grid: "%Y-%m-%d",
        drag_links: !0,
        drag_progress: !0,
        drag_resize: !0,
        drag_project: !1,
        drag_move: !0,
        drag_mode: {
          resize: "resize",
          progress: "progress",
          move: "move",
          ignore: "ignore",
        },
        round_dnd_dates: !0,
        link_wrapper_width: 20,
        link_arrow_size: 12,
        root_id: 0,
        autofit: !1,
        columns: [
          { name: "text", tree: !0, width: "*", resize: !0 },
          { name: "start_date", align: "center", resize: !0 },
          { name: "duration", align: "center" },
          { name: "add", width: 44 },
        ],
        scale_offset_minimal: !0,
        inherit_scale_class: !1,
        scales: [{ unit: "day", step: 1, date: "%M %d" }],
        time_step: 60,
        duration_step: 1,
        // task_date: "%d %F %Y",
        task_date: "%Y %F %d",
        time_picker: "%H:%i",
        task_attribute: "data-task-id",
        link_attribute: "data-link-id",
        layer_attribute: "data-layer",
        buttons_left: ["gantt_save_btn", "gantt_cancel_btn"],
        _migrate_buttons: {
          dhx_save_btn: "gantt_save_btn",
          dhx_cancel_btn: "gantt_cancel_btn",
          dhx_delete_btn: "gantt_delete_btn",
        },
        buttons_right: ["gantt_delete_btn"],
        lightbox: {
          sections: [
            {
              name: "description",
              height: 70,
              map_to: "text",
              type: "textarea",
              focus: !0,
            },
            { name: "time", type: "duration", map_to: "auto" },
          ],
          project_sections: [
            {
              name: "description",
              height: 70,
              map_to: "text",
              type: "textarea",
              focus: !0,
            },
            { name: "type", type: "typeselect", map_to: "type" },
            { name: "time", type: "duration", readonly: !0, map_to: "auto" },
          ],
          milestone_sections: [
            {
              name: "description",
              height: 70,
              map_to: "text",
              type: "textarea",
              focus: !0,
            },
            { name: "type", type: "typeselect", map_to: "type" },
            { name: "time", type: "duration", single_date: !0, map_to: "auto" },
          ],
        },
        drag_lightbox: !0,
        sort: !1,
        details_on_create: !0,
        details_on_dblclick: !0,
        initial_scroll: !0,
        task_scroll_offset: 100,
        order_branch: !1,
        order_branch_free: !1,
        task_height: void 0,
        bar_height: "full",
        bar_height_padding: 9,
        min_column_width: 70,
        min_grid_column_width: 70,
        grid_resizer_column_attribute: "data-column-index",
        keep_grid_width: !1,
        grid_resize: !1,
        grid_elastic_columns: !1,
        show_tasks_outside_timescale: !1,
        show_unscheduled: !0,
        resize_rows: !1,
        task_grid_row_resizer_attribute: "data-row-index",
        min_task_grid_row_height: 30,
        row_height: 36,
        readonly_property: "readonly",
        editable_property: "editable",
        calendar_property: "calendar_id",
        resource_calendars: {},
        dynamic_resource_calendars: !1,
        inherit_calendar: !1,
        type_renderers: {},
        open_tree_initially: !1,
        optimize_render: !0,
        prevent_default_scroll: !1,
        show_errors: !0,
        wai_aria_attributes: !0,
        smart_scales: !0,
        rtl: !1,
        placeholder_task: !1,
        horizontal_scroll_key: "shiftKey",
        drag_timeline: {
          useKey: void 0,
          ignore: ".gantt_task_line, .gantt_task_link",
          render: !1,
        },
        drag_multiple: !0,
        csp: "auto",
      }),
      (n.ajax = (function (l) {
        return {
          cache: !0,
          method: "get",
          parse: function (d) {
            return typeof d != "string"
              ? d
              : ((d = d.replace(/^[\s]+/, "")),
                typeof DOMParser > "u" || kt.isIE
                  ? J.ActiveXObject !== void 0 &&
                    (((c = new J.ActiveXObject("Microsoft.XMLDOM")).async =
                      "false"),
                    c.loadXML(d))
                  : (c = new DOMParser().parseFromString(d, "text/xml")),
                c);
            var c;
          },
          xmltop: function (d, c, u) {
            if (c.status === void 0 || c.status < 400) {
              var h = c.responseXML
                ? c.responseXML || c
                : this.parse(c.responseText || c);
              if (
                h &&
                h.documentElement !== null &&
                !h.getElementsByTagName("parsererror").length
              )
                return h.getElementsByTagName(d)[0];
            }
            return (
              u !== -1 &&
                l.callEvent("onLoadXMLError", [
                  "Incorrect XML",
                  arguments[1],
                  u,
                ]),
              document.createElement("DIV")
            );
          },
          xpath: function (d, c) {
            if ((c.nodeName || (c = c.responseXML || c), kt.isIE))
              return c.selectNodes(d) || [];
            for (
              var u,
                h = [],
                _ = (c.ownerDocument || c).evaluate(
                  d,
                  c,
                  null,
                  XPathResult.ANY_TYPE,
                  null
                );
              (u = _.iterateNext());

            )
              h.push(u);
            return h;
          },
          query: function (d) {
            return this._call(
              d.method || "GET",
              d.url,
              d.data || "",
              d.async || !0,
              d.callback,
              d.headers
            );
          },
          get: function (d, c, u) {
            var h = Rt("GET", arguments);
            return this.query(h);
          },
          getSync: function (d, c) {
            var u = Rt("GET", arguments);
            return (u.async = !1), this.query(u);
          },
          put: function (d, c, u, h) {
            var _ = Rt("PUT", arguments);
            return this.query(_);
          },
          del: function (d, c, u) {
            var h = Rt("DELETE", arguments);
            return this.query(h);
          },
          post: function (d, c, u, h) {
            arguments.length == 1
              ? (c = "")
              : arguments.length == 2 &&
                typeof c == "function" &&
                ((u = c), (c = ""));
            var _ = Rt("POST", arguments);
            return this.query(_);
          },
          postSync: function (d, c, u) {
            c = c === null ? "" : String(c);
            var h = Rt("POST", arguments);
            return (h.async = !1), this.query(h);
          },
          _call: function (d, c, u, h, _, f) {
            return new l.Promise(function (y, v) {
              var b =
                  typeof XMLHttpRequest !== void 0
                    ? new XMLHttpRequest()
                    : new J.ActiveXObject("Microsoft.XMLHTTP"),
                g =
                  navigator.userAgent.match(/AppleWebKit/) !== null &&
                  navigator.userAgent.match(/Qt/) !== null &&
                  navigator.userAgent.match(/Safari/) !== null;
              h &&
                (b.onreadystatechange = function () {
                  if (b.readyState == 4 || (g && b.readyState == 3)) {
                    if (
                      (b.status < 200 ||
                        b.status > 299 ||
                        b.responseText === "") &&
                      !l.callEvent("onAjaxError", [b])
                    )
                      return;
                    setTimeout(function () {
                      typeof _ == "function" &&
                        _.apply(J, [{ xmlDoc: b, filePath: c }]),
                        y(b),
                        typeof _ == "function" && ((_ = null), (b = null));
                    }, 0);
                  }
                });
              var m = !this || !this.cache;
              if (
                (d == "GET" &&
                  m &&
                  (c +=
                    (c.indexOf("?") >= 0 ? "&" : "?") +
                    "dhxr" +
                    new Date().getTime() +
                    "=1"),
                b.open(d, c, h),
                f)
              )
                for (var p in f) b.setRequestHeader(p, f[p]);
              else
                d.toUpperCase() == "POST" || d == "PUT" || d == "DELETE"
                  ? b.setRequestHeader(
                      "Content-Type",
                      "application/x-www-form-urlencoded"
                    )
                  : d == "GET" && (u = null);
              if (
                (b.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
                b.send(u),
                !h)
              )
                return { xmlDoc: b, filePath: c };
            });
          },
          urlSeparator: function (d) {
            return d.indexOf("?") != -1 ? "&" : "?";
          },
        };
      })(n)),
      (n.date = xi(n)),
      (n.RemoteEvents = Si);
    var a = (function (l) {
      function d(u) {
        return {
          target: u.target || u.srcElement,
          pageX: u.pageX,
          pageY: u.pageY,
          clientX: u.clientX,
          clientY: u.clientY,
          metaKey: u.metaKey,
          shiftKey: u.shiftKey,
          ctrlKey: u.ctrlKey,
          altKey: u.altKey,
        };
      }
      function c(u, h) {
        (this._obj = u), (this._settings = h || {}), ct(this);
        var _ = this.getInputMethods();
        (this._drag_start_timer = null),
          l.attachEvent(
            "onGanttScroll",
            z(function (v, b) {
              this.clearDragTimer();
            }, this)
          );
        for (var f = { passive: !1 }, y = 0; y < _.length; y++)
          z(function (v) {
            l.event(
              u,
              v.down,
              z(function (g) {
                v.accessor(g) &&
                  ((g.button !== void 0 && g.button !== 0) ||
                    (h.preventDefault &&
                      h.selector &&
                      dt(g.target, h.selector) &&
                      g.preventDefault(),
                    (l.config.touch && g.timeStamp && g.timeStamp - 0 < 300) ||
                      ((this._settings.original_target = d(g)),
                      (this._settings.original_element_sizes = {
                        ...lt(g, hn(u)),
                        width: g.target.offsetWidth,
                        height: g.target.offsetHeight,
                      }),
                      l.config.touch
                        ? (this.clearDragTimer(),
                          (this._drag_start_timer = setTimeout(
                            z(function () {
                              l.getState().lightbox || this.dragStart(u, g, v);
                            }, this),
                            l.config.touch_drag
                          )))
                        : this.dragStart(u, g, v))));
              }, this),
              f
            );
            var b = document.body;
            l.event(
              b,
              v.up,
              z(function (g) {
                v.accessor(g) && this.clearDragTimer();
              }, this),
              f
            );
          }, this)(_[y]);
      }
      return (
        (c.prototype = {
          traceDragEvents: function (u, h) {
            var _ = z(function (m) {
              return this.dragMove(u, m, h.accessor);
            }, this);
            z(function (m) {
              return this.dragScroll(u, m);
            }, this);
            var f = z(function (m) {
                if (
                  !this.config.started ||
                  !U(this.config.updates_per_second) ||
                  Sn(this, this.config.updates_per_second)
                ) {
                  var p = _(m);
                  if (p)
                    try {
                      m &&
                        m.preventDefault &&
                        m.cancelable &&
                        m.preventDefault();
                    } catch {}
                  return p;
                }
              }, this),
              y = Ct(l.$root),
              v = this.config.mousemoveContainer || Ct(l.$root),
              b = { passive: !1 },
              g = z(function (m) {
                return (
                  l.eventRemove(v, h.move, f),
                  l.eventRemove(y, h.up, g, b),
                  this.dragEnd(u)
                );
              }, this);
            l.event(v, h.move, f, b), l.event(y, h.up, g, b);
          },
          checkPositionChange: function (u) {
            var h = u.x - this.config.pos.x,
              _ = u.y - this.config.pos.y;
            return (
              Math.sqrt(Math.pow(Math.abs(h), 2) + Math.pow(Math.abs(_), 2)) >
              this.config.sensitivity
            );
          },
          initDnDMarker: function () {
            var u = (this.config.marker = document.createElement("div"));
            (u.className = "gantt_drag_marker"),
              (u.innerHTML = ""),
              document.body.appendChild(u);
          },
          backupEventTarget: function (u, h) {
            if (l.config.touch) {
              var _ = h(u),
                f = _.target || _.srcElement,
                y = f.cloneNode(!0);
              (this.config.original_target = d(_)),
                (this.config.original_target.target = y),
                (this.config.backup_element = f),
                f.parentNode.appendChild(y),
                (f.style.display = "none"),
                (this.config.mousemoveContainer || document.body).appendChild(
                  f
                );
            }
          },
          getInputMethods: function () {
            var u = [];
            if (
              (u.push({
                move: "mousemove",
                down: "mousedown",
                up: "mouseup",
                accessor: function (_) {
                  return _;
                },
              }),
              l.config.touch)
            ) {
              var h = !0;
              try {
                document.createEvent("TouchEvent");
              } catch {
                h = !1;
              }
              h
                ? u.push({
                    move: "touchmove",
                    down: "touchstart",
                    up: "touchend",
                    accessor: function (_) {
                      return _.touches && _.touches.length > 1
                        ? null
                        : _.touches[0]
                        ? {
                            target: document.elementFromPoint(
                              _.touches[0].clientX,
                              _.touches[0].clientY
                            ),
                            pageX: _.touches[0].pageX,
                            pageY: _.touches[0].pageY,
                            clientX: _.touches[0].clientX,
                            clientY: _.touches[0].clientY,
                          }
                        : _;
                    },
                  })
                : J.navigator.pointerEnabled
                ? u.push({
                    move: "pointermove",
                    down: "pointerdown",
                    up: "pointerup",
                    accessor: function (_) {
                      return _.pointerType == "mouse" ? null : _;
                    },
                  })
                : J.navigator.msPointerEnabled &&
                  u.push({
                    move: "MSPointerMove",
                    down: "MSPointerDown",
                    up: "MSPointerUp",
                    accessor: function (_) {
                      return _.pointerType == _.MSPOINTER_TYPE_MOUSE ? null : _;
                    },
                  });
            }
            return u;
          },
          clearDragTimer: function () {
            this._drag_start_timer &&
              (clearTimeout(this._drag_start_timer),
              (this._drag_start_timer = null));
          },
          dragStart: function (u, h, _) {
            (this.config && this.config.started) ||
              ((this.config = {
                obj: u,
                marker: null,
                started: !1,
                pos: this.getPosition(h),
                sensitivity: 4,
              }),
              this._settings && O(this.config, this._settings, !0),
              this.traceDragEvents(u, _),
              (l._prevent_touch_scroll = !0),
              h.target.closest(".gantt_row") &&
                !l.config.order_branch &&
                (l._prevent_touch_scroll = !1),
              document.body.classList.add("gantt_noselect"),
              l.config.touch && this.dragMove(u, h, _.accessor));
          },
          dragMove: function (u, h, _) {
            var f = _(h);
            if (!f) return !1;
            if (!this.config.marker && !this.config.started) {
              var y = this.getPosition(f);
              if (l.config.touch || this.checkPositionChange(y)) {
                if (
                  ((this.config.started = !0),
                  (this.config.ignore = !1),
                  (l._touch_drag = !0),
                  this.callEvent("onBeforeDragStart", [
                    u,
                    this.config.original_target,
                  ]) === !1)
                )
                  return (this.config.ignore = !0), !1;
                this.backupEventTarget(h, _),
                  this.initDnDMarker(),
                  l._touch_feedback(),
                  this.callEvent("onAfterDragStart", [
                    u,
                    this.config.original_target,
                  ]);
              } else this.config.ignore = !0;
            }
            return this.config.ignore
              ? !1
              : h.targetTouches && !f.target
              ? void 0
              : ((f.pos = this.getPosition(f)),
                (this.config.marker.style.left = f.pos.x + "px"),
                (this.config.marker.style.top = f.pos.y + "px"),
                this.callEvent("onDragMove", [u, f]),
                !0);
          },
          dragEnd: function (u) {
            var h = this.config.backup_element;
            h && h.parentNode && h.parentNode.removeChild(h),
              (l._prevent_touch_scroll = !1),
              this.config.marker &&
                (this.config.marker.parentNode.removeChild(this.config.marker),
                (this.config.marker = null),
                this.callEvent("onDragEnd", [])),
              (this.config.started = !1),
              (l._touch_drag = !1),
              document.body.classList.remove("gantt_noselect");
          },
          getPosition: function (u) {
            var h = 0,
              _ = 0;
            return (
              u.pageX || u.pageY
                ? ((h = u.pageX), (_ = u.pageY))
                : (u.clientX || u.clientY) &&
                  ((h =
                    u.clientX +
                    document.body.scrollLeft +
                    document.documentElement.scrollLeft),
                  (_ =
                    u.clientY +
                    document.body.scrollTop +
                    document.documentElement.scrollTop)),
              { x: h, y: _ }
            );
          },
        }),
        c
      );
    })(n);
    n.$services.setService("dnd", function () {
      return a;
    });
    var r = (function (l) {
      var d = {};
      function c(u, h, _) {
        _ = _ || u;
        var f = l.config,
          y = l.templates;
        l.config[u] &&
          d[_] != f[u] &&
          ((h && y[_]) || ((y[_] = l.date.date_to_str(f[u])), (d[_] = f[u])));
      }
      return {
        initTemplates: function () {
          var u = l.date,
            h = u.date_to_str,
            _ = l.config,
            f = h(_.xml_date || _.date_format, _.server_utc),
            y = u.str_to_date(_.xml_date || _.date_format, _.server_utc);
          c("date_scale", !0, void 0, l.config, l.templates),
            c("date_grid", !0, "grid_date_format", l.config, l.templates),
            c("task_date", !0, void 0, l.config, l.templates),
            l.mixin(l.templates, {
              xml_format: void 0,
              format_date: f,
              xml_date: void 0,
              parse_date: y,
              progress_text: function (v, b, g) {
                return "";
              },
              grid_header_class: function (v, b) {
                return "";
              },
              task_text: function (v, b, g) {
                return g.text;
              },
              task_class: function (v, b, g) {
                return "";
              },
              task_end_date: function (v) {
                return l.templates.task_date(v);
              },
              grid_row_class: function (v, b, g) {
                return "";
              },
              task_row_class: function (v, b, g) {
                return "";
              },
              timeline_cell_class: function (v, b) {
                return "";
              },
              timeline_cell_content: function (v, b) {
                return "";
              },
              scale_cell_class: function (v) {
                return "";
              },
              scale_row_class: function (v) {
                return "";
              },
              grid_indent: function (v) {
                return "<div class='gantt_tree_indent'></div>";
              },
              grid_folder: function (v) {
                return (
                  "<div class='gantt_tree_icon gantt_folder_" +
                  (v.$open ? "open" : "closed") +
                  "'></div>"
                );
              },
              grid_file: function (v) {
                return "<div class='gantt_tree_icon gantt_file'></div>";
              },
              grid_open: function (v) {
                return (
                  "<div class='gantt_tree_icon gantt_" +
                  (v.$open ? "close" : "open") +
                  "'></div>"
                );
              },
              grid_blank: function (v) {
                return "<div class='gantt_tree_icon gantt_blank'></div>";
              },
              date_grid: function (v, b, g) {
                return b && l.isUnscheduledTask(b) && l.config.show_unscheduled
                  ? l.templates.task_unscheduled_time(b)
                  : l.templates.grid_date_format(v, g);
              },
              task_time: function (v, b, g) {
                return l.isUnscheduledTask(g) && l.config.show_unscheduled
                  ? l.templates.task_unscheduled_time(g)
                  : l.templates.task_date(v) +
                      " - " +
                      l.templates.task_end_date(b);
              },
              task_unscheduled_time: function (v) {
                return "";
              },
              time_picker: h(_.time_picker),
              link_class: function (v) {
                return "";
              },
              link_description: function (v) {
                var b = l.getTask(v.source),
                  g = l.getTask(v.target);
                return "<b>" + b.text + "</b> &ndash;  <b>" + g.text + "</b>";
              },
              drag_link: function (v, b, g, m) {
                v = l.getTask(v);
                var p = l.locale.labels,
                  k =
                    "<b>" +
                    v.text +
                    "</b> " +
                    (b ? p.link_start : p.link_end) +
                    "<br/>";
                return (
                  g &&
                    (k +=
                      "<b> " +
                      (g = l.getTask(g)).text +
                      "</b> " +
                      (m ? p.link_start : p.link_end) +
                      "<br/>"),
                  k
                );
              },
              drag_link_class: function (v, b, g, m) {
                var p = "";
                return (
                  v &&
                    g &&
                    (p =
                      " " +
                      (l.isLinkAllowed(v, g, b, m)
                        ? "gantt_link_allow"
                        : "gantt_link_deny")),
                  "gantt_link_tooltip" + p
                );
              },
              tooltip_date_format: u.date_to_str("%Y-%m-%d"),
              tooltip_text: function (v, b, g) {
                return `<div>: ${g.text}</div>
				<div>: ${l.templates.tooltip_date_format(v)}</div>
				<div>: ${l.templates.tooltip_date_format(b)}</div>`;
              },
              baseline_text: function (v, b, g) {
                return "";
              },
            });
        },
        initTemplate: c,
      };
    })(n);
    n.$services.setService("templateLoader", function () {
      return r;
    }),
      ct(n);
    var s = new Ti();
    s.registerProvider("global", function () {
      var l = {
        min_date: n._min_date,
        max_date: n._max_date,
        selected_task: null,
      };
      return (
        n.$data &&
          n.$data.tasksStore &&
          (l.selected_task = n.$data.tasksStore.getSelectedId()),
        l
      );
    }),
      (n.getState = s.getState),
      n.$services.setService("state", function () {
        return s;
      }),
      O(n, vn),
      (n.Promise = Ei),
      (n.env = kt),
      (function (l) {
        var d = Di.create();
        O(l, d);
        var c,
          u = l.createDatastore({
            name: "task",
            type: "treeDatastore",
            rootId: function () {
              return l.config.root_id;
            },
            initItem: z(function (m) {
              this.defined(m.id) || (m.id = this.uid()),
                m.start_date &&
                  (m.start_date = l.date.parseDate(m.start_date, "parse_date")),
                m.end_date &&
                  (m.end_date = l.date.parseDate(m.end_date, "parse_date"));
              var p = null;
              (m.duration || m.duration === 0) &&
                (m.duration = p = 1 * m.duration),
                p &&
                  (m.start_date && !m.end_date
                    ? (m.end_date = this.calculateEndDate(m))
                    : !m.start_date &&
                      m.end_date &&
                      (m.start_date = this.calculateEndDate({
                        start_date: m.end_date,
                        duration: -m.duration,
                        task: m,
                      }))),
                l.config.deadlines !== !1 &&
                  m.deadline &&
                  (m.deadline = l.date.parseDate(m.deadline, "parse_date")),
                (m.progress = Number(m.progress) || 0),
                this._isAllowedUnscheduledTask(m) &&
                  this._set_default_task_timing(m),
                this._init_task_timing(m),
                m.start_date && m.end_date && this.correctTaskWorkTime(m),
                (m.$source = []),
                (m.$target = []);
              var k = this.$data.tasksStore.getItem(m.id);
              return (
                k && !U(m.open) && (m.$open = k.$open),
                m.parent === void 0 && (m.parent = this.config.root_id),
                m.open && (m.$open = !0),
                m
              );
            }, l),
            getConfig: function () {
              return l.config;
            },
          }),
          h = l.createDatastore({
            name: "link",
            initItem: z(function (m) {
              return this.defined(m.id) || (m.id = this.uid()), m;
            }, l),
          });
        function _(m) {
          var p = l.isTaskVisible(m);
          if (!p && l.isTaskExists(m)) {
            var k = l.getParent(m);
            l.isTaskExists(k) &&
              l.isTaskVisible(k) &&
              ((k = l.getTask(k)), l.isSplitTask(k) && (p = !0));
          }
          return p;
        }
        function f(m) {
          if (l.isTaskExists(m.source)) {
            var p = l.getTask(m.source);
            (p.$source = p.$source || []),
              y(m.id, p.$source) && p.$source.push(m.id);
          }
          if (l.isTaskExists(m.target)) {
            var k = l.getTask(m.target);
            (k.$target = k.$target || []),
              y(m.id, k.$target) && k.$target.push(m.id);
          }
        }
        function y(m, p) {
          return p.indexOf(String(m)) === -1 && p.indexOf(Number(m)) === -1;
        }
        function v(m) {
          if (l.isTaskExists(m.source)) {
            for (var p = l.getTask(m.source), k = 0; k < p.$source.length; k++)
              if (p.$source[k] == m.id) {
                p.$source.splice(k, 1);
                break;
              }
          }
          if (l.isTaskExists(m.target)) {
            var w = l.getTask(m.target);
            for (k = 0; k < w.$target.length; k++)
              if (w.$target[k] == m.id) {
                w.$target.splice(k, 1);
                break;
              }
          }
        }
        function b() {
          for (
            var m = null,
              p = l.$data.tasksStore.getItems(),
              k = 0,
              w = p.length;
            k < w;
            k++
          )
            ((m = p[k]).$source = []), (m.$target = []);
          var x = l.$data.linksStore.getItems();
          for (k = 0, w = x.length; k < w; k++) f(x[k]);
        }
        function g(m) {
          var p = m.source,
            k = m.target;
          for (var w in m.events)
            (function (x, $) {
              p.attachEvent(
                x,
                function () {
                  return k.callEvent($, Array.prototype.slice.call(arguments));
                },
                $
              );
            })(w, m.events[w]);
        }
        l.attachEvent("onDestroy", function () {
          u.destructor(), h.destructor();
        }),
          l.attachEvent("onLinkValidation", function (m) {
            if (l.isLinkExists(m.id) || m.id === "predecessor_generated")
              return !0;
            for (
              var p = l.getTask(m.source).$source, k = 0;
              k < p.length;
              k++
            ) {
              var w = l.getLink(p[k]),
                x = m.source == w.source,
                $ = m.target == w.target,
                S = m.type == w.type;
              if (x && $ && S) return !1;
            }
            return !0;
          }),
          u.attachEvent("onBeforeRefreshAll", function () {
            if (!u._skipTaskRecalculation)
              for (var m = u.getVisibleItems(), p = 0; p < m.length; p++) {
                var k = m[p];
                (k.$index = p),
                  (k.$local_index = l.getTaskIndex(k.id)),
                  l.resetProjectDates(k);
              }
          }),
          u.attachEvent("onFilterItem", function (m, p) {
            if (l.config.show_tasks_outside_timescale) return !0;
            var k = null,
              w = null;
            if (l.config.start_date && l.config.end_date) {
              if (l._isAllowedUnscheduledTask(p)) return !0;
              if (
                ((k = l.config.start_date.valueOf()),
                (w = l.config.end_date.valueOf()),
                +p.start_date > w || +p.end_date < +k)
              )
                return !1;
            }
            return !0;
          }),
          u.attachEvent("onIdChange", function (m, p) {
            l._update_flags(m, p);
            var k = l.getTask(p);
            u.isSilent() ||
              ((k.$split_subtask || k.rollup) &&
                l.eachParent(function (w) {
                  l.refreshTask(w.id);
                }, p));
          }),
          u.attachEvent("onAfterUpdate", function (m) {
            if ((l._update_parents(m), l.getState("batchUpdate").batch_update))
              return !0;
            var p = u.getItem(m);
            p.$source || (p.$source = []);
            for (var k = 0; k < p.$source.length; k++) h.refresh(p.$source[k]);
            for (
              p.$target || (p.$target = []), k = 0;
              k < p.$target.length;
              k++
            )
              h.refresh(p.$target[k]);
          }),
          u.attachEvent("onBeforeItemMove", function (m, p, k) {
            return (
              !jt(m, l, u) ||
              (console.log(
                "The placeholder task cannot be moved to another position."
              ),
              !1)
            );
          }),
          u.attachEvent("onAfterItemMove", function (m, p, k) {
            var w = l.getTask(m);
            this.getNextSibling(m) !== null
              ? (w.$drop_target = this.getNextSibling(m))
              : this.getPrevSibling(m) !== null
              ? (w.$drop_target = "next:" + this.getPrevSibling(m))
              : (w.$drop_target = "next:null");
          }),
          u.attachEvent("onStoreUpdated", function (m, p, k) {
            if (
              (k == "delete" && l._update_flags(m, null),
              !l.$services.getService("state").getState("batchUpdate")
                .batch_update)
            ) {
              if (l.config.fit_tasks && k !== "paint") {
                var w = l.getState();
                De(l);
                var x = l.getState();
                if (+w.min_date != +x.min_date || +w.max_date != +x.max_date)
                  return l.render(), l.callEvent("onScaleAdjusted", []), !0;
              }
              k == "add" || k == "move" || k == "delete"
                ? l.$layout &&
                  (this.$config.name != "task" ||
                    (k != "add" && k != "delete") ||
                    (this._skipTaskRecalculation != "lightbox" &&
                      (this._skipTaskRecalculation = !0)),
                  l.$layout.resize())
                : m || h.refresh();
            }
          }),
          h.attachEvent("onAfterAdd", function (m, p) {
            f(p);
          }),
          h.attachEvent("onAfterUpdate", function (m, p) {
            b();
          }),
          h.attachEvent("onAfterDelete", function (m, p) {
            v(p);
          }),
          h.attachEvent("onAfterSilentDelete", function (m, p) {
            v(p);
          }),
          h.attachEvent("onBeforeIdChange", function (m, p) {
            v(l.mixin({ id: m }, l.$data.linksStore.getItem(p))),
              f(l.$data.linksStore.getItem(p));
          }),
          h.attachEvent("onFilterItem", function (m, p) {
            if (!l.config.show_links) return !1;
            var k = _(p.source),
              w = _(p.target);
            return (
              !(
                !k ||
                !w ||
                l._isAllowedUnscheduledTask(l.getTask(p.source)) ||
                l._isAllowedUnscheduledTask(l.getTask(p.target))
              ) && l.callEvent("onBeforeLinkDisplay", [m, p])
            );
          }),
          (c = {}),
          l.attachEvent("onBeforeTaskDelete", function (m, p) {
            return (c[m] = Ae.getSubtreeLinks(l, m)), !0;
          }),
          l.attachEvent("onAfterTaskDelete", function (m, p) {
            c[m] &&
              l.$data.linksStore.silent(function () {
                for (var k in c[m])
                  l.isLinkExists(k) && l.$data.linksStore.removeItem(k),
                    v(c[m][k]);
                c[m] = null;
              });
          }),
          l.attachEvent("onAfterLinkDelete", function (m, p) {
            l.isTaskExists(p.source) && l.refreshTask(p.source),
              l.isTaskExists(p.target) && l.refreshTask(p.target);
          }),
          l.attachEvent("onParse", b),
          g({
            source: h,
            target: l,
            events: {
              onItemLoading: "onLinkLoading",
              onBeforeAdd: "onBeforeLinkAdd",
              onAfterAdd: "onAfterLinkAdd",
              onBeforeUpdate: "onBeforeLinkUpdate",
              onAfterUpdate: "onAfterLinkUpdate",
              onBeforeDelete: "onBeforeLinkDelete",
              onAfterDelete: "onAfterLinkDelete",
              onIdChange: "onLinkIdChange",
            },
          }),
          g({
            source: u,
            target: l,
            events: {
              onItemLoading: "onTaskLoading",
              onBeforeAdd: "onBeforeTaskAdd",
              onAfterAdd: "onAfterTaskAdd",
              onBeforeUpdate: "onBeforeTaskUpdate",
              onAfterUpdate: "onAfterTaskUpdate",
              onBeforeDelete: "onBeforeTaskDelete",
              onAfterDelete: "onAfterTaskDelete",
              onIdChange: "onTaskIdChange",
              onBeforeItemMove: "onBeforeTaskMove",
              onAfterItemMove: "onAfterTaskMove",
              onFilterItem: "onBeforeTaskDisplay",
              onItemOpen: "onTaskOpened",
              onItemClose: "onTaskClosed",
              onBeforeSelect: "onBeforeTaskSelected",
              onAfterSelect: "onTaskSelected",
              onAfterUnselect: "onTaskUnselected",
            },
          }),
          (l.$data = { tasksStore: u, linksStore: h });
      })(n),
      (n.dataProcessor = Ii),
      (n.createDataProcessor = Li),
      (function (l) {
        l.ext || (l.ext = {});
        for (
          var d = [Pi, Ri, Oi, Bi, zi, ji, Fi, Wi, Vi], c = 0;
          c < d.length;
          c++
        )
          d[c] && d[c](l);
      })(n),
      (function (l) {
        (function (d) {
          (d.getGridColumn = function (c) {
            for (var u = d.config.columns, h = 0; h < u.length; h++)
              if (u[h].name == c) return u[h];
            return null;
          }),
            (d.getGridColumns = function () {
              return d.config.columns.slice();
            });
        })(l),
          (ne.prototype.getGridColumns = function () {
            for (
              var d = this.$getConfig().columns, c = [], u = 0;
              u < d.length;
              u++
            )
              d[u].hide || c.push(d[u]);
            return c;
          });
      })(n),
      (function (l) {
        l.isReadonly = function (d) {
          return (
            (typeof d != "number" && typeof d != "string") ||
              !l.isTaskExists(d) ||
              (d = l.getTask(d)),
            (!d || !d[this.config.editable_property]) &&
              ((d && d[this.config.readonly_property]) || this.config.readonly)
          );
        };
      })(n),
      qi(n),
      (function (l) {
        var d = new On(l),
          c = new Bn(d);
        O(l, ta(d, c));
      })(n),
      ea(n),
      (function (l) {
        l.getTaskType = function (d) {
          var c = d;
          for (var u in (d && typeof d == "object" && (c = d.type),
          this.config.types))
            if (this.config.types[u] == c) return c;
          return l.config.types.task;
        };
      })(n),
      (function (l) {
        function d() {
          return (
            l._cached_functions.update_if_changed(l),
            l._cached_functions.active || l._cached_functions.activate(),
            !0
          );
        }
        (l._cached_functions = {
          cache: {},
          mode: !1,
          critical_path_mode: !1,
          wrap_methods: function (u, h) {
            if (h._prefetch_originals)
              for (var _ in h._prefetch_originals)
                h[_] = h._prefetch_originals[_];
            for (h._prefetch_originals = {}, _ = 0; _ < u.length; _++)
              this.prefetch(u[_], h);
          },
          prefetch: function (u, h) {
            var _ = h[u];
            if (_) {
              var f = this;
              (h._prefetch_originals[u] = _),
                (h[u] = function () {
                  for (
                    var y = new Array(arguments.length),
                      v = 0,
                      b = arguments.length;
                    v < b;
                    v++
                  )
                    y[v] = arguments[v];
                  if (f.active) {
                    var g = f.get_arguments_hash(Array.prototype.slice.call(y));
                    f.cache[u] || (f.cache[u] = {});
                    var m = f.cache[u];
                    if (f.has_cached_value(m, g))
                      return f.get_cached_value(m, g);
                    var p = _.apply(this, y);
                    return f.cache_value(m, g, p), p;
                  }
                  return _.apply(this, y);
                });
            }
            return _;
          },
          cache_value: function (u, h, _) {
            this.is_date(_) && (_ = new Date(_)), (u[h] = _);
          },
          has_cached_value: function (u, h) {
            return u.hasOwnProperty(h);
          },
          get_cached_value: function (u, h) {
            var _ = u[h];
            return this.is_date(_) && (_ = new Date(_)), _;
          },
          is_date: function (u) {
            return u && u.getUTCDate;
          },
          get_arguments_hash: function (u) {
            for (var h = [], _ = 0; _ < u.length; _++)
              h.push(this.stringify_argument(u[_]));
            return "(" + h.join(";") + ")";
          },
          stringify_argument: function (u) {
            return (u.id ? u.id : this.is_date(u) ? u.valueOf() : u) + "";
          },
          activate: function () {
            this.clear(), (this.active = !0);
          },
          deactivate: function () {
            this.clear(), (this.active = !1);
          },
          clear: function () {
            this.cache = {};
          },
          setup: function (u) {
            var h = [],
              _ = ["_isProjectEnd", "_getProjectEnd", "_getSlack"];
            this.mode == "auto"
              ? u.config.highlight_critical_path && (h = _)
              : this.mode === !0 && (h = _),
              this.wrap_methods(h, u);
          },
          update_if_changed: function (u) {
            (this.critical_path_mode != u.config.highlight_critical_path ||
              this.mode !== u.config.optimize_render) &&
              ((this.critical_path_mode = u.config.highlight_critical_path),
              (this.mode = u.config.optimize_render),
              this.setup(u));
          },
        }),
          l.attachEvent("onBeforeGanttRender", d),
          l.attachEvent("onBeforeDataRender", d),
          l.attachEvent("onBeforeSmartRender", function () {
            d();
          }),
          l.attachEvent("onBeforeParse", d),
          l.attachEvent("onDataRender", function () {
            l._cached_functions.deactivate();
          });
        var c = null;
        l.attachEvent("onSmartRender", function () {
          c && clearTimeout(c),
            (c = setTimeout(function () {
              l._cached_functions.deactivate();
            }, 1e3));
        }),
          l.attachEvent("onBeforeGanttReady", function () {
            return l._cached_functions.update_if_changed(l), !0;
          });
      })(n),
      na(n),
      (function (l) {
        l.destructor = function () {
          for (var d in (this.clearAll(),
          this.callEvent("onDestroy", []),
          this._getDatastores().forEach(function (c) {
            c.destructor();
          }),
          this.$root && delete this.$root.gantt,
          this._eventRemoveAll && this._eventRemoveAll(),
          this.$layout && this.$layout.destructor(),
          this.resetLightbox && this.resetLightbox(),
          this.ext.inlineEditors &&
            this.ext.inlineEditors.destructor &&
            this.ext.inlineEditors.destructor(),
          this._dp && this._dp.destructor && this._dp.destructor(),
          this.$services.destructor(),
          this.detachAllEvents(),
          this))
            d.indexOf("$") === 0 && delete this[d];
          this.$destroyed = !0;
        };
      })(n);
    var o = new xa({
      en: ua,
      ar: ia,
      be: aa,
      ca: ra,
      cn: sa,
      cs: oa,
      da: la,
      de: da,
      el: ca,
      es: ha,
      fa: _a,
      fi: ga,
      fr: fa,
      he: pa,
      hr: ma,
      hu: va,
      id: ka,
      it: ya,
      jp: ba,
      kr: $a,
      nb: wa,
      nl: Sa,
      no: Ta,
      pl: Ea,
      pt: Ca,
      ro: Da,
      ru: Aa,
      si: Ma,
      sk: Ia,
      sv: La,
      tr: Na,
      ua: Pa,
    });
    return (
      (n.i18n = {
        addLocale: o.addLocale,
        setLocale: function (l) {
          if (typeof l == "string") {
            var d = o.getLocale(l);
            d || (d = o.getLocale("cn")), (n.locale = d);
          } else if (l)
            if (n.locale)
              for (var c in l)
                l[c] && typeof l[c] == "object"
                  ? (n.locale[c] || (n.locale[c] = {}),
                    n.mixin(n.locale[c], l[c], !0))
                  : (n.locale[c] = l[c]);
            else n.locale = l;
          const u = n.locale.labels;
          (u.gantt_save_btn = u.gantt_save_btn || u.icon_save),
            (u.gantt_cancel_btn = u.gantt_cancel_btn || u.icon_cancel),
            (u.gantt_delete_btn = u.gantt_delete_btn || u.icon_delete);
        },
        getLocale: o.getLocale,
      }),
      n.i18n.setLocale("cn"),
      n
    );
  }
  function Oa(t) {
    var n = "data-dhxbox",
      e = null;
    function i(g, m) {
      var p = g.callback;
      y.hide(g.box), (e = g.box = null), p && p(m);
    }
    function a(g) {
      if (e) {
        var m = g.which || g.keyCode,
          p = !1;
        if (v.keyboard) {
          if (m == 13 || m == 32) {
            var k = g.target || g.srcElement;
            it(k).indexOf("gantt_popup_button") > -1 && k.click
              ? k.click()
              : (i(e, !0), (p = !0));
          }
          m == 27 && (i(e, !1), (p = !0));
        }
        return p
          ? (g.preventDefault && g.preventDefault(), !(g.cancelBubble = !0))
          : void 0;
      }
    }
    var r = Ct(t.$root) || document;
    function s(g) {
      s.cover ||
        ((s.cover = document.createElement("div")),
        (s.cover.onkeydown = a),
        (s.cover.className = "dhx_modal_cover"),
        document.body.appendChild(s.cover)),
        (s.cover.style.display = g ? "inline-block" : "none");
    }
    function o(g, m, p) {
      return (
        "<div " +
        t._waiAria.messageButtonAttrString(g) +
        " class='gantt_popup_button " +
        ("gantt_" + m.toLowerCase().replace(/ /g, "_") + "_button") +
        "' data-result='" +
        p +
        "' result='" +
        p +
        "' ><div>" +
        g +
        "</div></div>"
      );
    }
    function l() {
      for (var g = [].slice.apply(arguments, [0]), m = 0; m < g.length; m++)
        if (g[m]) return g[m];
    }
    function d(g, m, p) {
      var k = g.tagName
        ? g
        : (function ($, S, T) {
            var E = document.createElement("div"),
              C = ut();
            t._waiAria.messageModalAttr(E, C),
              (E.className = " gantt_modal_box gantt-" + $.type),
              E.setAttribute(n, 1);
            var D = "";
            if (
              ($.width && (E.style.width = $.width),
              $.height && (E.style.height = $.height),
              $.title &&
                (D += '<div class="gantt_popup_title">' + $.title + "</div>"),
              (D +=
                '<div class="gantt_popup_text" id="' +
                C +
                '"><span>' +
                ($.content ? "" : $.text) +
                '</span></div><div  class="gantt_popup_controls">'),
              S &&
                (D += o(l($.ok, t.locale.labels.message_ok, "OK"), "ok", !0)),
              T &&
                (D += o(
                  l($.cancel, t.locale.labels.message_cancel, "Cancel"),
                  "cancel",
                  !1
                )),
              $.buttons)
            )
              for (var A = 0; A < $.buttons.length; A++) {
                var I = $.buttons[A];
                D +=
                  typeof I == "object"
                    ? o(
                        I.label,
                        I.css || "gantt_" + I.label.toLowerCase() + "_button",
                        I.value || A
                      )
                    : o(I, I, A);
              }
            if (((D += "</div>"), (E.innerHTML = D), $.content)) {
              var M = $.content;
              typeof M == "string" && (M = document.getElementById(M)),
                M.style.display == "none" && (M.style.display = ""),
                E.childNodes[$.title ? 1 : 0].appendChild(M);
            }
            return (
              (E.onclick = function (L) {
                var N = L.target || L.srcElement;
                if (
                  (N.className || (N = N.parentNode),
                  dt(N, ".gantt_popup_button"))
                ) {
                  var P = N.getAttribute("data-result");
                  i($, (P = P == "true" || (P != "false" && P)));
                }
              }),
              ($.box = E),
              (S || T) && (e = $),
              E
            );
          })(g, m, p);
      g.hidden || s(!0), document.body.appendChild(k);
      var w = Math.abs(
          Math.floor(
            ((window.innerWidth || document.documentElement.offsetWidth) -
              k.offsetWidth) /
              2
          )
        ),
        x = Math.abs(
          Math.floor(
            ((window.innerHeight || document.documentElement.offsetHeight) -
              k.offsetHeight) /
              2
          )
        );
      return (
        g.position == "top" ? (k.style.top = "-3px") : (k.style.top = x + "px"),
        (k.style.left = w + "px"),
        (k.onkeydown = a),
        y.focus(k),
        g.hidden && y.hide(k),
        t.callEvent("onMessagePopup", [k]),
        k
      );
    }
    function c(g) {
      return d(g, !0, !1);
    }
    function u(g) {
      return d(g, !0, !0);
    }
    function h(g) {
      return d(g);
    }
    function _(g, m, p) {
      return (
        typeof g != "object" &&
          (typeof m == "function" && ((p = m), (m = "")),
          (g = { text: g, type: m, callback: p })),
        g
      );
    }
    function f(g, m, p, k) {
      return (
        typeof g != "object" && (g = { text: g, type: m, expire: p, id: k }),
        (g.id = g.id || ut()),
        (g.expire = g.expire || v.expire),
        g
      );
    }
    t.event(r, "keydown", a, !0);
    var y = function () {
      var g = _.apply(this, arguments);
      return (g.type = g.type || "alert"), h(g);
    };
    (y.hide = function (g) {
      for (; g && g.getAttribute && !g.getAttribute(n); ) g = g.parentNode;
      g &&
        (g.parentNode.removeChild(g),
        s(!1),
        t.callEvent("onAfterMessagePopup", [g]));
    }),
      (y.focus = function (g) {
        setTimeout(function () {
          var m = zt(g);
          m.length && m[0].focus && m[0].focus();
        }, 1);
      });
    var v = function (g, m, p, k) {
      switch (
        (((g = f.apply(this, arguments)).type = g.type || "info"),
        g.type.split("-")[0])
      ) {
        case "alert":
          return c(g);
        case "confirm":
          return u(g);
        case "modalbox":
          return h(g);
        default:
          return (function (w) {
            v.area ||
              ((v.area = document.createElement("div")),
              (v.area.className = "gantt_message_area"),
              (v.area.style[v.position] = "5px")),
              tt(v.area, document.body) || document.body.appendChild(v.area),
              v.hide(w.id);
            var x = document.createElement("div");
            return (
              (x.innerHTML = "<div>" + w.text + "</div>"),
              (x.className = "gantt-info gantt-" + w.type),
              (x.onclick = function () {
                v.hide(w.id), (w = null);
              }),
              t._waiAria.messageInfoAttr(x),
              v.position == "bottom" && v.area.firstChild
                ? v.area.insertBefore(x, v.area.firstChild)
                : v.area.appendChild(x),
              w.expire > 0 &&
                (v.timers[w.id] = window.setTimeout(function () {
                  v && v.hide(w.id);
                }, w.expire)),
              (v.pull[w.id] = x),
              (x = null),
              w.id
            );
          })(g);
      }
    };
    (v.seed = new Date().valueOf()),
      (v.uid = ut),
      (v.expire = 4e3),
      (v.keyboard = !0),
      (v.position = "top"),
      (v.pull = {}),
      (v.timers = {}),
      (v.hideAll = function () {
        for (var g in v.pull) v.hide(g);
      }),
      (v.hide = function (g) {
        var m = v.pull[g];
        m &&
          m.parentNode &&
          (window.setTimeout(function () {
            m.parentNode.removeChild(m), (m = null);
          }, 2e3),
          (m.className += " hidden"),
          v.timers[g] && window.clearTimeout(v.timers[g]),
          delete v.pull[g]);
      });
    var b = [];
    return (
      t.attachEvent("onMessagePopup", function (g) {
        b.push(g);
      }),
      t.attachEvent("onAfterMessagePopup", function (g) {
        for (var m = 0; m < b.length; m++) b[m] === g && (b.splice(m, 1), m--);
      }),
      t.attachEvent("onDestroy", function () {
        s.cover &&
          s.cover.parentNode &&
          s.cover.parentNode.removeChild(s.cover);
        for (var g = 0; g < b.length; g++)
          b[g].parentNode && b[g].parentNode.removeChild(b[g]);
        (b = null),
          v.area && v.area.parentNode && v.area.parentNode.removeChild(v.area),
          (v = null);
      }),
      {
        alert: function () {
          var g = _.apply(this, arguments);
          return (g.type = g.type || "confirm"), c(g);
        },
        confirm: function () {
          var g = _.apply(this, arguments);
          return (g.type = g.type || "alert"), u(g);
        },
        message: v,
        modalbox: y,
      }
    );
  }
  function Fn(t, n) {
    var e = this.$config[t];
    return e
      ? (e.$extendedConfig ||
          ((e.$extendedConfig = !0), Object.setPrototypeOf(e, n)),
        e)
      : n;
  }
  function Ba(t, n) {
    var e, i, a;
    O(
      t,
      ((e = n),
      {
        $getConfig: function () {
          return (
            i || (i = e ? e.$getConfig() : this.$gantt.config),
            this.$config.config ? Fn.call(this, "config", i) : i
          );
        },
        $getTemplates: function () {
          return (
            a || (a = e ? e.$getTemplates() : this.$gantt.templates),
            this.$config.templates ? Fn.call(this, "templates", a) : a
          );
        },
      })
    );
  }
  const za = function (t) {
    var n = {},
      e = {};
    function i(a, r, s, o) {
      var l = n[a];
      if (!l || !l.create) return !1;
      a != "resizer" ||
        s.mode ||
        (o.$config.cols ? (s.mode = "x") : (s.mode = "y")),
        a != "viewcell" ||
          s.view != "scrollbar" ||
          s.scroll ||
          (o.$config.cols ? (s.scroll = "y") : (s.scroll = "x")),
        (s = X(s)).id || e[s.view] || (s.id = s.view),
        s.id && !s.css && (s.css = s.id + "_cell");
      var d = new l.create(r, s, this, t);
      return (
        l.configure && l.configure(d),
        Ba(d, o),
        d.$id || (d.$id = s.id || t.uid()),
        d.$parent || typeof r != "object" || (d.$parent = r),
        d.$config || (d.$config = s),
        e[d.$id] && (d.$id = t.uid()),
        (e[d.$id] = d),
        d
      );
    }
    return {
      initUI: function (a, r) {
        var s = "cell";
        return (
          a.view
            ? (s = "viewcell")
            : a.resizer
            ? (s = "resizer")
            : a.rows || a.cols
            ? (s = "layout")
            : a.views && (s = "multiview"),
          i.call(this, s, null, a, r)
        );
      },
      reset: function () {
        e = {};
      },
      registerView: function (a, r, s) {
        n[a] = { create: r, configure: s };
      },
      createView: i,
      getView: function (a) {
        return e[a];
      },
    };
  };
  var ja = (function (t) {
    return function (n) {
      var e = { click: {}, doubleclick: {}, contextMenu: {} };
      function i(h, _, f, y) {
        e[h][_] || (e[h][_] = []), e[h][_].push({ handler: f, root: y });
      }
      function a(h) {
        h = h || window.event;
        var _ = n.locate(h),
          f = s(h, e.click),
          y = !0;
        if (
          (_ !== null
            ? (y =
                !n.checkEvent("onTaskClick") ||
                n.callEvent("onTaskClick", [_, h]))
            : n.callEvent("onEmptyClick", [h]),
          y)
        ) {
          if (!o(f, h, _)) return;
          switch (h.target.nodeName) {
            case "SELECT":
            case "INPUT":
              return;
          }
          _ &&
            n.getTask(_) &&
            !n._multiselect &&
            n.config.select_task &&
            n.selectTask(_);
        }
      }
      function r(h) {
        var _ = (h = h || window.event).target || h.srcElement,
          f = n.locate(_),
          y = n.locate(_, n.config.link_attribute),
          v =
            !n.checkEvent("onContextMenu") ||
            n.callEvent("onContextMenu", [f, y, h]);
        return (
          v || (h.preventDefault ? h.preventDefault() : (h.returnValue = !1)), v
        );
      }
      function s(h, _) {
        for (var f = h.target || h.srcElement, y = []; f; ) {
          var v = t.getClassName(f);
          if (v) {
            v = v.split(" ");
            for (var b = 0; b < v.length; b++)
              if (v[b] && _[v[b]])
                for (var g = _[v[b]], m = 0; m < g.length; m++)
                  (g[m].root && !t.isChildOf(f, g[m].root)) ||
                    y.push(g[m].handler);
          }
          f = f.parentNode;
        }
        return y;
      }
      function o(h, _, f) {
        for (var y = !0, v = 0; v < h.length; v++) {
          var b = h[v].call(n, _, f, _.target || _.srcElement);
          y = y && !(b !== void 0 && b !== !0);
        }
        return y;
      }
      function l(h) {
        h = h || window.event;
        var _ = n.locate(h),
          f = s(h, e.doubleclick),
          y =
            !n.checkEvent("onTaskDblClick") ||
            _ === null ||
            n.callEvent("onTaskDblClick", [_, h]);
        if (y) {
          if (!o(f, h, _)) return;
          _ !== null &&
            n.getTask(_) &&
            y &&
            n.config.details_on_dblclick &&
            !n.isReadonly(_) &&
            n.showLightbox(_);
        }
      }
      function d(h) {
        if (n.checkEvent("onMouseMove")) {
          var _ = n.locate(h);
          (n._last_move_event = h), n.callEvent("onMouseMove", [_, h]);
        }
      }
      var c = n._createDomEventScope();
      function u(h) {
        c.detachAll(),
          h &&
            (c.attach(h, "click", a),
            c.attach(h, "dblclick", l),
            c.attach(h, "mousemove", d),
            c.attach(h, "contextmenu", r));
      }
      return {
        reset: u,
        global: function (h, _, f) {
          i(h, _, f, null);
        },
        delegate: i,
        detach: function (h, _, f, y) {
          if (e[h] && e[h][_]) {
            for (var v = e[h], b = v[_], g = 0; g < b.length; g++)
              b[g].root == y && (b.splice(g, 1), g--);
            b.length || delete v[_];
          }
        },
        callHandler: function (h, _, f, y) {
          var v = e[h][_];
          if (v)
            for (var b = 0; b < v.length; b++)
              ((f || v[b].root) && v[b].root !== f) ||
                v[b].handler.apply(this, y);
        },
        onDoubleClick: l,
        onMouseMove: d,
        onContextMenu: r,
        onClick: a,
        destructor: function () {
          u(), (e = null), (c = null);
        },
      };
    };
  })(gn);
  const Fa = { init: ja };
  function Wn(t, n, e) {
    return (
      !!n &&
      !(n.left > t.x_end || n.left + n.width < t.x) &&
      !(n.top > t.y_end || n.top + n.height < t.y)
    );
  }
  function Vt(t) {
    return t.config.smart_rendering && t._smart_render;
  }
  function ae(t, n, e) {
    return {
      top: n.getItemTop(t.id),
      height: n.getItemHeight(t.id),
      left: 0,
      right: 1 / 0,
    };
  }
  function et(t, n, e, i, a) {
    var r = n.getItemIndexByTopPosition(a.y) || 0,
      s = n.getItemIndexByTopPosition(a.y_end) || i.count(),
      o = Math.max(0, r - 1),
      l = Math.min(i.count(), s + 1);
    const d = [];
    if (t.config.keyboard_navigation && t.getSelectedId()) {
      let c = t.getTask(t.getSelectedId());
      c.$expanded_branch && !c.$split_subtask && d.push(t.getSelectedId());
    }
    if (
      t.$ui.getView("grid") &&
      t.ext.inlineEditors &&
      t.ext.inlineEditors.getState().id
    ) {
      let c = t.ext.inlineEditors.getState().id;
      i.exists(c) && d.push(c);
    }
    return { start: o, end: l, ids: d };
  }
  var Wa = function (t) {
    var n = (function (e) {
      var i = {},
        a = {};
      function r(o) {
        var l = null;
        return (
          typeof o.view == "string"
            ? (l = e.$ui.getView(o.view))
            : o.view && (l = o.view),
          l
        );
      }
      function s(o, l, d) {
        if (a[o]) return a[o];
        l.renderer || e.assert(!1, "Invalid renderer call");
        var c = null,
          u = null,
          h = null,
          _ = null,
          f = null;
        typeof l.renderer == "function"
          ? ((c = l.renderer), (h = ae))
          : ((c = l.renderer.render),
            (u = l.renderer.update),
            (_ = l.renderer.onrender),
            l.renderer.isInViewPort
              ? (f = l.renderer.isInViewPort)
              : (h = l.renderer.getRectangle),
            h || h === null || (h = ae));
        var y = l.filter;
        return (
          d && d.setAttribute(e.config.layer_attribute, !0),
          (a[o] = {
            render_item: function (v, b, g, m, p) {
              if (((b = b || d), !y || y(v))) {
                var k = m || r(l),
                  w = p || (k ? k.$getConfig() : null),
                  x = g;
                !x && w && w.smart_rendering && (x = k.getViewPort());
                var $ = null;
                !Vt(e) && (h || f) && x
                  ? (f ? f(v, x, k, w, e) : Wn(x, h(v, k, w, e))) &&
                    ($ = c.call(e, v, k, w, x))
                  : ($ = c.call(e, v, k, w, x)),
                  this.append(v, $, b);
                var S = b.nodeType == 11;
                _ && !S && $ && _.call(e, v, $, k);
              } else this.remove_item(v.id);
            },
            clear: function (v) {
              (this.rendered = i[o] = {}), l.append || this.clear_container(v);
            },
            clear_container: function (v) {
              (v = v || d) && (v.innerHTML = "");
            },
            get_visible_range: function (v) {
              var b,
                g,
                m = r(l),
                p = m ? m.$getConfig() : null;
              return (
                p && p.smart_rendering && (b = m.getViewPort()),
                m &&
                  b &&
                  (typeof l.renderer == "function"
                    ? (g = et(e, m, 0, v, b))
                    : l.renderer &&
                      l.renderer.getVisibleRange &&
                      (g = l.renderer.getVisibleRange(e, m, p, v, b))),
                g || (g = { start: 0, end: v.count() }),
                g
              );
            },
            prepare_data: function (v) {
              if (l.renderer && l.renderer.prepareData)
                return l.renderer.prepareData(v, e, l);
            },
            render_items: function (v, b) {
              b = b || d;
              var g = document.createDocumentFragment();
              this.clear(b);
              var m = null,
                p = r(l),
                k = p ? p.$getConfig() : null;
              k && k.smart_rendering && (m = p.getViewPort());
              for (var w = 0, x = v.length; w < x; w++)
                this.render_item(v[w], g, m, p, k);
              b.appendChild(g, b);
              var $ = {};
              v.forEach(function (E) {
                $[E.id] = E;
              });
              var S = {};
              if (_) {
                var T = {};
                for (var w in this.rendered)
                  S[w] ||
                    ((T[w] = this.rendered[w]),
                    _.call(e, $[w], this.rendered[w], p));
              }
            },
            update_items: function (v, b) {
              var g = r(l),
                m = g ? g.$getConfig() : null;
              if (
                g &&
                g.$getConfig().smart_rendering &&
                !Vt(e) &&
                this.rendered &&
                (h || f)
              ) {
                b = b || d;
                var p = document.createDocumentFragment(),
                  k = null;
                g && (k = g.getViewPort());
                var w = {};
                v.forEach(function (I) {
                  w[I.id] = I;
                });
                var x = {},
                  $ = {};
                for (var S in this.rendered) ($[S] = !0), (x[S] = !0);
                for (var T = {}, E = ((S = 0), v.length); S < E; S++) {
                  var C = v[S],
                    D = this.rendered[C.id];
                  ($[C.id] = !1),
                    D && D.parentNode
                      ? (f ? f(C, k, g, m, e) : Wn(k, h(C, g, m, e)))
                        ? (u && u.call(e, C, D, g, m, k), this.restore(C, p))
                        : ($[C.id] = !0)
                      : ((T[v[S].id] = !0), this.render_item(v[S], p, k, g, m));
                }
                for (var S in $) $[S] && this.hide(S);
                if ((p.childNodes.length && b.appendChild(p, b), _)) {
                  var A = {};
                  for (var S in this.rendered)
                    (x[S] && !T[S]) ||
                      ((A[S] = this.rendered[S]),
                      _.call(e, w[S], this.rendered[S], g));
                }
              }
            },
            append: function (v, b, g) {
              this.rendered &&
                (b
                  ? (this.rendered[v.id] && this.rendered[v.id].parentNode
                      ? this.replace_item(v.id, b)
                      : g.appendChild(b),
                    (this.rendered[v.id] = b))
                  : this.rendered[v.id] && this.remove_item(v.id));
            },
            replace_item: function (v, b) {
              var g = this.rendered[v];
              g && g.parentNode && g.parentNode.replaceChild(b, g),
                (this.rendered[v] = b);
            },
            remove_item: function (v) {
              this.hide(v), delete this.rendered[v];
            },
            hide: function (v) {
              var b = this.rendered[v];
              b && b.parentNode && b.parentNode.removeChild(b),
                delete this.rendered[v];
            },
            restore: function (v, b) {
              var g = this.rendered[v.id];
              g
                ? g.parentNode || this.append(v, g, b || d)
                : this.render_item(v, b || d);
            },
            change_id: function (v, b) {
              (this.rendered[b] = this.rendered[v]), delete this.rendered[v];
            },
            rendered: i[o],
            node: d,
            destructor: function () {
              this.clear(), delete a[o], delete i[o];
            },
          }),
          a[o]
        );
      }
      return {
        getRenderer: s,
        clearRenderers: function () {
          for (var o in a) s(o).destructor();
        },
      };
    })(t);
    return {
      createGroup: function (e, i, a, r) {
        var s = {
          tempCollection: [],
          renderers: {},
          container: e,
          filters: [],
          getLayers: function () {
            this._add();
            var o = [];
            for (var l in this.renderers) o.push(this.renderers[l]);
            return o;
          },
          getLayer: function (o) {
            return this.renderers[o];
          },
          _add: function (o) {
            o && ((o.id = o.id || ut()), this.tempCollection.push(o));
            const l = this.container(),
              d = this.tempCollection;
            for (let c = 0; c < d.length; c++) {
              if (
                ((o = d[c]),
                !(
                  this.container() ||
                  (o && o.container && o.container.isConnected)
                ))
              )
                continue;
              let u = o.container,
                h = o.id,
                _ = o.topmost;
              if (!u.parentNode)
                if (_) l.appendChild(u);
                else {
                  let f = i ? i() : l.firstChild;
                  f && f.parentNode == l
                    ? l.insertBefore(u, f)
                    : l.appendChild(u);
                }
              (this.renderers[h] = n.getRenderer(h, o, u)),
                r && r(o, t),
                this.tempCollection.splice(c, 1),
                c--;
            }
          },
          addLayer: function (o) {
            if (o) {
              typeof o == "function" && (o = { renderer: o }),
                o.filter === void 0
                  ? (o.filter = Vn(a || []))
                  : o.filter instanceof Array &&
                    (o.filter.push(a), (o.filter = Vn(o.filter))),
                o.container || (o.container = document.createElement("div"));
              var l = this;
              o.requestUpdate = function () {
                t.config.smart_rendering &&
                  !Vt(t) &&
                  l.renderers[o.id] &&
                  l.onUpdateRequest(l.renderers[o.id]);
              };
            }
            return this._add(o), o ? o.id : void 0;
          },
          onUpdateRequest: function (o) {},
          eachLayer: function (o) {
            for (var l in this.renderers) o(this.renderers[l]);
          },
          removeLayer: function (o) {
            this.renderers[o] &&
              (this.renderers[o].destructor(), delete this.renderers[o]);
          },
          clear: function () {
            for (var o in this.renderers) this.renderers[o].destructor();
            this.renderers = {};
          },
        };
        return (
          t.attachEvent("onDestroy", function () {
            s.clear(), (s = null);
          }),
          s
        );
      },
    };
  };
  function Vn(t) {
    return (
      t instanceof Array || (t = Array.prototype.slice.call(arguments, 0)),
      function (n) {
        for (var e = !0, i = 0, a = t.length; i < a; i++) {
          var r = t[i];
          r && (e = e && r(n.id, n) !== !1);
        }
        return e;
      }
    );
  }
  function Un(t, n, e) {
    if (!t.start_date || !t.end_date) return null;
    var i = n.posFromDate(t.start_date),
      a = n.posFromDate(t.end_date),
      r = Math.min(i, a) - 200,
      s = Math.max(i, a) + 200;
    return {
      top: n.getItemTop(t.id),
      height: n.getItemHeight(t.id),
      left: r,
      width: s - r,
    };
  }
  function Gn() {
    var t = [],
      n = !1;
    function e() {
      (t = []), (n = !1);
    }
    function i(r, s, o) {
      s.$getConfig(),
        r.getVisibleItems().forEach(function (l) {
          var d = (function (c, u, h, _) {
            if (!_.isTaskExists(c.source) || !_.isTaskExists(c.target))
              return null;
            var f = Un(_.getTask(c.source), u),
              y = Un(_.getTask(c.target), u);
            if (!f || !y) return null;
            var v = 100,
              b = Math.min(f.left, y.left) - v,
              g = Math.max(f.left + f.width, y.left + y.width) + v,
              m = Math.min(f.top, y.top) - v,
              p = Math.max(f.top + f.height, y.top + y.height) + v;
            return {
              top: m,
              height: p - m,
              bottom: p,
              left: b,
              width: g - b,
              right: g,
            };
          })(l, s, 0, o);
          d && t.push({ id: l.id, rec: d });
        }),
        t.sort(function (l, d) {
          return l.rec.right < d.rec.right ? -1 : 1;
        }),
        (n = !0);
    }
    var a = !1;
    return function (r, s, o, l, d) {
      (function (f) {
        a ||
          ((a = !0),
          f.attachEvent("onPreFilter", e),
          f.attachEvent("onStoreUpdated", e),
          f.attachEvent("onClearAll", e),
          f.attachEvent("onBeforeStoreUpdate", e));
      })(l),
        n || i(l, s, r);
      for (var c = [], u = 0; u < t.length; u++) {
        var h = t[u],
          _ = h.rec;
        _.right < d.x ||
          (_.left < d.x_end &&
            _.right > d.x &&
            _.top < d.y_end &&
            _.bottom > d.y &&
            c.push(h.id));
      }
      return { ids: c };
    };
  }
  function qn(t, n, e, i, a) {
    var r = e.$gantt.getTask(t.source),
      s = e.$gantt.getTask(t.target),
      o = e.getItemTop(r.id),
      l = e.getItemHeight(r.id),
      d = e.getItemTop(s.id),
      c = e.getItemHeight(s.id);
    if ((n.y > o + l && n.y > d + c) || (n.y_end < d && n.y_end < o)) return !1;
    var u = e.posFromDate(r.start_date),
      h = e.posFromDate(r.end_date),
      _ = e.posFromDate(s.start_date),
      f = e.posFromDate(s.end_date);
    if (u > h) {
      var y = h;
      (h = u), (u = y);
    }
    return (
      _ > f && ((y = f), (f = _), (_ = y)),
      (u += -100),
      (h += 100),
      (_ += -100),
      (f += 100),
      !(n.x > h && n.x > f) && !(n.x_end < u && n.x_end < _)
    );
  }
  function Va(t, n) {
    if (t.view) {
      var e = t.view;
      typeof e == "string" && (e = n.$ui.getView(e)),
        e &&
          e.attachEvent &&
          e.attachEvent("onScroll", function () {
            n.$services.getService("state").getState("batchUpdate")
              .batch_update ||
              e.$config.$skipSmartRenderOnScroll ||
              (t.requestUpdate && t.requestUpdate());
          });
    }
  }
  var xt = (function () {
    function t(n, e, i, a) {
      n && ((this.$container = ye(n)), (this.$parent = n)),
        (this.$config = O(e, { headerHeight: 33 })),
        (this.$gantt = a),
        (this.$domEvents = a._createDomEventScope()),
        (this.$id = e.id || "c" + ut()),
        (this.$name = "cell"),
        (this.$factory = i),
        (this.$externalComponent = null),
        ct(this);
    }
    return (
      (t.prototype.destructor = function () {
        (this.$parent = this.$container = this.$view = null),
          this.$gantt.$services
            .getService("mouseEvents")
            .detach("click", "gantt_header_arrow", this._headerClickHandler),
          this.$domEvents.detachAll(),
          this.callEvent("onDestroy", []),
          this.detachAllEvents();
      }),
      (t.prototype.cell = function (n) {
        return null;
      }),
      (t.prototype.scrollTo = function (n, e) {
        var i = this.$view;
        this.$config.html && (i = this.$view.firstChild),
          1 * n == n && (i.scrollLeft = n),
          1 * e == e && (i.scrollTop = e);
      }),
      (t.prototype.clear = function () {
        (this.getNode().innerHTML = ""),
          (this.getNode().className = "gantt_layout_content"),
          (this.getNode().style.padding = "0");
      }),
      (t.prototype.resize = function (n) {
        if (this.$parent) return this.$parent.resize(n);
        n === !1 && (this.$preResize = !0);
        var e = this.$container,
          i = e.offsetWidth,
          a = e.offsetHeight,
          r = this.getSize();
        e === document.body &&
          ((i = document.body.offsetWidth), (a = document.body.offsetHeight)),
          i < r.minWidth && (i = r.minWidth),
          i > r.maxWidth && (i = r.maxWidth),
          a < r.minHeight && (a = r.minHeight),
          a > r.maxHeight && (a = r.maxHeight),
          this.setSize(i, a),
          this.$preResize,
          (this.$preResize = !1);
      }),
      (t.prototype.hide = function () {
        this._hide(!0), this.resize();
      }),
      (t.prototype.show = function (n) {
        this._hide(!1), n && this.$parent && this.$parent.show(), this.resize();
      }),
      (t.prototype._hide = function (n) {
        if (n === !0 && this.$view.parentNode)
          this.$view.parentNode.removeChild(this.$view);
        else if (n === !1 && !this.$view.parentNode) {
          var e = this.$parent.cellIndex(this.$id);
          this.$parent.moveView(this, e);
        }
        this.$config.hidden = n;
      }),
      (t.prototype.$toHTML = function (n, e) {
        n === void 0 && (n = ""),
          (e = [e || "", this.$config.css || ""].join(" "));
        var i = this.$config,
          a = "";
        if (i.raw) n = typeof i.raw == "string" ? i.raw : "";
        else {
          if (!n) {
            let r = null;
            (r = typeof i.html == "function" ? i.html() : i.html),
              this.$gantt.config.external_render &&
                this.$gantt.config.external_render.isElement(r) &&
                ((this.$externalComponent = r), (r = null)),
              (n =
                "<div class='gantt_layout_content' " +
                (e ? " class='" + e + "' " : "") +
                " >" +
                (r || "") +
                "</div>");
          }
          i.header &&
            (a =
              "<div class='gantt_layout_header'>" +
              (i.canCollapse
                ? "<div class='gantt_layout_header_arrow'></div>"
                : "") +
              "<div class='gantt_layout_header_content'>" +
              i.header +
              "</div></div>");
        }
        return (
          "<div class='gantt_layout_cell " +
          e +
          "' data-cell-id='" +
          this.$id +
          "'>" +
          a +
          n +
          "</div>"
        );
      }),
      (t.prototype.$fill = function (n, e) {
        (this.$view = n), (this.$parent = e), this.init();
      }),
      (t.prototype.getNode = function () {
        return this.$view.querySelector("gantt_layout_cell") || this.$view;
      }),
      (t.prototype.init = function () {
        var n = this;
        (this._headerClickHandler = function (e) {
          Q(e, "data-cell-id") == n.$id && n.toggle();
        }),
          this.$gantt.$services
            .getService("mouseEvents")
            .delegate("click", "gantt_header_arrow", this._headerClickHandler),
          this.callEvent("onReady", []);
      }),
      (t.prototype.toggle = function () {
        (this.$config.collapsed = !this.$config.collapsed), this.resize();
      }),
      (t.prototype.getSize = function () {
        var n = {
          height: this.$config.height || 0,
          width: this.$config.width || 0,
          gravity: this.$config.gravity || 1,
          minHeight: this.$config.minHeight || 0,
          minWidth: this.$config.minWidth || 0,
          maxHeight: this.$config.maxHeight || 1e11,
          maxWidth: this.$config.maxWidth || 1e11,
        };
        if (this.$config.collapsed) {
          var e = this.$config.mode === "x";
          n[e ? "width" : "height"] = n[e ? "maxWidth" : "maxHeight"] =
            this.$config.headerHeight;
        }
        return n;
      }),
      (t.prototype.getContentSize = function () {
        var n = this.$lastSize.contentX;
        n !== 1 * n && (n = this.$lastSize.width);
        var e = this.$lastSize.contentY;
        return (
          e !== 1 * e && (e = this.$lastSize.height), { width: n, height: e }
        );
      }),
      (t.prototype._getBorderSizes = function () {
        var n = {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          horizontal: 0,
          vertical: 0,
        };
        return (
          this._currentBorders &&
            (this._currentBorders[this._borders.left] &&
              ((n.left = 1), n.horizontal++),
            this._currentBorders[this._borders.right] &&
              ((n.right = 1), n.horizontal++),
            this._currentBorders[this._borders.top] &&
              ((n.top = 1), n.vertical++),
            this._currentBorders[this._borders.bottom] &&
              ((n.bottom = 1), n.vertical++)),
          n
        );
      }),
      (t.prototype.setSize = function (n, e) {
        (this.$view.style.width = n + "px"),
          (this.$view.style.height = e + "px");
        var i = this._getBorderSizes(),
          a = e - i.vertical,
          r = n - i.horizontal;
        (this.$lastSize = { x: n, y: e, contentX: r, contentY: a }),
          this.$config.header ? this._sizeHeader() : this._sizeContent();
      }),
      (t.prototype._borders = {
        left: "gantt_layout_cell_border_left",
        right: "gantt_layout_cell_border_right",
        top: "gantt_layout_cell_border_top",
        bottom: "gantt_layout_cell_border_bottom",
      }),
      (t.prototype._setBorders = function (n, e) {
        e || (e = this);
        var i = e.$view;
        for (var a in this._borders) Pt(i, this._borders[a]);
        typeof n == "string" && (n = [n]);
        var r = {};
        for (a = 0; a < n.length; a++) $t(i, n[a]), (r[n[a]] = !0);
        e._currentBorders = r;
      }),
      (t.prototype._sizeContent = function () {
        var n = this.$view.childNodes[0];
        n &&
          n.className == "gantt_layout_content" &&
          (n.style.height = this.$lastSize.contentY + "px");
      }),
      (t.prototype._sizeHeader = function () {
        var n = this.$lastSize;
        n.contentY -= this.$config.headerHeight;
        var e = this.$view.childNodes[0],
          i = this.$view.childNodes[1],
          a = this.$config.mode === "x";
        if (this.$config.collapsed)
          if (((i.style.display = "none"), a)) {
            (e.className = "gantt_layout_header collapsed_x"),
              (e.style.width = n.y + "px");
            var r = Math.floor(n.y / 2 - n.x / 2);
            (e.style.transform =
              "rotate(90deg) translate(" + r + "px, " + r + "px)"),
              (i.style.display = "none");
          } else e.className = "gantt_layout_header collapsed_y";
        else
          (e.className = a
            ? "gantt_layout_header"
            : "gantt_layout_header vertical"),
            (e.style.width = "auto"),
            (e.style.transform = ""),
            (i.style.display = ""),
            (i.style.height = n.contentY + "px");
        e.style.height = this.$config.headerHeight + "px";
      }),
      t
    );
  })();
  function W(t, n) {
    for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e]);
    function i() {
      this.constructor = t;
    }
    t.prototype =
      n === null ? Object.create(n) : ((i.prototype = n.prototype), new i());
  }
  var Yn = (function (t) {
      function n(e, i, a) {
        var r = t.apply(this, arguments) || this;
        return e && (r.$root = !0), r._parseConfig(i), (r.$name = "layout"), r;
      }
      return (
        W(n, t),
        (n.prototype.destructor = function () {
          this.$container && this.$view && dn(this.$view);
          for (var e = 0; e < this.$cells.length; e++)
            this.$cells[e].destructor();
          (this.$cells = []), t.prototype.destructor.call(this);
        }),
        (n.prototype._resizeScrollbars = function (e, i) {
          var a = !1,
            r = [],
            s = [];
          const o = [];
          function l(f) {
            f.$parent.show(), (a = !0), r.push(f);
          }
          function d(f) {
            f.$parent.hide(), (a = !0), s.push(f);
          }
          for (var c, u = 0; u < i.length; u++)
            e[(c = i[u]).$config.scroll]
              ? d(c)
              : c.shouldHide()
              ? o.push(c)
              : c.shouldShow()
              ? l(c)
              : c.isVisible()
              ? r.push(c)
              : s.push(c);
          var h = {};
          for (u = 0; u < r.length; u++)
            r[u].$config.group && (h[r[u].$config.group] = !0);
          for (
            o.forEach(function (f) {
              (f.$config.group && h[f.$config.group]) || d(f);
            }),
              u = 0;
            u < s.length;
            u++
          )
            if ((c = s[u]).$config.group && h[c.$config.group]) {
              l(c);
              for (var _ = 0; _ < r.length; _++)
                if (r[_] == c) {
                  this.$gantt.$scrollbarRepaint = !0;
                  break;
                }
            }
          return a;
        }),
        (n.prototype.getScrollbarsInfo = function () {
          const e = this.getCellsByType("scroller"),
            i = [];
          return (
            e.forEach((a) => {
              let r = {};
              const {
                visible: s,
                direction: o,
                size: l,
                scrollSize: d,
                position: c,
              } = a.getScrollState();
              let u = a._getLinkedViews().map((h) => h.$config.id);
              (r.id = a.$id),
                (r.visible = s),
                (r.boundViews = u),
                o === "x"
                  ? ((r.x = l), (r.x_inner = d), (r.x_pos = c || 0))
                  : ((r.y = l), (r.y_inner = d), (r.y_pos = c || 0)),
                i.push(r);
            }),
            i
          );
        }),
        (n.prototype._syncCellSizes = function (e, i) {
          if (e) {
            var a = {};
            return (
              this._eachChild(function (r) {
                r.$config.group &&
                  r.$name != "scrollbar" &&
                  r.$name != "resizer" &&
                  (a[r.$config.group] || (a[r.$config.group] = []),
                  a[r.$config.group].push(r));
              }),
              a[e] && this._syncGroupSize(a[e], i),
              a[e]
            );
          }
        }),
        (n.prototype._syncGroupSize = function (e, i) {
          if (e.length)
            for (
              var a = e[0].$parent._xLayout ? "width" : "height",
                r = e[0].$parent.getNextSibling(e[0].$id) ? 1 : -1,
                s = i.value,
                o = i.isGravity,
                l = 0;
              l < e.length;
              l++
            ) {
              var d = e[l].getSize(),
                c =
                  r > 0
                    ? e[l].$parent.getNextSibling(e[l].$id)
                    : e[l].$parent.getPrevSibling(e[l].$id);
              c.$name == "resizer" &&
                (c =
                  r > 0
                    ? c.$parent.getNextSibling(c.$id)
                    : c.$parent.getPrevSibling(c.$id));
              var u = c.getSize();
              if (o) e[l].$config.gravity = s;
              else if (c[a]) {
                var h = d.gravity + u.gravity,
                  _ = d[a] + u[a],
                  f = h / _;
                (e[l].$config.gravity = f * s),
                  (c.$config[a] = _ - s),
                  (c.$config.gravity = h - f * s);
              } else e[l].$config[a] = s;
              var y = this.$gantt.$ui.getView("grid");
              !y ||
                e[l].$content !== y ||
                y.$config.scrollable ||
                o ||
                (this.$gantt.config.grid_width = s);
            }
        }),
        (n.prototype.resize = function (e) {
          var i = !1;
          if (
            (this.$root &&
              !this._resizeInProgress &&
              (this.callEvent("onBeforeResize", []),
              (i = !0),
              (this._resizeInProgress = !0)),
            t.prototype.resize.call(this, !0),
            t.prototype.resize.call(this, !1),
            i)
          ) {
            var a = [];
            a = (a = (a = a.concat(this.getCellsByType("viewCell"))).concat(
              this.getCellsByType("viewLayout")
            )).concat(this.getCellsByType("hostCell"));
            for (
              var r = this.getCellsByType("scroller"), s = 0;
              s < a.length;
              s++
            )
              a[s].$config.hidden || a[s].setContentSize();
            var o = this._getAutosizeMode(this.$config.autosize),
              l = this._resizeScrollbars(o, r);
            if (
              (this.$config.autosize &&
                (this.autosize(this.$config.autosize),
                a.forEach(function (d) {
                  const c = d.$parent,
                    u = c.getContentSize(o);
                  o.x &&
                    (c.$config.$originalWidthStored ||
                      ((c.$config.$originalWidthStored = !0),
                      (c.$config.$originalWidth = c.$config.width)),
                    (c.$config.width = u.width)),
                    o.y &&
                      (c.$config.$originalHeightStored ||
                        ((c.$config.$originalHeightStored = !0),
                        (c.$config.$originalHeight = c.$config.height)),
                      (c.$config.height = u.height));
                }),
                (l = !0)),
              l)
            )
              for (this.resize(), s = 0; s < a.length; s++)
                a[s].$config.hidden || a[s].setContentSize();
            this.callEvent("onResize", []);
          }
          i && (this._resizeInProgress = !1);
        }),
        (n.prototype._eachChild = function (e, i) {
          if ((e((i = i || this)), i.$cells))
            for (var a = 0; a < i.$cells.length; a++)
              this._eachChild(e, i.$cells[a]);
        }),
        (n.prototype.isChild = function (e) {
          var i = !1;
          return (
            this._eachChild(function (a) {
              (a !== e && a.$content !== e) || (i = !0);
            }),
            i
          );
        }),
        (n.prototype.getCellsByType = function (e) {
          var i = [];
          if (
            (e === this.$name && i.push(this),
            this.$content && this.$content.$name == e && i.push(this.$content),
            this.$cells)
          )
            for (var a = 0; a < this.$cells.length; a++) {
              var r = n.prototype.getCellsByType.call(this.$cells[a], e);
              r.length && i.push.apply(i, r);
            }
          return i;
        }),
        (n.prototype.getNextSibling = function (e) {
          var i = this.cellIndex(e);
          return i >= 0 && this.$cells[i + 1] ? this.$cells[i + 1] : null;
        }),
        (n.prototype.getPrevSibling = function (e) {
          var i = this.cellIndex(e);
          return i >= 0 && this.$cells[i - 1] ? this.$cells[i - 1] : null;
        }),
        (n.prototype.cell = function (e) {
          for (var i = 0; i < this.$cells.length; i++) {
            var a = this.$cells[i];
            if (a.$id === e) return a;
            var r = a.cell(e);
            if (r) return r;
          }
        }),
        (n.prototype.cellIndex = function (e) {
          for (var i = 0; i < this.$cells.length; i++)
            if (this.$cells[i].$id === e) return i;
          return -1;
        }),
        (n.prototype.moveView = function (e, i) {
          if (this.$cells[i] !== e) return window.alert("Not implemented");
          i += this.$config.header ? 1 : 0;
          var a = this.$view;
          i >= a.childNodes.length
            ? a.appendChild(e.$view)
            : a.insertBefore(e.$view, a.childNodes[i]);
        }),
        (n.prototype._parseConfig = function (e) {
          (this.$cells = []), (this._xLayout = !e.rows);
          for (var i = e.rows || e.cols || e.views, a = 0; a < i.length; a++) {
            var r = i[a];
            r.mode = this._xLayout ? "x" : "y";
            var s = this.$factory.initUI(r, this);
            s
              ? ((s.$parent = this), this.$cells.push(s))
              : (i.splice(a, 1), a--);
          }
        }),
        (n.prototype.getCells = function () {
          return this.$cells;
        }),
        (n.prototype.render = function () {
          var e = ln(this.$container, this.$toHTML());
          this.$fill(e, null);
          const i = this.$gantt;
          this._eachChild((a) => {
            a.$externalComponent &&
              (i.config.external_render.renderElement(
                a.$externalComponent,
                a.$view.querySelector(".gantt_layout_content")
              ),
              (a.$externalComponent = null));
          }),
            this.callEvent("onReady", []),
            this.resize(),
            (this.render = this.resize);
        }),
        (n.prototype.$fill = function (e, i) {
          (this.$view = e), (this.$parent = i);
          for (
            var a = cn(e, "gantt_layout_cell"), r = a.length - 1;
            r >= 0;
            r--
          ) {
            var s = this.$cells[r];
            s.$fill(a[r], this),
              s.$config.hidden && s.$view.parentNode.removeChild(s.$view);
          }
        }),
        (n.prototype.$toHTML = function () {
          for (
            var e = this._xLayout ? "x" : "y", i = [], a = 0;
            a < this.$cells.length;
            a++
          )
            i.push(this.$cells[a].$toHTML());
          return t.prototype.$toHTML.call(
            this,
            i.join(""),
            (this.$root ? "gantt_layout_root " : "") +
              "gantt_layout gantt_layout_" +
              e
          );
        }),
        (n.prototype.getContentSize = function (e) {
          for (var i, a, r, s = 0, o = 0, l = 0; l < this.$cells.length; l++)
            (a = this.$cells[l]).$config.hidden ||
              ((i = a.getContentSize(e)),
              a.$config.view === "scrollbar" &&
                e[a.$config.scroll] &&
                ((i.height = 0), (i.width = 0)),
              a.$config.resizer &&
                (this._xLayout ? (i.height = 0) : (i.width = 0)),
              (r = a._getBorderSizes()),
              this._xLayout
                ? ((s += i.width + r.horizontal),
                  (o = Math.max(o, i.height + r.vertical)))
                : ((s = Math.max(s, i.width + r.horizontal)),
                  (o += i.height + r.vertical)));
          return {
            width: (s += (r = this._getBorderSizes()).horizontal),
            height: (o += r.vertical),
          };
        }),
        (n.prototype._cleanElSize = function (e) {
          return 1 * (e || "").toString().replace("px", "") || 0;
        }),
        (n.prototype._getBoxStyles = function (e) {
          var i = null,
            a = [
              "width",
              "height",
              "paddingTop",
              "paddingBottom",
              "paddingLeft",
              "paddingRight",
              "borderLeftWidth",
              "borderRightWidth",
              "borderTopWidth",
              "borderBottomWidth",
            ],
            r = {
              boxSizing:
                (i = window.getComputedStyle
                  ? window.getComputedStyle(e, null)
                  : { width: e.clientWidth, height: e.clientHeight })
                  .boxSizing == "border-box",
            };
          i.MozBoxSizing && (r.boxSizing = i.MozBoxSizing == "border-box");
          for (var s = 0; s < a.length; s++)
            r[a[s]] = i[a[s]] ? this._cleanElSize(i[a[s]]) : 0;
          var o = {
            horPaddings:
              r.paddingLeft +
              r.paddingRight +
              r.borderLeftWidth +
              r.borderRightWidth,
            vertPaddings:
              r.paddingTop +
              r.paddingBottom +
              r.borderTopWidth +
              r.borderBottomWidth,
            borderBox: r.boxSizing,
            innerWidth: r.width,
            innerHeight: r.height,
            outerWidth: r.width,
            outerHeight: r.height,
          };
          return (
            o.borderBox
              ? ((o.innerWidth -= o.horPaddings),
                (o.innerHeight -= o.vertPaddings))
              : ((o.outerWidth += o.horPaddings),
                (o.outerHeight += o.vertPaddings)),
            o
          );
        }),
        (n.prototype._getAutosizeMode = function (e) {
          var i = { x: !1, y: !1 };
          return (
            e === "xy"
              ? (i.x = i.y = !0)
              : e === "y" || e === !0
              ? (i.y = !0)
              : e === "x" && (i.x = !0),
            i
          );
        }),
        (n.prototype.autosize = function (e) {
          var i = this._getAutosizeMode(e),
            a = this._getBoxStyles(this.$container),
            r = this.getContentSize(e),
            s = this.$container;
          i.x &&
            (a.borderBox && (r.width += a.horPaddings),
            (s.style.width = r.width + "px")),
            i.y &&
              (a.borderBox && (r.height += a.vertPaddings),
              (s.style.height = r.height + "px"));
        }),
        (n.prototype.getSize = function () {
          this._sizes = [];
          for (
            var e = 0, i = 0, a = 1e11, r = 0, s = 1e11, o = 0, l = 0;
            l < this.$cells.length;
            l++
          ) {
            var d = (this._sizes[l] = this.$cells[l].getSize());
            this.$cells[l].$config.hidden ||
              (this._xLayout
                ? (!d.width && d.minWidth ? (e += d.minWidth) : (e += d.width),
                  (a += d.maxWidth),
                  (i += d.minWidth),
                  (r = Math.max(r, d.height)),
                  (s = Math.min(s, d.maxHeight)),
                  (o = Math.max(o, d.minHeight)))
                : (!d.height && d.minHeight
                    ? (r += d.minHeight)
                    : (r += d.height),
                  (s += d.maxHeight),
                  (o += d.minHeight),
                  (e = Math.max(e, d.width)),
                  (a = Math.min(a, d.maxWidth)),
                  (i = Math.max(i, d.minWidth))));
          }
          var c = t.prototype.getSize.call(this);
          return (
            c.maxWidth >= 1e5 && (c.maxWidth = a),
            c.maxHeight >= 1e5 && (c.maxHeight = s),
            (c.minWidth = c.minWidth != c.minWidth ? 0 : c.minWidth),
            (c.minHeight = c.minHeight != c.minHeight ? 0 : c.minHeight),
            this._xLayout
              ? ((c.minWidth += this.$config.margin * this.$cells.length || 0),
                (c.minWidth += 2 * this.$config.padding || 0),
                (c.minHeight += 2 * this.$config.padding || 0))
              : ((c.minHeight += this.$config.margin * this.$cells.length || 0),
                (c.minHeight += 2 * this.$config.padding || 0)),
            c
          );
        }),
        (n.prototype._calcFreeSpace = function (e, i, a) {
          var r = a ? i.minWidth : i.minHeight,
            s = i.maxWidth,
            o = e;
          return (
            o
              ? (o > s && (o = s), o < r && (o = r), (this._free -= o))
              : ((o = Math.floor((this._free / this._gravity) * i.gravity)) >
                  s &&
                  ((o = s), (this._free -= o), (this._gravity -= i.gravity)),
                o < r &&
                  ((o = r), (this._free -= o), (this._gravity -= i.gravity))),
            o
          );
        }),
        (n.prototype._calcSize = function (e, i, a) {
          var r = e,
            s = a ? i.minWidth : i.minHeight,
            o = a ? i.maxWidth : i.maxHeight;
          return (
            r || (r = Math.floor((this._free / this._gravity) * i.gravity)),
            r > o && (r = o),
            r < s && (r = s),
            r
          );
        }),
        (n.prototype._configureBorders = function () {
          this.$root &&
            this._setBorders(
              [
                this._borders.left,
                this._borders.top,
                this._borders.right,
                this._borders.bottom,
              ],
              this
            );
          for (
            var e = this._xLayout ? this._borders.right : this._borders.bottom,
              i = this.$cells,
              a = i.length - 1,
              r = a;
            r >= 0;
            r--
          )
            if (!i[r].$config.hidden) {
              a = r;
              break;
            }
          for (r = 0; r < i.length; r++)
            if (!i[r].$config.hidden) {
              var s = r >= a,
                o = "";
              !s &&
                i[r + 1] &&
                i[r + 1].$config.view == "scrollbar" &&
                (this._xLayout
                  ? (s = !0)
                  : (o = "gantt_layout_cell_border_transparent")),
                this._setBorders(s ? [] : [e, o], i[r]);
            }
        }),
        (n.prototype._updateCellVisibility = function () {
          for (
            var e = this._visibleCells || {},
              i = !this._visibleCells,
              a = {},
              r = null,
              s = [],
              o = 0;
            o < this._sizes.length;
            o++
          )
            (r = this.$cells[o]).$config.hide_empty && s.push(r),
              !i && r.$config.hidden && e[r.$id]
                ? r._hide(!0)
                : r.$config.hidden || e[r.$id] || r._hide(!1),
              r.$config.hidden || (a[r.$id] = !0);
          for (this._visibleCells = a, o = 0; o < s.length; o++) {
            var l = (r = s[o]).$cells,
              d = !0;
            l.forEach(function (c) {
              c.$config.hidden || c.$config.resizer || (d = !1);
            }),
              (r.$config.hidden = d);
          }
        }),
        (n.prototype.setSize = function (e, i) {
          this._configureBorders(),
            t.prototype.setSize.call(this, e, i),
            (i = this.$lastSize.contentY),
            (e = this.$lastSize.contentX);
          var a,
            r,
            s = this.$config.padding || 0;
          (this.$view.style.padding = s + "px"),
            (this._gravity = 0),
            (this._free = this._xLayout ? e : i),
            (this._free -= 2 * s),
            this._updateCellVisibility();
          for (var o = 0; o < this._sizes.length; o++)
            if (!(a = this.$cells[o]).$config.hidden) {
              var l = this.$config.margin || 0;
              a.$name != "resizer" || l || (l = -1);
              var d = a.$view,
                c = this._xLayout ? "marginRight" : "marginBottom";
              o !== this.$cells.length - 1 &&
                ((d.style[c] = l + "px"), (this._free -= l)),
                (r = this._sizes[o]),
                this._xLayout
                  ? r.width || (this._gravity += r.gravity)
                  : r.height || (this._gravity += r.gravity);
            }
          for (o = 0; o < this._sizes.length; o++)
            if (!(a = this.$cells[o]).$config.hidden) {
              var u = (r = this._sizes[o]).width,
                h = r.height;
              this._xLayout
                ? this._calcFreeSpace(u, r, !0)
                : this._calcFreeSpace(h, r, !1);
            }
          for (o = 0; o < this.$cells.length; o++)
            if (!(a = this.$cells[o]).$config.hidden) {
              r = this._sizes[o];
              var _ = void 0,
                f = void 0;
              this._xLayout
                ? ((_ = this._calcSize(r.width, r, !0)), (f = i - 2 * s))
                : ((_ = e - 2 * s), (f = this._calcSize(r.height, r, !1))),
                a.setSize(_, f);
            }
        }),
        n
      );
    })(xt),
    Ua = (function (t) {
      function n(e, i, a) {
        for (
          var r = t.apply(this, arguments) || this, s = 0;
          s < r.$cells.length;
          s++
        )
          r.$cells[s].$config.hidden = s !== 0;
        return (r.$cell = r.$cells[0]), (r.$name = "viewLayout"), r;
      }
      return (
        W(n, t),
        (n.prototype.cell = function (e) {
          var i = t.prototype.cell.call(this, e);
          return i.$view || this.$fill(null, this), i;
        }),
        (n.prototype.moveView = function (e) {
          var i = this.$view;
          this.$cell &&
            ((this.$cell.$config.hidden = !0), i.removeChild(this.$cell.$view)),
            (this.$cell = e),
            i.appendChild(e.$view);
        }),
        (n.prototype.setSize = function (e, i) {
          xt.prototype.setSize.call(this, e, i);
        }),
        (n.prototype.setContentSize = function () {
          var e = this.$lastSize;
          this.$cell.setSize(e.contentX, e.contentY);
        }),
        (n.prototype.getSize = function () {
          var e = t.prototype.getSize.call(this);
          if (this.$cell) {
            var i = this.$cell.getSize();
            if (this.$config.byMaxSize)
              for (var a = 0; a < this.$cells.length; a++) {
                var r = this.$cells[a].getSize();
                for (var s in i) i[s] = Math.max(i[s], r[s]);
              }
            for (var o in e) e[o] = e[o] || i[o];
            e.gravity = Math.max(e.gravity, i.gravity);
          }
          return e;
        }),
        n
      );
    })(Yn),
    Ga = (function (t) {
      function n(e, i, a) {
        var r = t.apply(this, arguments) || this;
        if (i.view) {
          i.id && (this.$id = ut());
          var s = X(i);
          if (
            (delete s.config,
            delete s.templates,
            (this.$content = this.$factory.createView(i.view, this, s, this)),
            !this.$content)
          )
            return !1;
        }
        return (r.$name = "viewCell"), r;
      }
      return (
        W(n, t),
        (n.prototype.destructor = function () {
          this.clear(), t.prototype.destructor.call(this);
        }),
        (n.prototype.clear = function () {
          if (((this.$initialized = !1), this.$content)) {
            var e = this.$content.unload || this.$content.destructor;
            e && e.call(this.$content);
          }
          t.prototype.clear.call(this);
        }),
        (n.prototype.scrollTo = function (e, i) {
          this.$content && this.$content.scrollTo
            ? this.$content.scrollTo(e, i)
            : t.prototype.scrollTo.call(this, e, i);
        }),
        (n.prototype._setContentSize = function (e, i) {
          var a = this._getBorderSizes();
          if (typeof e == "number") {
            var r = e + a.horizontal;
            this.$config.width = r;
          }
          if (typeof i == "number") {
            var s = i + a.vertical;
            this.$config.height = s;
          }
        }),
        (n.prototype.setSize = function (e, i) {
          if (
            (t.prototype.setSize.call(this, e, i),
            !this.$preResize && this.$content && !this.$initialized)
          ) {
            this.$initialized = !0;
            var a = this.$view.childNodes[0],
              r = this.$view.childNodes[1];
            r || (r = a), this.$content.init(r);
          }
        }),
        (n.prototype.setContentSize = function () {
          !this.$preResize &&
            this.$content &&
            this.$initialized &&
            this.$content.setSize(
              this.$lastSize.contentX,
              this.$lastSize.contentY
            );
        }),
        (n.prototype.getContentSize = function () {
          var e = t.prototype.getContentSize.call(this);
          if (this.$content && this.$initialized) {
            var i = this.$content.getSize();
            (e.width = i.contentX === void 0 ? i.width : i.contentX),
              (e.height = i.contentY === void 0 ? i.height : i.contentY);
          }
          var a = this._getBorderSizes();
          return (e.width += a.horizontal), (e.height += a.vertical), e;
        }),
        n
      );
    })(xt),
    qa = (function (t) {
      function n(e, i, a) {
        var r,
          s,
          o = t.apply(this, arguments) || this;
        function l(d) {
          var c = d.pageX,
            u = d.pageY;
          return (
            d.touches && ((c = d.touches[0].pageX), (u = d.touches[0].pageY)),
            { x: c, y: u }
          );
        }
        return (
          (o._moveHandler = function (d) {
            o._moveResizer(o._resizer, l(d).x, l(d).y);
          }),
          (o._upHandler = function (d) {
            var c = o._getNewSizes();
            o.callEvent("onResizeEnd", [
              r,
              s,
              c ? c.back : 0,
              c ? c.front : 0,
            ]) !== !1 && o._setSizes(),
              o._setBackground(!1),
              o._clearResizer(),
              o._clearListeneres(),
              d.touches && (o.$gantt._prevent_touch_scroll = !1);
          }),
          (o._clearListeneres = function () {
            this.$domEvents.detach(document, "mouseup", o._upHandler),
              this.$domEvents.detach(document, "mousemove", o._moveHandler),
              this.$domEvents.detach(document, "mousemove", o._startOnMove),
              this.$domEvents.detach(document, "mouseup", o._cancelDND),
              this.$domEvents.detach(document, "touchend", o._upHandler),
              this.$domEvents.detach(document, "touchmove", o._startOnMove),
              this.$domEvents.detach(document, "touchstart", o._downHandler);
          }),
          (o._callStartDNDEvent = function () {
            if (
              (this._xMode
                ? ((r =
                    this._behind.$config.width ||
                    this._behind.$view.offsetWidth),
                  (s =
                    this._front.$config.width || this._front.$view.offsetWidth))
                : ((r =
                    this._behind.$config.height ||
                    this._behind.$view.offsetHeight),
                  (s =
                    this._front.$config.height ||
                    this._front.$view.offsetHeight)),
              o.callEvent("onResizeStart", [r, s]) === !1)
            )
              return !1;
          }),
          (o._startDND = function (d) {
            if (this._callStartDNDEvent() !== !1) {
              var c = !1;
              this._eachGroupItem(function (u) {
                u._getSiblings(), u._callStartDNDEvent() === !1 && (c = !0);
              }),
                c ||
                  (o._moveHandler(d),
                  o.$domEvents.attach(document, "mousemove", o._moveHandler),
                  o.$domEvents.attach(document, "mouseup", o._upHandler));
            }
          }),
          (o._cancelDND = function () {
            o._setBackground(!1), o._clearResizer(), o._clearListeneres();
          }),
          (o._startOnMove = function (d) {
            d.touches &&
              ((o.$gantt._touch_drag = !0),
              (o.$gantt._prevent_touch_scroll = !0)),
              o._isPosChanged(d) && (o._clearListeneres(), o._startDND(d));
          }),
          (o._downHandler = function (d) {
            o._getSiblings(),
              o._behind.$config.collapsed ||
                o._front.$config.collapsed ||
                (o._setBackground(!0),
                (o._resizer = o._setResizer()),
                (o._positions = {
                  x: l(d).x,
                  y: l(d).y,
                  timestamp: Date.now(),
                }),
                o.$domEvents.attach(document, "mousemove", o._startOnMove),
                o.$domEvents.attach(document, "mouseup", o._cancelDND));
          }),
          (o.$name = "resizer"),
          o
        );
      }
      return (
        W(n, t),
        (n.prototype.init = function () {
          var e = this;
          t.prototype.init.call(this),
            (this._xMode = this.$config.mode === "x"),
            this._xMode && !this.$config.width
              ? (this.$config.width = this.$config.minWidth = 1)
              : this._xMode ||
                this.$config.height ||
                (this.$config.height = this.$config.minHeight = 1),
            (this.$config.margin = -1),
            this.$domEvents.attach(this.$view, "mousedown", e._downHandler),
            this.$domEvents.attach(this.$view, "touchstart", e._downHandler),
            this.$domEvents.attach(this.$view, "touchmove", e._startOnMove),
            this.$domEvents.attach(this.$view, "touchend", e._upHandler);
        }),
        (n.prototype.$toHTML = function () {
          var e = this.$config.mode,
            i = this.$config.css || "";
          return (
            "<div class='gantt_layout_cell gantt_resizer gantt_resizer_" +
            e +
            "'><div class='gantt_layout_content gantt_resizer_" +
            e +
            (i ? " " + i : "") +
            "'></div></div>"
          );
        }),
        (n.prototype._clearResizer = function () {
          this._resizer &&
            (this._resizer.parentNode &&
              this._resizer.parentNode.removeChild(this._resizer),
            (this._resizer = null));
        }),
        (n.prototype._isPosChanged = function (e) {
          return (
            !!this._positions &&
            (Math.abs(this._positions.x - e.pageX) > 3 ||
              Math.abs(this._positions.y - e.pageY) > 3 ||
              Date.now() - this._positions.timestamp > 300)
          );
        }),
        (n.prototype._getSiblings = function () {
          var e = this.$parent.getCells();
          this.$config.prev &&
            ((this._behind = this.$factory.getView(this.$config.prev)),
            this._behind instanceof xt ||
              (this._behind = this._behind.$parent)),
            this.$config.next &&
              ((this._front = this.$factory.getView(this.$config.next)),
              this._front instanceof xt ||
                (this._front = this._behind.$parent));
          for (var i = 0; i < e.length; i++)
            this === e[i] &&
              (this._behind || (this._behind = e[i - 1]),
              this._front || (this._front = e[i + 1]));
        }),
        (n.prototype._setBackground = function (e) {
          var i = "gantt_resizing";
          if (!e)
            return (
              Pt(this._behind.$view, i),
              Pt(this._front.$view, i),
              void document.body.classList.remove("gantt_noselect")
            );
          $t(this._behind.$view, i),
            $t(this._front.$view, i),
            document.body.classList.add("gantt_noselect");
        }),
        (n.prototype._setResizer = function () {
          var e = document.createElement("div");
          return (
            (e.className = "gantt_resizer_stick"),
            this.$view.appendChild(e),
            (this.$view.style.overflow = "visible"),
            (e.style.height = this.$view.style.height),
            e
          );
        }),
        (n.prototype._getDirection = function (e, i) {
          var a;
          return (a = this._xMode
            ? e - this._positions.x
            : i - this._positions.y)
            ? a < 0
              ? -1
              : 1
            : 0;
        }),
        (n.prototype._getResizePosition = function (e, i) {
          var a, r, s, o, l;
          this._xMode
            ? ((a = e - this._positions.x),
              (r =
                this._behind.$config.width || this._behind.$view.offsetWidth),
              (o = this._front.$config.width || this._front.$view.offsetWidth),
              (s = this._behind.$config.minWidth),
              (l = this._front.$config.minWidth))
            : ((a = i - this._positions.y),
              (r =
                this._behind.$config.height || this._behind.$view.offsetHeight),
              (o =
                this._front.$config.height || this._front.$view.offsetHeight),
              (s = this._front.$config.minHeight),
              (l = this._front.$config.minHeight));
          var d,
            c,
            u = this._getDirection(e, i);
          if (u === -1) {
            if (
              ((c = o - a),
              (d = r - Math.abs(a)),
              o - a > this._front.$config.maxWidth)
            )
              return;
            Math.abs(a) >= r && (a = -Math.abs(r - 2)),
              r - Math.abs(a) <= s && (a = -Math.abs(r - s));
          } else
            (c = o - Math.abs(a)),
              (d = r + a),
              r + a > this._behind.$config.maxWidth &&
                (a = this._behind.$config.maxWidth - r),
              Math.abs(a) >= o && (a = o - 2),
              o - Math.abs(a) <= l && (a = Math.abs(o - l));
          return (
            u === -1
              ? ((c = o - a), (d = r - Math.abs(a)))
              : ((c = o - Math.abs(a)), (d = r + a)),
            { size: a, newFrontSide: c, newBehindSide: d }
          );
        }),
        (n.prototype._getGroupName = function () {
          return (
            this._getSiblings(),
            this._front.$config.group || this._behind.$config.group
          );
        }),
        (n.prototype._eachGroupItem = function (e, i) {
          for (
            var a = this.$factory.getView("main"),
              r = this._getGroupName(),
              s = a.getCellsByType("resizer"),
              o = 0;
            o < s.length;
            o++
          )
            s[o]._getGroupName() == r &&
              s[o] != this &&
              e.call(i || this, s[o]);
        }),
        (n.prototype._getGroupResizePosition = function (e, i) {
          var a = this._getResizePosition(e, i);
          if (!this._getGroupName()) return a;
          var r,
            s = [a];
          this._eachGroupItem(function (l) {
            l._getSiblings();
            var d = X(this._positions);
            this._xMode
              ? (d.x += l._behind.$config.width - this._behind.$config.width)
              : (d.y += l._behind.$config.height - this._behind.$config.height),
              (l._positions = d),
              s.push(l._getResizePosition(e, i));
          });
          for (var o = 0; o < s.length; o++) {
            if (!s[o]) return;
            (r === void 0 || s[o].newBehindSide > r.newBehindSide) &&
              (r = s[o]);
          }
          return r;
        }),
        (n.prototype._moveResizer = function (e, i, a) {
          if (i !== 0) {
            var r = this._getGroupResizePosition(i, a);
            r &&
              Math.abs(r.size) !== 1 &&
              (this._xMode
                ? ((e.style.left = r.size + "px"),
                  (this._positions.nextX = r.size || 0))
                : ((e.style.top = r.size + "px"),
                  (this._positions.nextY = r.size || 0)),
              this.callEvent("onResize", [r.newBehindSide, r.newFrontSide]));
          }
        }),
        (n.prototype._setGravity = function (e) {
          var i = this._xMode ? "offsetWidth" : "offsetHeight",
            a = this._xMode ? this._positions.nextX : this._positions.nextY,
            r = this._front.$view[i],
            s = this._behind.$view[i],
            o = ((r - a) / r) * this._front.getSize().gravity,
            l = ((s + a) / s) * this._behind.getSize().gravity;
          e !== "front" && (this._front.$config.gravity = o),
            e !== "behind" && (this._behind.$config.gravity = l);
        }),
        (n.prototype._getNewSizes = function () {
          var e, i, a;
          return (
            this._xMode
              ? ((e = this._behind.$config.width),
                (i = this._front.$config.width),
                (a = this._positions.nextX))
              : ((e = this._behind.$config.height),
                (i = this._front.$config.height),
                (a = this._positions.nextY)),
            i || e
              ? { front: i ? i - a || 1 : 0, back: e ? e + a || 1 : 0 }
              : null
          );
        }),
        (n.prototype._assignNewSizes = function (e) {
          this._getSiblings();
          var i = this._xMode ? "width" : "height";
          e
            ? (e.front
                ? (this._front.$config[i] = e.front)
                : this._setGravity("behind"),
              e.back
                ? (this._behind.$config[i] = e.back)
                : this._setGravity("front"))
            : this._setGravity();
        }),
        (n.prototype._setSizes = function () {
          this._resizer && this.$view.removeChild(this._resizer);
          var e = this._getNewSizes();
          if (this._positions.nextX || this._positions.nextY) {
            this._assignNewSizes(e);
            var i,
              a = this._xMode ? "width" : "height";
            (e && e.front) ||
              (this._front.$config.group &&
                ((i = { value: this._front.$config.gravity, isGravity: !0 }),
                this.$gantt.$layout._syncCellSizes(
                  this._front.$config.group,
                  i
                ))),
              (e && e.back) ||
                (this._behind.$config.group &&
                  ((i = { value: this._behind.$config.gravity, isGravity: !0 }),
                  this.$gantt.$layout._syncCellSizes(
                    this._behind.$config.group,
                    i
                  ))),
              e &&
                (e.front
                  ? this._front.$config.group &&
                    ((i = { value: this._front.$config[a], isGravity: !1 }),
                    this.$gantt.$layout._syncCellSizes(
                      this._front.$config.group,
                      i
                    ))
                  : e.back &&
                    this._behind.$config.group &&
                    ((i = { value: this._behind.$config[a], isGravity: !1 }),
                    this.$gantt.$layout._syncCellSizes(
                      this._behind.$config.group,
                      i
                    ))),
              this._getGroupName()
                ? this.$factory.getView("main").resize()
                : this.$parent.resize();
          }
        }),
        n
      );
    })(xt),
    Ya = (function (t) {
      var n = ["altKey", "shiftKey", "metaKey"];
      function e(a, r, s, o) {
        var l = t.apply(this, arguments) || this;
        (this.$config = O(r, { scroll: "x" })),
          (l._scrollHorizontalHandler = z(l._scrollHorizontalHandler, l)),
          (l._scrollVerticalHandler = z(l._scrollVerticalHandler, l)),
          (l._outerScrollVerticalHandler = z(l._outerScrollVerticalHandler, l)),
          (l._outerScrollHorizontalHandler = z(
            l._outerScrollHorizontalHandler,
            l
          )),
          (l._mouseWheelHandler = z(l._mouseWheelHandler, l)),
          (this.$config.hidden = !0);
        var d = o.config.scroll_size;
        return (
          o.env.isIE && (d += 1),
          this._isHorizontal()
            ? ((l.$config.height = d), (l.$parent.$config.height = d))
            : ((l.$config.width = d), (l.$parent.$config.width = d)),
          (this.$config.scrollPosition = 0),
          (l.$name = "scroller"),
          l
        );
      }
      function i(a, r) {
        if ((r.push(a), a.$cells))
          for (var s = 0; s < a.$cells.length; s++) i(a.$cells[s], r);
      }
      return (
        W(e, t),
        (e.prototype.init = function (a) {
          (a.innerHTML = this.$toHTML()),
            (this.$view = a.firstChild),
            this.$view || this.init(),
            this._isVertical() ? this._initVertical() : this._initHorizontal(),
            this._initMouseWheel(),
            this._initLinkedViews();
        }),
        (e.prototype.$toHTML = function () {
          return (
            "<div class='gantt_layout_cell " +
            (this._isHorizontal() ? "gantt_hor_scroll" : "gantt_ver_scroll") +
            "'><div style='" +
            (this._isHorizontal() ? "width:2000px" : "height:2000px") +
            "'></div></div>"
          );
        }),
        (e.prototype._getRootParent = function () {
          for (var a = this.$parent; a && a.$parent; ) a = a.$parent;
          if (a) return a;
        }),
        (e.prototype._eachView = function () {
          var a = [];
          return i(this._getRootParent(), a), a;
        }),
        (e.prototype._getLinkedViews = function () {
          for (var a = this._eachView(), r = [], s = 0; s < a.length; s++)
            a[s].$config &&
              ((this._isVertical() && a[s].$config.scrollY == this.$id) ||
                (this._isHorizontal() && a[s].$config.scrollX == this.$id)) &&
              r.push(a[s]);
          return r;
        }),
        (e.prototype._initHorizontal = function () {
          (this.$scroll_hor = this.$view),
            this.$domEvents.attach(
              this.$view,
              "scroll",
              this._scrollHorizontalHandler
            );
        }),
        (e.prototype._initLinkedViews = function () {
          for (
            var a = this._getLinkedViews(),
              r = this._isVertical()
                ? "gantt_layout_outer_scroll gantt_layout_outer_scroll_vertical"
                : "gantt_layout_outer_scroll gantt_layout_outer_scroll_horizontal",
              s = 0;
            s < a.length;
            s++
          )
            $t(a[s].$view || a[s].getNode(), r);
        }),
        (e.prototype._initVertical = function () {
          (this.$scroll_ver = this.$view),
            this.$domEvents.attach(
              this.$view,
              "scroll",
              this._scrollVerticalHandler
            );
        }),
        (e.prototype._updateLinkedViews = function () {}),
        (e.prototype._initMouseWheel = function () {
          kt.isFF
            ? this.$domEvents.attach(
                this._getRootParent().$view,
                "wheel",
                this._mouseWheelHandler,
                { passive: !1 }
              )
            : this.$domEvents.attach(
                this._getRootParent().$view,
                "mousewheel",
                this._mouseWheelHandler,
                {
                  passive: !1,
                }
              );
        }),
        (e.prototype.scrollHorizontally = function (a) {
          if (!this._scrolling) {
            (this._scrolling = !0),
              (this.$scroll_hor.scrollLeft = a),
              (this.$config.codeScrollLeft = a),
              (a = this.$scroll_hor.scrollLeft);
            for (var r = this._getLinkedViews(), s = 0; s < r.length; s++)
              r[s].scrollTo && r[s].scrollTo(a, void 0);
            var o = this.$config.scrollPosition;
            (this.$config.scrollPosition = a),
              this.callEvent("onScroll", [o, a, this.$config.scroll]),
              (this._scrolling = !1);
          }
        }),
        (e.prototype.scrollVertically = function (a) {
          if (!this._scrolling) {
            (this._scrolling = !0),
              (this.$scroll_ver.scrollTop = a),
              (a = this.$scroll_ver.scrollTop);
            for (var r = this._getLinkedViews(), s = 0; s < r.length; s++)
              r[s].scrollTo && r[s].scrollTo(void 0, a);
            var o = this.$config.scrollPosition;
            (this.$config.scrollPosition = a),
              this.callEvent("onScroll", [o, a, this.$config.scroll]),
              (this._scrolling = !1);
          }
        }),
        (e.prototype._isVertical = function () {
          return this.$config.scroll == "y";
        }),
        (e.prototype._isHorizontal = function () {
          return this.$config.scroll == "x";
        }),
        (e.prototype._scrollHorizontalHandler = function (a) {
          if (!this._isVertical() && !this._scrolling) {
            if (new Date() - (this._wheel_time || 0) < 100) return !0;
            var r = this.$scroll_hor.scrollLeft;
            this.scrollHorizontally(r),
              (this._oldLeft = this.$scroll_hor.scrollLeft);
          }
        }),
        (e.prototype._outerScrollHorizontalHandler = function (a) {
          this._isVertical();
        }),
        (e.prototype.show = function () {
          this.$parent.show();
        }),
        (e.prototype.hide = function () {
          this.$parent.hide();
        }),
        (e.prototype._getScrollSize = function () {
          for (
            var a,
              r = 0,
              s = 0,
              o = this._isHorizontal(),
              l = this._getLinkedViews(),
              d = o ? "scrollWidth" : "scrollHeight",
              c = o ? "contentX" : "contentY",
              u = o ? "x" : "y",
              h = this._getScrollOffset(),
              _ = 0;
            _ < l.length;
            _++
          )
            if (
              (a = l[_]) &&
              a.$content &&
              a.$content.getSize &&
              !a.$config.hidden
            ) {
              var f,
                y = a.$content.getSize();
              if (((f = y.hasOwnProperty(d) ? y[d] : y[c]), h))
                y[c] > y[u] &&
                  y[c] > r &&
                  f > y[u] - h + 2 &&
                  ((r = f + (o ? 0 : 2)), (s = y[u]));
              else {
                var v = Math.max(y[c] - f, 0);
                (f += v) > Math.max(y[u] - v, 0) &&
                  f > r &&
                  ((r = f), (s = y[u]));
              }
            }
          return { outerScroll: s, innerScroll: r };
        }),
        (e.prototype.scroll = function (a) {
          this._isHorizontal()
            ? this.scrollHorizontally(a)
            : this.scrollVertically(a);
        }),
        (e.prototype.getScrollState = function () {
          return {
            visible: this.isVisible(),
            direction: this.$config.scroll,
            size: this.$config.outerSize,
            scrollSize: this.$config.scrollSize || 0,
            position: this.$config.scrollPosition || 0,
          };
        }),
        (e.prototype.setSize = function (a, r) {
          t.prototype.setSize.apply(this, arguments);
          var s = this._getScrollSize(),
            o =
              (this._isVertical() ? r : a) -
              this._getScrollOffset() +
              (this._isHorizontal() ? 1 : 0);
          s.innerScroll &&
            o > s.outerScroll &&
            (s.innerScroll += o - s.outerScroll),
            (this.$config.scrollSize = s.innerScroll),
            (this.$config.width = a),
            (this.$config.height = r),
            this._setScrollSize(s.innerScroll);
        }),
        (e.prototype.isVisible = function () {
          return !(!this.$parent || !this.$parent.$view.parentNode);
        }),
        (e.prototype.shouldShow = function () {
          var a = this._getScrollSize();
          return (
            !(
              !a.innerScroll &&
              this.$parent &&
              this.$parent.$view.parentNode
            ) &&
            !(!a.innerScroll || (this.$parent && this.$parent.$view.parentNode))
          );
        }),
        (e.prototype.shouldHide = function () {
          return !(
            this._getScrollSize().innerScroll ||
            !this.$parent ||
            !this.$parent.$view.parentNode
          );
        }),
        (e.prototype.toggleVisibility = function () {
          this.shouldHide() ? this.hide() : this.shouldShow() && this.show();
        }),
        (e.prototype._getScaleOffset = function (a) {
          var r = 0;
          return (
            !a ||
              (a.$config.view != "timeline" && a.$config.view != "grid") ||
              (r = a.$content.$getConfig().scale_height),
            r
          );
        }),
        (e.prototype._getScrollOffset = function () {
          var a = 0;
          if (this._isVertical()) {
            var r = this.$parent.$parent;
            a = Math.max(
              this._getScaleOffset(r.getPrevSibling(this.$parent.$id)),
              this._getScaleOffset(r.getNextSibling(this.$parent.$id))
            );
          } else
            for (var s = this._getLinkedViews(), o = 0; o < s.length; o++) {
              var l = s[o].$parent.$cells,
                d = l[l.length - 1];
              if (
                d &&
                d.$config.view == "scrollbar" &&
                d.$config.hidden === !1
              ) {
                a = d.$config.width;
                break;
              }
            }
          return a || 0;
        }),
        (e.prototype._setScrollSize = function (a) {
          var r = this._isHorizontal() ? "width" : "height",
            s = this._isHorizontal() ? this.$scroll_hor : this.$scroll_ver,
            o = this._getScrollOffset(),
            l = s.firstChild;
          o
            ? this._isVertical()
              ? ((this.$config.outerSize = this.$config.height - o + 3),
                (s.style.height = this.$config.outerSize + "px"),
                (s.style.top = o - 1 + "px"),
                $t(s, this.$parent._borders.top),
                $t(s.parentNode, "gantt_task_vscroll"))
              : ((this.$config.outerSize = this.$config.width - o + 1),
                (s.style.width = this.$config.outerSize + "px"))
            : ((s.style.top = "auto"),
              Pt(s, this.$parent._borders.top),
              Pt(s.parentNode, "gantt_task_vscroll"),
              (this.$config.outerSize = this.$config.height)),
            (l.style[r] = a + "px");
        }),
        (e.prototype._scrollVerticalHandler = function (a) {
          if (!this._scrollHorizontalHandler() && !this._scrolling) {
            var r = this.$scroll_ver.scrollTop;
            r != this._oldTop &&
              (this.scrollVertically(r),
              (this._oldTop = this.$scroll_ver.scrollTop));
          }
        }),
        (e.prototype._outerScrollVerticalHandler = function (a) {
          this._scrollHorizontalHandler();
        }),
        (e.prototype._checkWheelTarget = function (a) {
          for (
            var r = this._getLinkedViews().concat(this), s = 0;
            s < r.length;
            s++
          )
            if (tt(a, r[s].$view)) return !0;
          return !1;
        }),
        (e.prototype._mouseWheelHandler = function (a) {
          var r = a.target || a.srcElement;
          if (this._checkWheelTarget(r)) {
            this._wheel_time = new Date();
            var s = {},
              o = { x: 1, y: 1 },
              l = this.$gantt.config.wheel_scroll_sensitivity;
            typeof l == "number" && l
              ? (o = { x: l, y: l })
              : {}.toString.apply(l) == "[object Object]" &&
                (o = { x: l.x, y: l.y });
            var d = kt.isFF,
              c = d ? a.deltaX : a.wheelDeltaX,
              u = d ? a.deltaY : a.wheelDelta,
              h = -20;
            if (d) {
              const k = parseInt(navigator.userAgent.split("Firefox/")[1]);
              h =
                k <= 87
                  ? a.deltaMode !== 0
                    ? -40
                    : -10
                  : k <= 90
                  ? -3
                  : k <= 96
                  ? -1.5
                  : -1;
            }
            var _ = d ? c * h * o.x : 2 * c * o.x,
              f = d ? u * h * o.y : u * o.y,
              y = this.$gantt.config.horizontal_scroll_key;
            if (
              (y !== !1 &&
                n.indexOf(y) >= 0 &&
                (!a[y] || a.deltaX || a.wheelDeltaX || ((_ = 2 * f), (f = 0))),
              _ && Math.abs(_) > Math.abs(f))
            ) {
              if (this._isVertical()) return;
              if (s.x || !this.$scroll_hor || !this.$scroll_hor.offsetWidth)
                return !0;
              var v = _ / -40,
                b = this._oldLeft,
                g = b + 30 * v;
              if (
                (this.scrollHorizontally(g),
                (this.$scroll_hor.scrollLeft = g),
                b == this.$scroll_hor.scrollLeft)
              )
                return !0;
              this._oldLeft = this.$scroll_hor.scrollLeft;
            } else {
              if (this._isHorizontal()) return;
              if (s.y || !this.$scroll_ver || !this.$scroll_ver.offsetHeight)
                return !0;
              (v = f / -40), f === void 0 && (v = a.detail);
              var m = this._oldTop,
                p = this.$scroll_ver.scrollTop + 30 * v;
              if (
                (this.scrollVertically(p),
                (this.$scroll_ver.scrollTop = p),
                m == this.$scroll_ver.scrollTop)
              )
                return !0;
              this._oldTop = this.$scroll_ver.scrollTop;
            }
            return (
              a.preventDefault && a.preventDefault(), (a.cancelBubble = !0), !1
            );
          }
        }),
        e
      );
    })(xt),
    Ja = function (t, n) {
      var e = {},
        i = "gantt-static-bg-styles-" + t.uid();
      function a(u) {
        var h =
          /^rgba?\(([\d]{1,3}), *([\d]{1,3}), *([\d]{1,3}) *(,( *[\d.]+ *))?\)$/i.exec(
            u
          );
        return h
          ? { r: 1 * h[1], g: 1 * h[2], b: 1 * h[3], a: 255 * h[5] || 255 }
          : null;
      }
      function r(u) {
        return e[u] || null;
      }
      function s(u, h, _) {
        return (u + "" + h + _.bottomBorderColor + _.rightBorderColor).replace(
          /[^\w\d]/g,
          ""
        );
      }
      function o(u, h) {
        e[u] = h;
      }
      function l(u, h, _) {
        var f = Math.floor(500 / u) || 1,
          y = Math.floor(500 / h) || 1,
          v = document.createElement("canvas");
        (v.height = h * y), (v.width = u * f);
        var b = v.getContext("2d");
        return (
          (function (m, p, k, w, x, $) {
            var S = x.createImageData(p * w, m * k);
            S.imageSmoothingEnabled = !1;
            for (
              var T = 1 * $.rightBorderWidth,
                E = a($.rightBorderColor),
                C = 0,
                D = 0,
                A = 0,
                I = 1;
              I <= w;
              I++
            )
              for (C = I * p - 1, A = 0; A < T; A++)
                for (D = 0; D < m * k; D++) g(C - A, D, E, S);
            var M = 1 * $.bottomBorderWidth,
              L = a($.bottomBorderColor);
            D = 0;
            for (var N = 1; N <= k; N++)
              for (D = N * m - 1, A = 0; A < M; A++)
                for (C = 0; C < p * w; C++) g(C, D - A, L, S);
            x.putImageData(S, 0, 0);
          })(h, u, y, f, b, _),
          v.toDataURL()
        );
        function g(m, p, k, w) {
          var x = 4 * (p * (u * f) + m);
          (w.data[x] = k.r),
            (w.data[x + 1] = k.g),
            (w.data[x + 2] = k.b),
            (w.data[x + 3] = k.a);
        }
      }
      function d(u) {
        return "gantt-static-bg-" + u;
      }
      function c() {
        var u = document.createElement("div");
        u.className = "gantt_task_cell";
        var h = document.createElement("div");
        return (h.className = "gantt_task_row"), h.appendChild(u), h;
      }
      return {
        render: function (u, h, _, f, y) {
          if (
            (h.static_background || h.timeline_placeholder) &&
            document.createElement("canvas").getContext
          ) {
            u.innerHTML = "";
            var v = (function (p) {
                var k = c(),
                  w = c();
                p.appendChild(k), p.appendChild(w);
                var x = k.firstChild,
                  $ = getComputedStyle(k),
                  S = getComputedStyle(x),
                  T = {
                    bottomBorderWidth: $.getPropertyValue(
                      "border-bottom-width"
                    ).replace("px", ""),
                    rightBorderWidth: S.getPropertyValue(
                      "border-right-width"
                    ).replace("px", ""),
                    bottomBorderColor: $.getPropertyValue(
                      "border-bottom-color"
                    ),
                    rightBorderColor: S.getPropertyValue("border-right-color"),
                  };
                return p.removeChild(k), p.removeChild(w), T;
              })(u),
              b = (function (p, k, w, x) {
                var $ = {},
                  S = (function (M) {
                    for (var L = M.width, N = {}, P = 0; P < L.length; P++)
                      1 * L[P] && (N[L[P]] = !0);
                    return N;
                  })(w),
                  T = x,
                  E = "";
                for (var C in S) {
                  var D = 1 * C,
                    A = s(D, T, p);
                  if (!r(A)) {
                    var I = l(D, T, p);
                    o(A, I),
                      (E +=
                        "." + d(A) + "{ background-image: url('" + I + "');}");
                  }
                  $[C] = d(A);
                }
                return (
                  E &&
                    ((function () {
                      var M = document.getElementById(i);
                      return (
                        M ||
                          (((M = document.createElement("style")).id = i),
                          document.body.appendChild(M)),
                        M
                      );
                    })().innerHTML += E),
                  $
                );
              })(v, 0, _, y),
              g = (function (p, k, w, x) {
                var $,
                  S,
                  T = [],
                  E = 0,
                  C = w.width.filter(function (F) {
                    return !!F;
                  }),
                  D = 0,
                  A = 1e5;
                if (n.isIE) {
                  var I = navigator.appVersion || "";
                  (I.indexOf("Windows NT 6.2") == -1 &&
                    I.indexOf("Windows NT 6.1") == -1 &&
                    I.indexOf("Windows NT 6.0") == -1) ||
                    (A = 2e4);
                }
                for (var M = 0; M < C.length; M++) {
                  var L = C[M];
                  if ((L != S && S !== void 0) || M == C.length - 1 || E > A) {
                    for (
                      var N = x,
                        P = 0,
                        R = Math.floor(A / k.row_height) * k.row_height,
                        B = E;
                      N > 0;

                    ) {
                      var H = Math.min(N, R);
                      (N -= R),
                        (($ = document.createElement("div")).style.height =
                          H + "px"),
                        ($.style.position = "absolute"),
                        ($.style.top = P + "px"),
                        ($.style.left = D + "px"),
                        ($.style.pointerEvents = "none"),
                        ($.style.whiteSpace = "no-wrap"),
                        ($.className = p[S || L]),
                        M == C.length - 1 && (B = L + B - 1),
                        ($.style.width = B + "px"),
                        T.push($),
                        (P += H);
                    }
                    (E = 0), (D += B);
                  }
                  L && ((E += L), (S = L));
                }
                return T;
              })(b, h, _, f),
              m = document.createDocumentFragment();
            g.forEach(function (p) {
              m.appendChild(p);
            }),
              u.appendChild(m);
          }
        },
        destroy: function () {
          var u = document.getElementById(i);
          u && u.parentNode && u.parentNode.removeChild(u);
        },
      };
    };
  const Ka = function () {
    return Ja(vn, kt);
  };
  var je = function (t, n, e, i) {
    (this.$config = O({}, n || {})),
      (this.$scaleHelper = new En(i)),
      (this.$gantt = i),
      (this._posFromDateCache = {}),
      (this._timelineDragScroll = null),
      O(this, Nn(this)),
      ct(this);
  };
  function Fe(t) {
    if ((t._delayRender && t._delayRender.$cancelTimeout(), t.$gantt)) {
      var n = t.$gantt.$data.tasksStore,
        e = t.$config.rowStore,
        i = "_attached_" + e.$config.name;
      t[i] && (n.detachEvent(t[i]), (t[i] = null)),
        e.$attachedResourceViewHandler &&
          (e.detachEvent(e.$attachedResourceViewHandler),
          (e.$attachedResourceViewHandler = null),
          n.detachEvent(e.$attachedTaskStoreHandler),
          (e.$attachedTaskStoreHandler = null));
    }
  }
  function We(t) {
    var n = t.prototype.init,
      e = t.prototype.destructor;
    return {
      init: function () {
        n.apply(this, arguments), this._linkToTaskStore();
      },
      destructor: function () {
        Fe(this), e.apply(this, arguments);
      },
      previousDragId: null,
      relevantResources: null,
      _linkToTaskStore: function () {
        if (this.$config.rowStore && this.$gantt.$data.tasksStore) {
          var i = this.$gantt.$data.tasksStore,
            a = this.$config.rowStore;
          Fe(this);
          var r = this,
            s = Xt(function () {
              if (r.$gantt.getState().lightbox) s();
              else {
                const l = r.$config.rowStore,
                  d = r._getRelevantResources();
                if (d && l.$config.name === r.$gantt.config.resource_store) {
                  if (d == "nothing_to_repaint") return;
                  (l._quick_refresh = !0),
                    r.relevantResources.forEach(function (c) {
                      l.refresh(c);
                    }),
                    (l._quick_refresh = !1);
                } else l.refresh();
              }
            }, 300);
          this._delayRender = s;
          var o = "_attached_" + a.$config.name;
          r[o] ||
            (r[o] = i.attachEvent("onStoreUpdated", function () {
              if (!s.$pending && !this._skipResourceRepaint) {
                const l = r.$gantt.getState();
                if (l.drag_mode == "progress") return !0;
                l.drag_mode && l.drag_id && (r.previousDragId = l.drag_id), s();
              }
              return !0;
            })),
            this.$gantt.attachEvent("onDestroy", function () {
              return Fe(r), !0;
            }),
            a.$attachedResourceViewHandler ||
              ((a.$attachedResourceViewHandler = a.attachEvent(
                "onBeforeFilter",
                function () {
                  return (
                    !r.$gantt.getState().lightbox &&
                    (s.$pending && s.$cancelTimeout(),
                    r._updateNestedTasks(),
                    !0)
                  );
                }
              )),
              (a.$attachedTaskStoreHandler = i.attachEvent(
                "onAfterDelete",
                function () {
                  a._mark_recompute = !0;
                }
              )));
        }
      },
      _getRelevantResources: function () {
        if (!this.$gantt.getTaskAssignments) return null;
        const i = this.$gantt.getState(),
          a = this.$config.rowStore;
        let r = [];
        if (i.drag_mode && i.drag_id)
          if (this.previousDragId == i.drag_id) {
            if (this.relevantResources) return this.relevantResources;
            r = this._getIdsFromAssignments(this.previousDragId);
          } else
            (this.previousDragId = i.drag_id),
              (r = this._getIdsFromAssignments(this.previousDragId));
        else {
          if (!this.previousDragId) return null;
          (r = this._getIdsFromAssignments(this.previousDragId)),
            (this.previousDragId = null);
        }
        return r.length
          ? (r.forEach(function (s) {
              a.eachParent(function (o) {
                r.push(o.id);
              }, s);
            }),
            (this.relevantResources = [...new Set(r)]))
          : (this.relevantResources = "nothing_to_repaint");
      },
      _getIdsFromAssignments: function (i) {
        const a = this.$gantt,
          r = [],
          s = a.getTask(i);
        return (
          a.getTaskAssignments(i).forEach(function (o) {
            r.push(o.resource_id);
          }),
          a.isSummaryTask(s) &&
            a.config.drag_project &&
            a.eachTask(function (o) {
              a.getTaskAssignments(o.id).forEach(function (l) {
                r.push(l.resource_id);
              });
            }, i),
          a.config.drag_multiple &&
            a.getSelectedTasks &&
            a.getSelectedTasks().forEach(function (o) {
              a.getTaskAssignments(o).forEach(function (l) {
                r.push(l.resource_id);
              });
            }),
          r
        );
      },
      _updateNestedTasks: function () {
        var i = this.$gantt,
          a = i.getDatastore(i.config.resource_store);
        a.$config.fetchTasks &&
          a.silent(function () {
            var r = [],
              s = {},
              o = {};
            for (var l in (a.eachItem(function (d) {
              if (d.$role != "task") {
                var c = i.getResourceAssignments(d.id),
                  u = {};
                c.sort(function (h, _) {
                  const f = a.pull,
                    y = f[`${h.task_id}_${h.resource_id}`],
                    v = f[`${_.task_id}_${_.resource_id}`];
                  return y && v ? y.$local_index - v.$local_index : 0;
                }),
                  c.forEach(function (h) {
                    if (!u[h.task_id] && i.isTaskExists(h.task_id)) {
                      u[h.task_id] = !0;
                      var _,
                        f = i.getTask(h.task_id);
                      ((_ = a.$config.copyOnParse
                        ? i.copy(f)
                        : Object.create(f)).id = f.id + "_" + d.id),
                        (_.$task_id = f.id),
                        (_.$resource_id = d.id),
                        (_[a.$parentProperty] = d.id),
                        (_.$role = "task"),
                        r.push(_),
                        (s[_.id] = !0);
                    }
                  });
              } else o[d.id] = !0;
            }),
            o))
              s[l] || a.removeItem(l);
            r.length && a.parse(r);
          });
      },
    };
  }
  je.prototype = {
    init: function (t) {
      (t.innerHTML +=
        "<div class='gantt_task' style='width:inherit;height:inherit;'></div>"),
        (this.$task = t.childNodes[0]),
        (this.$task.innerHTML =
          "<div class='gantt_task_scale'></div><div class='gantt_data_area'></div>"),
        (this.$task_scale = this.$task.childNodes[0]),
        (this.$task_data = this.$task.childNodes[1]),
        (this.$task_data.innerHTML =
          "<div class='gantt_task_bg'></div><div class='gantt_task_baselines'></div><div class='gantt_links_area'></div><div class='gantt_bars_area'></div><div class='gantt_task_constraints'></div><div class='gantt_task_deadlines'></div>"),
        (this.$task_bg = this.$task_data.childNodes[0]),
        (this.$task_baselines = this.$task_data.childNodes[1]),
        (this.$task_links = this.$task_data.childNodes[2]),
        (this.$task_bars = this.$task_data.childNodes[3]),
        (this.$task_constraints = this.$task_data.childNodes[4]),
        (this.$task_deadlines = this.$task_data.childNodes[5]),
        (this._tasks = {
          col_width: 0,
          width: [],
          full_width: 0,
          trace_x: [],
          rendered: {},
        });
      var n = this.$getConfig(),
        e = n[this.$config.bind + "_attribute"],
        i = n[this.$config.bindLinks + "_attribute"];
      !e && this.$config.bind && (e = "data-" + this.$config.bind + "-id"),
        !i &&
          this.$config.bindLinks &&
          (i = "data-" + this.$config.bindLinks + "-id"),
        (this.$config.item_attribute = e || null),
        (this.$config.link_attribute = i || null);
      var a = this._createLayerConfig();
      this.$config.layers || (this.$config.layers = a.tasks),
        this.$config.linkLayers || (this.$config.linkLayers = a.links),
        this._attachLayers(this.$gantt),
        this.callEvent("onReady", []),
        this.$gantt.ext.dragTimeline &&
          ((this._timelineDragScroll = this.$gantt.ext.dragTimeline.create()),
          this._timelineDragScroll.attach(this));
    },
    setSize: function (t, n) {
      var e = this.$getConfig();
      if ((1 * t === t && (this.$config.width = t), 1 * n === n)) {
        this.$config.height = n;
        var i = Math.max(this.$config.height - e.scale_height);
        this.$task_data.style.height = i + "px";
      }
      this.refresh(),
        (this.$task_bg.style.backgroundImage = ""),
        e.smart_rendering && this.$config.rowStore
          ? (this.$task_bg.style.height = this.getTotalHeight() + "px")
          : (this.$task_bg.style.height = "");
      for (
        var a = this._tasks,
          r = this.$task_data.childNodes,
          s = 0,
          o = r.length;
        s < o;
        s++
      ) {
        var l = r[s];
        l.hasAttribute("data-layer") &&
          l.style &&
          (l.style.width = a.full_width + "px");
      }
    },
    isVisible: function () {
      return this.$parent && this.$parent.$config
        ? !this.$parent.$config.hidden
        : this.$task.offsetWidth;
    },
    getSize: function () {
      var t = this.$getConfig(),
        n = this.$config.rowStore ? this.getTotalHeight() : 0,
        e = this.isVisible() ? this._tasks.full_width : 0;
      return {
        x: this.isVisible() ? this.$config.width : 0,
        y: this.isVisible() ? this.$config.height : 0,
        contentX: this.isVisible() ? e : 0,
        contentY: this.isVisible() ? t.scale_height + n : 0,
        scrollHeight: this.isVisible() ? n : 0,
        scrollWidth: this.isVisible() ? e : 0,
      };
    },
    scrollTo: function (t, n) {
      if (this.isVisible()) {
        var e = !1;
        (this.$config.scrollTop = this.$config.scrollTop || 0),
          (this.$config.scrollLeft = this.$config.scrollLeft || 0),
          1 * n === n &&
            ((this.$config.scrollTop = n),
            (this.$task_data.scrollTop = this.$config.scrollTop),
            (e = !0)),
          1 * t === t &&
            ((this.$task.scrollLeft = t),
            (this.$config.scrollLeft = this.$task.scrollLeft),
            this._refreshScales(),
            (e = !0)),
          e &&
            this.callEvent("onScroll", [
              this.$config.scrollLeft,
              this.$config.scrollTop,
            ]);
      }
    },
    _refreshScales: function () {
      if (this.isVisible() && this.$getConfig().smart_scales) {
        var t = this.getViewPort(),
          n = this._scales;
        this.$task_scale.innerHTML = this._getScaleChunkHtml(n, t.x, t.x_end);
      }
    },
    getViewPort: function () {
      var t = this.$config.scrollLeft || 0,
        n = this.$config.scrollTop || 0,
        e = this.$config.height || 0,
        i = this.$config.width || 0;
      return { y: n, y_end: n + e, x: t, x_end: t + i, height: e, width: i };
    },
    _createLayerConfig: function () {
      var t = this,
        n = function () {
          return t.isVisible();
        };
      const e = this.$gantt,
        i = function (r, s) {
          return s.type === e.config.types.project && s.auto_scheduling === !1;
        };
      var a = [
        {
          expose: !0,
          renderer: this.$gantt.$ui.layers.taskBar(),
          container: this.$task_bars,
          filter: [
            n,
            function (r, s) {
              return !s.hide_bar;
            },
            function (r, s) {
              return !i(0, s);
            },
          ],
        },
        {
          renderer: this.$gantt.$ui.layers.timedProjectBar(),
          filter: [n, i],
          container: this.$task_bars,
          append: !0,
        },
        {
          renderer: this.$gantt.$ui.layers.taskSplitBar(),
          filter: [n],
          container: this.$task_bars,
          append: !0,
        },
        {
          renderer: this.$gantt.$ui.layers.taskRollupBar(),
          filter: [n],
          container: this.$task_bars,
          append: !0,
        },
        {
          renderer: this.$gantt.$ui.layers.taskConstraints(),
          filter: [n],
          container: this.$task_constraints,
          append: !1,
        },
      ];
      return (
        e.config.deadlines &&
          a.push({
            renderer: this.$gantt.$ui.layers.taskDeadline(),
            filter: [n],
            container: this.$task_deadlines,
            append: !1,
          }),
        e.config.baselines &&
          a.push({
            renderer: this.$gantt.$ui.layers.taskBaselines(),
            filter: [n],
            container: this.$task_baselines,
            append: !1,
          }),
        a.push({
          renderer: this.$gantt.$ui.layers.taskBg(),
          container: this.$task_bg,
          filter: [n],
        }),
        {
          tasks: a,
          links: [
            {
              expose: !0,
              renderer: this.$gantt.$ui.layers.link(),
              container: this.$task_links,
              filter: [n],
            },
          ],
        }
      );
    },
    _attachLayers: function (t) {
      (this._taskLayers = []), (this._linkLayers = []);
      var n = this,
        e = this.$gantt.$services.getService("layers");
      if (this.$config.bind) {
        this._bindStore();
        var i = e.getDataRender(this.$config.bind);
        i ||
          (i = e.createDataRender({
            name: this.$config.bind,
            defaultContainer: function () {
              return n.$task_data;
            },
          })),
          (i.container = function () {
            return n.$task_data;
          });
        for (var a = this.$config.layers, r = 0; a && r < a.length; r++) {
          typeof (d = a[r]) == "string" && (d = this.$gantt.$ui.layers[d]()),
            (typeof d == "function" || (d && d.render && d.update)) &&
              (d = { renderer: d }),
            (d.view = this);
          var s = i.addLayer(d);
          this._taskLayers.push(s),
            d.expose && (this._taskRenderer = i.getLayer(s));
        }
        this._initStaticBackgroundRender();
      }
      if (this.$config.bindLinks) {
        n.$config.linkStore = n.$gantt.getDatastore(n.$config.bindLinks);
        var o = e.getDataRender(this.$config.bindLinks);
        o ||
          (o = e.createDataRender({
            name: this.$config.bindLinks,
            defaultContainer: function () {
              return n.$task_data;
            },
          }));
        var l = this.$config.linkLayers;
        for (r = 0; l && r < l.length; r++) {
          var d;
          typeof d == "string" && (d = this.$gantt.$ui.layers[d]()),
            ((d = l[r]).view = this);
          var c = o.addLayer(d);
          this._taskLayers.push(c),
            l[r].expose && (this._linkRenderer = o.getLayer(c));
        }
      }
    },
    _initStaticBackgroundRender: function () {
      var t = this,
        n = Ka(),
        e = t.$config.rowStore;
      e &&
        ((this._staticBgHandler = e.attachEvent(
          "onStoreUpdated",
          function (i, a, r) {
            if (i === null && t.isVisible()) {
              var s = t.$getConfig();
              if (s.static_background || s.timeline_placeholder) {
                var o = t.$gantt.getDatastore(t.$config.bind),
                  l = t.$task_bg_static;
                if (
                  (l ||
                    (((l = document.createElement("div")).className =
                      "gantt_task_bg"),
                    (t.$task_bg_static = l),
                    t.$task_bg.nextSibling
                      ? t.$task_data.insertBefore(l, t.$task_bg.nextSibling)
                      : t.$task_data.appendChild(l)),
                  o)
                ) {
                  var d = t.getTotalHeight();
                  s.timeline_placeholder &&
                    (d =
                      s.timeline_placeholder.height ||
                      t.$task_data.offsetHeight ||
                      99999),
                    n.render(
                      l,
                      s,
                      t.getScale(),
                      d,
                      t.getItemHeight(a ? a.id : null)
                    );
                }
              } else
                s.static_background &&
                  t.$task_bg_static &&
                  t.$task_bg_static.parentNode &&
                  t.$task_bg_static.parentNode.removeChild(t.$task_bg_static);
            }
          }
        )),
        this.attachEvent("onDestroy", function () {
          n.destroy();
        }),
        (this._initStaticBackgroundRender = function () {}));
    },
    _clearLayers: function (t) {
      var n = this.$gantt.$services.getService("layers"),
        e = n.getDataRender(this.$config.bind),
        i = n.getDataRender(this.$config.bindLinks);
      if (this._taskLayers)
        for (var a = 0; a < this._taskLayers.length; a++)
          e.removeLayer(this._taskLayers[a]);
      if (this._linkLayers)
        for (a = 0; a < this._linkLayers.length; a++)
          i.removeLayer(this._linkLayers[a]);
      (this._linkLayers = []), (this._taskLayers = []);
    },
    _render_tasks_scales: function () {
      var t = this.$getConfig(),
        n = "",
        e = 0,
        i = 0,
        a = this.$gantt.getState();
      if (this.isVisible()) {
        var r = this.$scaleHelper,
          s = this._getScales();
        i = t.scale_height;
        var o = this.$config.width;
        (t.autosize != "x" && t.autosize != "xy") ||
          (o = Math.max(t.autosize_min_width, 0));
        var l = r.prepareConfigs(
            s,
            t.min_column_width,
            o,
            i - 1,
            a.min_date,
            a.max_date,
            t.rtl
          ),
          d = (this._tasks = l[l.length - 1]);
        (this._scales = l),
          (this._posFromDateCache = {}),
          (n = this._getScaleChunkHtml(l, 0, this.$config.width)),
          (e = d.full_width + "px"),
          (i += "px");
      }
      (this.$task_scale.style.height = i),
        (this.$task_data.style.width = this.$task_scale.style.width = e),
        (this.$task_scale.innerHTML = n);
    },
    _getScaleChunkHtml: function (t, n, e) {
      for (
        var i = [], a = this.$gantt.templates.scale_row_class, r = 0;
        r < t.length;
        r++
      ) {
        var s = "gantt_scale_line",
          o = a(t[r]);
        o && (s += " " + o),
          i.push(
            '<div class="' +
              s +
              '" style="height:' +
              t[r].height +
              "px;position:relative;line-height:" +
              t[r].height +
              'px">' +
              this._prepareScaleHtml(t[r], n, e, r) +
              "</div>"
          );
      }
      return i.join("");
    },
    _prepareScaleHtml: function (t, n, e, i) {
      var a = this.$getConfig(),
        r = this.$gantt.templates,
        s = [],
        o = null,
        l = null,
        d = t.format || t.template || t.date;
      typeof d == "string" && (d = this.$gantt.date.date_to_str(d));
      var c = 0,
        u = t.count;
      !a.smart_scales ||
        isNaN(n) ||
        isNaN(e) ||
        ((c = Bt(t.left, n)), (u = Bt(t.left, e) + 1)),
        (l = t.css || function () {}),
        !t.css && a.inherit_scale_class && (l = r.scale_cell_class);
      for (var h = c; h < u && t.trace_x[h]; h++) {
        o = new Date(t.trace_x[h]);
        var _ = d.call(this, o),
          f = t.width[h];
        t.height;
        var y = t.left[h],
          v = "",
          b = "",
          g = "";
        if (f) {
          v =
            "width:" +
            f +
            "px;" +
            (a.smart_scales ? "position:absolute;left:" + y + "px" : "");
          const p = this.getViewPort(),
            k = (a.scales[i] || {}).sticky;
          let w = "";
          const x = 70;
          if ((k !== !1 && f > x) || k === !0) {
            if (y < p.x && y + f / 2 - x / 2 < p.x)
              w = ` style='position:absolute;left: ${p.x - y + 10}px;' `;
            else if (y + f / 2 + x / 2 > p.x_end && f > x) {
              let $ = p.x_end - y - 10,
                S = "-100%";
              $ < x && (($ = x), (S = `-${$}px`)),
                (w = ` style='position:absolute;left: ${$}px;transform: translate(${S},0);' `);
            }
          }
          (g =
            "gantt_scale_cell" + (h == t.count - 1 ? " gantt_last_cell" : "")),
            (b = l.call(this, o)) && (g += " " + b);
          var m = `<div class='${g}' ${this.$gantt._waiAria.getTimelineCellAttr(
            _
          )} style='${v}'><span ${w}>${_}</span></div>`;
          s.push(m);
        }
      }
      return s.join("");
    },
    dateFromPos: function (t) {
      var n = this._tasks;
      if (t < 0 || t > n.full_width || !n.full_width) return null;
      var e = Bt(this._tasks.left, t),
        i = this._tasks.left[e],
        a = n.width[e] || n.col_width,
        r = 0;
      a && ((r = (t - i) / a), n.rtl && (r = 1 - r));
      var s = 0;
      return (
        r && (s = this._getColumnDuration(n, n.trace_x[e])),
        new Date(n.trace_x[e].valueOf() + Math.round(r * s))
      );
    },
    posFromDate: function (t) {
      if (!this.isVisible() || !t) return 0;
      var n = String(t.valueOf());
      if (this._posFromDateCache[n] !== void 0)
        return this._posFromDateCache[n];
      var e = this.columnIndexByDate(t);
      this.$gantt.assert(e >= 0, "Invalid day index");
      var i = Math.floor(e),
        a = e % 1,
        r = this._tasks.left[Math.min(i, this._tasks.width.length - 1)];
      i == this._tasks.width.length &&
        (r += this._tasks.width[this._tasks.width.length - 1]),
        a &&
          (i < this._tasks.width.length
            ? (r += this._tasks.width[i] * (a % 1))
            : (r += 1));
      var s = Math.round(r);
      return (this._posFromDateCache[n] = s), Math.round(s);
    },
    _getNextVisibleColumn: function (t, n, e) {
      for (var i = +n[t], a = t; e[i]; ) i = +n[++a];
      return a;
    },
    _getPrevVisibleColumn: function (t, n, e) {
      for (var i = +n[t], a = t; e[i]; ) i = +n[--a];
      return a;
    },
    _getClosestVisibleColumn: function (t, n, e) {
      var i = this._getNextVisibleColumn(t, n, e);
      return n[i] || (i = this._getPrevVisibleColumn(t, n, e)), i;
    },
    columnIndexByDate: function (t) {
      var n = new Date(t).valueOf(),
        e = this._tasks.trace_x_ascending,
        i = this._tasks.ignore_x,
        a = this.$gantt.getState();
      if (n <= a.min_date) return this._tasks.rtl ? e.length : 0;
      if (n >= a.max_date) return this._tasks.rtl ? 0 : e.length;
      var r = Bt(e, n),
        s = this._getClosestVisibleColumn(r, e, i),
        o = e[s],
        l = this._tasks.trace_index_transition;
      if (!o) return l ? l[0] : 0;
      var d = (t - e[s]) / this._getColumnDuration(this._tasks, e[s]);
      return l ? l[s] + (1 - d) : s + d;
    },
    getItemPosition: function (t, n, e) {
      var i, a, r;
      let s = n || t.start_date || t.$auto_start_date,
        o = e || t.end_date || t.$auto_end_date;
      return (
        this._tasks.rtl
          ? ((a = this.posFromDate(s)), (i = this.posFromDate(o)))
          : ((i = this.posFromDate(s)), (a = this.posFromDate(o))),
        (r = Math.max(a - i, 0)),
        {
          left: i,
          top: this.getItemTop(t.id),
          height: this.getBarHeight(t.id),
          width: r,
          rowHeight: this.getItemHeight(t.id),
        }
      );
    },
    getBarHeight: function (t, n) {
      var e = this.$getConfig(),
        i = this.$config.rowStore.getItem(t),
        a = i.task_height || i.bar_height || e.bar_height || e.task_height,
        r = this.getItemHeight(t);
      return (
        a == "full" && (a = r - (e.bar_height_padding || 3)),
        (a = Math.min(a, r)),
        n && (a = Math.round(a / Math.sqrt(2))),
        Math.max(a, 0)
      );
    },
    getScale: function () {
      return this._tasks;
    },
    _getScales: function () {
      var t = this.$getConfig(),
        n = this.$scaleHelper,
        e = [n.primaryScale(t)].concat(n.getSubScales(t));
      return n.sortScales(e), e;
    },
    _getColumnDuration: function (t, n) {
      return this.$gantt.date.add(n, t.step, t.unit) - n;
    },
    _bindStore: function () {
      if (this.$config.bind) {
        var t = this.$gantt.getDatastore(this.$config.bind);
        if (((this.$config.rowStore = t), t && !t._timelineCacheAttached)) {
          var n = this;
          t._timelineCacheAttached = t.attachEvent(
            "onBeforeFilter",
            function () {
              n._resetTopPositionHeight();
            }
          );
        }
      }
    },
    _unbindStore: function () {
      if (this.$config.bind) {
        var t = this.$gantt.getDatastore(this.$config.bind);
        t &&
          t._timelineCacheAttached &&
          (t.detachEvent(t._timelineCacheAttached),
          (t._timelineCacheAttached = !1));
      }
    },
    refresh: function () {
      this._bindStore(),
        this.$config.bindLinks &&
          (this.$config.linkStore = this.$gantt.getDatastore(
            this.$config.bindLinks
          )),
        this._resetTopPositionHeight(),
        this._resetHeight(),
        this._initStaticBackgroundRender(),
        this._render_tasks_scales();
    },
    destructor: function () {
      var t = this.$gantt;
      this._clearLayers(t),
        this._unbindStore(),
        (this.$task = null),
        (this.$task_scale = null),
        (this.$task_data = null),
        (this.$task_bg = null),
        (this.$task_links = null),
        (this.$task_bars = null),
        (this.$gantt = null),
        this.$config.rowStore &&
          (this.$config.rowStore.detachEvent(this._staticBgHandler),
          (this.$config.rowStore = null)),
        this.$config.linkStore && (this.$config.linkStore = null),
        this._timelineDragScroll &&
          (this._timelineDragScroll.destructor(),
          (this._timelineDragScroll = null)),
        this.callEvent("onDestroy", []),
        this.detachAllEvents();
    },
  };
  var Xa = (function (t) {
      function n(e, i, a, r) {
        return t.apply(this, arguments) || this;
      }
      return (
        W(n, t),
        O(
          n.prototype,
          {
            init: function () {
              this.$config.bind === void 0 &&
                (this.$config.bind = this.$getConfig().resource_store),
                t.prototype.init.apply(this, arguments);
            },
            _initEvents: function () {
              var e = this.$gantt;
              t.prototype._initEvents.apply(this, arguments),
                this._mouseDelegates.delegate(
                  "click",
                  "gantt_row",
                  e.bind(function (i, a, r) {
                    var s = this.$config.rowStore;
                    if (!s) return !0;
                    var o = Q(i, this.$config.item_attribute);
                    return (
                      o &&
                        s.select(o.getAttribute(this.$config.item_attribute)),
                      !1
                    );
                  }, this),
                  this.$grid
                );
            },
          },
          !0
        ),
        O(n.prototype, We(n), !0),
        n
      );
    })(ne),
    Jn = (function (t) {
      function n(e, i, a, r) {
        var s = t.apply(this, arguments) || this;
        return (s.$config.bindLinks = null), s;
      }
      return (
        W(n, t),
        O(
          n.prototype,
          {
            init: function () {
              this.$config.bind === void 0 &&
                (this.$config.bind = this.$getConfig().resource_store),
                t.prototype.init.apply(this, arguments);
            },
            _createLayerConfig: function () {
              var e = this,
                i = function () {
                  return e.isVisible();
                };
              return {
                tasks: [
                  {
                    renderer: this.$gantt.$ui.layers.resourceRow(),
                    container: this.$task_bars,
                    filter: [i],
                  },
                  {
                    renderer: this.$gantt.$ui.layers.taskBg(),
                    container: this.$task_bg,
                    filter: [i],
                  },
                ],
                links: [],
              };
            },
          },
          !0
        ),
        O(n.prototype, We(n), !0),
        n
      );
    })(je),
    Za = (function (t) {
      function n(e, i, a, r) {
        var s = t.apply(this, arguments) || this;
        return (s.$config.bindLinks = null), s;
      }
      return (
        W(n, t),
        O(
          n.prototype,
          {
            _createLayerConfig: function () {
              var e = this,
                i = function () {
                  return e.isVisible();
                };
              return {
                tasks: [
                  {
                    renderer: this.$gantt.$ui.layers.resourceHistogram(),
                    container: this.$task_bars,
                    filter: [i],
                  },
                  {
                    renderer: this.$gantt.$ui.layers.taskBg(),
                    container: this.$task_bg,
                    filter: [i],
                  },
                ],
                links: [],
              };
            },
          },
          !0
        ),
        O(n.prototype, We(t), !0),
        n
      );
    })(Jn);
  const Qa = {
      init: function (t, n) {
        var e = n.$gantt;
        e.attachEvent("onTaskClick", function (i, a) {
          if (e._is_icon_open_click(a)) return !0;
          var r = t.getState(),
            s = t.locateCell(a.target);
          return (
            !s ||
            !t.getEditorConfig(s.columnName) ||
            ((t.isVisible() && r.id == s.id && r.columnName == s.columnName) ||
              t.startEdit(s.id, s.columnName),
            !1)
          );
        }),
          e.attachEvent("onEmptyClick", function () {
            return t.isVisible() && t.isChanged() ? t.save() : t.hide(), !0;
          }),
          e.attachEvent("onTaskDblClick", function (i, a) {
            var r = t.getState(),
              s = t.locateCell(a.target);
            return !s || !t.isVisible() || s.columnName != r.columnName;
          });
      },
      onShow: function (t, n, e) {
        var i = e.$gantt;
        i.ext &&
          i.ext.keyboardNavigation &&
          i.ext.keyboardNavigation.attachEvent("onKeyDown", function (a, r) {
            var s = i.constants.KEY_CODES,
              o = !1;
            return r.keyCode === s.SPACE && t.isVisible() && (o = !0), !o;
          }),
          (n.onkeydown = function (a) {
            a = a || window.event;
            var r = i.constants.KEY_CODES;
            if (!(a.defaultPrevented || (a.shiftKey && a.keyCode != r.TAB))) {
              var s = !0;
              switch (a.keyCode) {
                case i.keys.edit_save:
                  t.save();
                  break;
                case i.keys.edit_cancel:
                  t.hide();
                  break;
                case r.UP:
                case r.DOWN:
                  t.isVisible() && (t.hide(), (s = !1));
                  break;
                case r.TAB:
                  a.shiftKey ? t.editPrevCell(!0) : t.editNextCell(!0);
                  break;
                default:
                  s = !1;
              }
              s && a.preventDefault();
            }
          });
      },
      onHide: function () {},
      destroy: function () {},
    },
    tr = {
      init: function (t, n) {
        var e = t,
          i = n.$gantt,
          a = null,
          r = i.ext.keyboardNavigation;
        r.attachEvent("onBeforeFocus", function (s) {
          var o = t.locateCell(s);
          if ((clearTimeout(a), o)) {
            var l = o.columnName,
              d = o.id,
              c = e.getState();
            if (e.isVisible() && c.id == d && c.columnName === l) return !1;
          }
          return !0;
        }),
          r.attachEvent("onFocus", function (s) {
            var o = t.locateCell(s),
              l = t.getState();
            return (
              clearTimeout(a),
              !o ||
                (o.id == l.id && o.columnName == l.columnName) ||
                (e.isVisible() && e.save()),
              !0
            );
          }),
          t.attachEvent("onHide", function () {
            clearTimeout(a);
          }),
          r.attachEvent("onBlur", function () {
            return (
              (a = setTimeout(function () {
                e.save();
              })),
              !0
            );
          }),
          i.attachEvent("onTaskDblClick", function (s, o) {
            var l = t.getState(),
              d = t.locateCell(o.target);
            return !d || !t.isVisible() || d.columnName != l.columnName;
          }),
          i.attachEvent("onTaskClick", function (s, o) {
            if (i._is_icon_open_click(o)) return !0;
            var l = t.getState(),
              d = t.locateCell(o.target);
            return (
              !d ||
              !t.getEditorConfig(d.columnName) ||
              ((t.isVisible() &&
                l.id == d.id &&
                l.columnName == d.columnName) ||
                t.startEdit(d.id, d.columnName),
              !1)
            );
          }),
          i.attachEvent("onEmptyClick", function () {
            return e.save(), !0;
          }),
          r.attachEvent("onKeyDown", function (s, o) {
            var l = t.locateCell(o.target),
              d = !!l && t.getEditorConfig(l.columnName),
              c = t.getState(),
              u = i.constants.KEY_CODES,
              h = o.keyCode,
              _ = !1;
            switch (h) {
              case u.ENTER:
                t.isVisible()
                  ? (t.save(), o.preventDefault(), (_ = !0))
                  : d &&
                    !(o.ctrlKey || o.metaKey || o.shiftKey) &&
                    (e.startEdit(l.id, l.columnName),
                    o.preventDefault(),
                    (_ = !0));
                break;
              case u.ESC:
                t.isVisible() && (t.hide(), o.preventDefault(), (_ = !0));
                break;
              case u.UP:
              case u.DOWN:
                break;
              case u.LEFT:
              case u.RIGHT:
                ((d && t.isVisible()) || c.editorType === "date") && (_ = !0);
                break;
              case u.SPACE:
                t.isVisible() && (_ = !0),
                  d &&
                    !t.isVisible() &&
                    (e.startEdit(l.id, l.columnName),
                    o.preventDefault(),
                    (_ = !0));
                break;
              case u.DELETE:
                d && !t.isVisible()
                  ? (e.startEdit(l.id, l.columnName), (_ = !0))
                  : d && t.isVisible() && (_ = !0);
                break;
              case u.TAB:
                if (t.isVisible()) {
                  o.shiftKey ? t.editPrevCell(!0) : t.editNextCell(!0);
                  var f = t.getState();
                  f.id &&
                    r.focus({
                      type: "taskCell",
                      id: f.id,
                      column: f.columnName,
                    }),
                    o.preventDefault(),
                    (_ = !0);
                }
                break;
              default:
                if (t.isVisible()) _ = !0;
                else if (
                  (h >= 48 && h <= 57) ||
                  (h > 95 && h < 112) ||
                  (h >= 64 && h <= 91) ||
                  (h > 185 && h < 193) ||
                  (h > 218 && h < 223)
                ) {
                  var y = s.modifiers,
                    v = y.alt || y.ctrl || y.meta || y.shift;
                  y.alt ||
                    (v && r.getCommandHandler(s, "taskCell")) ||
                    (d &&
                      !t.isVisible() &&
                      (e.startEdit(l.id, l.columnName), (_ = !0)));
                }
            }
            return !_;
          });
      },
      onShow: function (t, n, e) {},
      onHide: function (t, n, e) {
        const i = e.$gantt;
        i && i.focus();
      },
      destroy: function () {},
    };
  function Ht(t) {
    var n = function () {};
    return (
      (n.prototype = {
        show: function (e, i, a, r) {},
        hide: function () {},
        set_value: function (e, i, a, r) {
          this.get_input(r).value = e;
        },
        get_value: function (e, i, a) {
          return this.get_input(a).value || "";
        },
        is_changed: function (e, i, a, r) {
          var s = this.get_value(i, a, r);
          return s && e && s.valueOf && e.valueOf
            ? s.valueOf() != e.valueOf()
            : s != e;
        },
        is_valid: function (e, i, a, r) {
          return !0;
        },
        save: function (e, i, a) {},
        get_input: function (e) {
          return e.querySelector("input");
        },
        focus: function (e) {
          var i = this.get_input(e);
          i && (i.focus && i.focus(), i.select && i.select());
        },
      }),
      n
    );
  }
  function er(t) {
    var n = Ht();
    function e() {
      return n.apply(this, arguments) || this;
    }
    return (
      W(e, n),
      O(
        e.prototype,
        {
          show: function (i, a, r, s) {
            var o = `<div role='cell'><input type='text' name='${a.name}' title='${a.name}'></div>`;
            s.innerHTML = o;
          },
        },
        !0
      ),
      e
    );
  }
  function nr(t) {
    var n = Ht();
    function e() {
      return n.apply(this, arguments) || this;
    }
    return (
      W(e, n),
      O(
        e.prototype,
        {
          show: function (i, a, r, s) {
            var o = r.min || 0,
              l = r.max || 100,
              d = `<div role='cell'><input type='number' min='${o}' max='${l}' name='${a.name}' title='${a.name}'></div>`;
            (s.innerHTML = d),
              (s.oninput = function (c) {
                +c.target.value < o && (c.target.value = o),
                  +c.target.value > l && (c.target.value = l);
              });
          },
          get_value: function (i, a, r) {
            return this.get_input(r).value || "";
          },
          is_valid: function (i, a, r, s) {
            return !isNaN(parseInt(i, 10));
          },
        },
        !0
      ),
      e
    );
  }
  function ir(t) {
    var n = Ht();
    function e() {
      return n.apply(this, arguments) || this;
    }
    return (
      W(e, n),
      O(
        e.prototype,
        {
          show: function (i, a, r, s) {
            for (
              var o = `<div role='cell'><select name='${a.name}' title='${a.name}'>`,
                l = [],
                d = r.options || [],
                c = 0;
              c < d.length;
              c++
            )
              l.push(
                "<option value='" +
                  r.options[c].key +
                  "'>" +
                  d[c].label +
                  "</option>"
              );
            (o += l.join("") + "</select></div>"), (s.innerHTML = o);
          },
          get_input: function (i) {
            return i.querySelector("select");
          },
        },
        !0
      ),
      e
    );
  }
  function ar(t) {
    var n = Ht(),
      e = "%Y-%m-%d",
      i = null,
      a = null;
    function r() {
      return n.apply(this, arguments) || this;
    }
    return (
      W(r, n),
      O(
        r.prototype,
        {
          show: function (s, o, l, d) {
            i || (i = t.date.date_to_str(e)), a || (a = t.date.str_to_date(e));
            var c = null,
              u = null;
            (c = typeof l.min == "function" ? l.min(s, o) : l.min),
              (u = typeof l.max == "function" ? l.max(s, o) : l.max);
            var h = `<div style='width:140px' role='cell'><input type='date' ${
              c ? " min='" + i(c) + "' " : ""
            } ${u ? " max='" + i(u) + "' " : ""} name='${o.name}' title='${
              o.name
            }'></div>`;
            (d.innerHTML = h),
              (d.oninput = function (_) {
                _.target.value &&
                  (c || u) &&
                  (+t.date.str_to_date("%Y-%m-%d")(_.target.value) < +c &&
                    (_.target.value = t.date.date_to_str("%Y-%m-%d")(c)),
                  +t.date.str_to_date("%Y-%m-%d")(_.target.value) > +u &&
                    (_.target.value = t.date.date_to_str("%Y-%m-%d")(u)));
              });
          },
          set_value: function (s, o, l, d) {
            s && s.getFullYear
              ? (this.get_input(d).value = i(s))
              : (this.get_input(d).value = s);
          },
          is_valid: function (s, o, l, d) {
            return !(!s || isNaN(s.getTime()));
          },
          get_value: function (s, o, l) {
            var d;
            try {
              d = a(this.get_input(l).value || "");
            } catch {
              d = null;
            }
            return d;
          },
        },
        !0
      ),
      r
    );
  }
  function rr(t) {
    var n = Ht();
    function e() {
      return n.apply(this, arguments) || this;
    }
    function i(l) {
      return l.formatter || t.ext.formatters.linkFormatter();
    }
    function a(l, d) {
      for (
        var c = (l || "").split(d.delimiter || ","), u = 0;
        u < c.length;
        u++
      ) {
        var h = c[u].trim();
        h ? (c[u] = h) : (c.splice(u, 1), u--);
      }
      return c.sort(), c;
    }
    function r(l, d, c) {
      for (var u = l.$target, h = [], _ = 0; _ < u.length; _++) {
        var f = c.getLink(u[_]);
        h.push(i(d).format(f));
      }
      return h.join((d.delimiter || ",") + " ");
    }
    function s(l) {
      return l.source + "_" + l.target + "_" + l.type + "_" + (l.lag || 0);
    }
    function o(l, d, c) {
      var u = (function (v, b, g) {
          var m = [];
          return (
            [...new Set(b)].forEach(function (p) {
              var k = i(g).parse(p);
              k &&
                ((k.target = v),
                (k.id = "predecessor_generated"),
                t.isLinkAllowed(k) && ((k.id = void 0), m.push(k)));
            }),
            m
          );
        })(l.id, d, c),
        h = {};
      l.$target.forEach(function (v) {
        var b = t.getLink(v);
        h[s(b)] = b.id;
      });
      var _ = [];
      u.forEach(function (v) {
        var b = s(v);
        h[b] ? delete h[b] : _.push(v);
      });
      var f = [];
      for (var y in h) f.push(h[y]);
      return { add: _, remove: f };
    }
    return (
      W(e, n),
      O(
        e.prototype,
        {
          show: function (l, d, c, u) {
            var h = `<div role='cell'><input type='text' name='${d.name}' title='${d.name}'></div>`;
            u.innerHTML = h;
          },
          hide: function () {},
          set_value: function (l, d, c, u) {
            this.get_input(u).value = r(l, c.editor, t);
          },
          get_value: function (l, d, c) {
            return a(this.get_input(c).value || "", d.editor);
          },
          save: function (l, d, c) {
            var u = o(t.getTask(l), this.get_value(l, d, c), d.editor);
            (u.add.length || u.remove.length) &&
              t.batchUpdate(function () {
                u.add.forEach(function (h) {
                  t.addLink(h);
                }),
                  u.remove.forEach(function (h) {
                    t.deleteLink(h);
                  }),
                  t.autoSchedule && t.autoSchedule();
              });
          },
          is_changed: function (l, d, c, u) {
            var h = this.get_value(d, c, u),
              _ = a(r(l, c.editor, t), c.editor);
            return h.join() !== _.join();
          },
        },
        !0
      ),
      e
    );
  }
  function sr(t) {
    var n = Ht();
    function e() {
      return n.apply(this, arguments) || this;
    }
    function i(a) {
      return a.formatter || t.ext.formatters.durationFormatter();
    }
    return (
      W(e, n),
      O(
        e.prototype,
        {
          show: function (a, r, s, o) {
            var l = `<div role='cell'><input type='text' name='${r.name}' title='${r.name}'></div>`;
            o.innerHTML = l;
          },
          set_value: function (a, r, s, o) {
            this.get_input(o).value = i(s.editor).format(a);
          },
          get_value: function (a, r, s) {
            return i(r.editor).parse(this.get_input(s).value || "");
          },
        },
        !0
      ),
      e
    );
  }
  function or(t) {
    return function (e, i, a) {
      a == "keepDates"
        ? (function (r, s) {
            s == "duration"
              ? (r.end_date = t.calculateEndDate(r))
              : (s != "end_date" && s != "start_date") ||
                (r.duration = t.calculateDuration(r));
          })(e, i)
        : a == "keepDuration"
        ? (function (r, s) {
            s == "end_date"
              ? (r.start_date = n(r))
              : (s != "start_date" && s != "duration") ||
                (r.end_date = t.calculateEndDate(r));
          })(e, i)
        : (function (r, s) {
            t.config.schedule_from_end
              ? s == "end_date" || s == "duration"
                ? (r.start_date = n(r))
                : s == "start_date" && (r.duration = t.calculateDuration(r))
              : s == "start_date" || s == "duration"
              ? (r.end_date = t.calculateEndDate(r))
              : s == "end_date" && (r.duration = t.calculateDuration(r));
          })(e, i);
    };
    function n(e) {
      return t.calculateEndDate({
        start_date: e.end_date,
        duration: -e.duration,
        task: e,
      });
    }
  }
  function lr(t) {
    t.config.editor_types = {
      text: new (er())(),
      number: new (nr())(),
      select: new (ir())(),
      date: new (ar(t))(),
      predecessor: new (rr(t))(),
      duration: new (sr(t))(),
    };
  }
  function dr(t) {
    var n = (function (a) {
        var r = null;
        return {
          setMapping: function (s) {
            r = s;
          },
          getMapping: function () {
            return (
              r ||
              (a.config.keyboard_navigation_cells && a.ext.keyboardNavigation
                ? tr
                : Qa)
            );
          },
        };
      })(t),
      e = {};
    ct(e);
    var i = {
      init: lr,
      createEditors: function (a) {
        function r(u, h) {
          var _ = a.$getConfig(),
            f = (function (b, g) {
              for (
                var m = a.$getConfig(),
                  p = a.getItemTop(b),
                  k = a.getItemHeight(b),
                  w = a.getGridColumns(),
                  x = 0,
                  $ = 0,
                  S = 0,
                  T = 0;
                T < w.length;
                T++
              ) {
                if (w[T].name == g) {
                  S = w[T].width;
                  break;
                }
                m.rtl ? ($ += w[T].width) : (x += w[T].width);
              }
              return m.rtl
                ? { top: p, right: $, height: k, width: S }
                : { top: p, left: x, height: k, width: S };
            })(u, h),
            y = document.createElement("div");
          (y.className = "gantt_grid_editor_placeholder"),
            y.setAttribute(a.$config.item_attribute, u),
            y.setAttribute(a.$config.bind + "_id", u),
            y.setAttribute("data-column-name", h);
          var v = (function (b, g) {
            for (var m = b.getGridColumns(), p = 0; p < m.length; p++)
              if (m[p].name == g) return p;
            return 0;
          })(a, h);
          return (
            y.setAttribute("data-column-index", v),
            t._waiAria.inlineEditorAttr(y),
            _.rtl
              ? (y.style.cssText = [
                  "top:" + f.top + "px",
                  "right:" + f.right + "px",
                  "width:" + f.width + "px",
                  "height:" + f.height + "px",
                ].join(";"))
              : (y.style.cssText = [
                  "top:" + f.top + "px",
                  "left:" + f.left + "px",
                  "width:" + f.width + "px",
                  "height:" + f.height + "px",
                ].join(";")),
            y
          );
        }
        var s = or(t),
          o = [],
          l = [],
          d = null,
          c = {
            _itemId: null,
            _columnName: null,
            _editor: null,
            _editorType: null,
            _placeholder: null,
            locateCell: function (u) {
              if (!tt(u, a.$grid)) return null;
              var h = Q(u, a.$config.item_attribute),
                _ = Q(u, "data-column-name");
              if (h && _) {
                var f = _.getAttribute("data-column-name");
                return {
                  id: h.getAttribute(a.$config.item_attribute),
                  columnName: f,
                };
              }
              return null;
            },
            getEditorConfig: function (u) {
              return a.getColumn(u).editor;
            },
            init: function () {
              var u = n.getMapping();
              u.init && u.init(this, a),
                (d = a.$gantt.getDatastore(a.$config.bind));
              var h = this;
              o.push(
                d.attachEvent("onIdChange", function (_, f) {
                  h._itemId == _ && (h._itemId = f);
                })
              ),
                o.push(
                  d.attachEvent("onStoreUpdated", function () {
                    a.$gantt.getState("batchUpdate").batch_update ||
                      (h.isVisible() && !d.isVisible(h._itemId) && h.hide());
                  })
                ),
                l.push(
                  t.attachEvent("onDataRender", function () {
                    h._editor &&
                      h._placeholder &&
                      !tt(h._placeholder, t.$root) &&
                      a.$grid_data.appendChild(h._placeholder);
                  })
                ),
                (this.init = function () {});
            },
            getState: function () {
              return {
                editor: this._editor,
                editorType: this._editorType,
                placeholder: this._placeholder,
                id: this._itemId,
                columnName: this._columnName,
              };
            },
            startEdit: function (u, h) {
              if ((this.isVisible() && this.save(), !d.exists(u))) return;
              var _ = { id: u, columnName: h };
              if (t.isReadonly(d.getItem(u)))
                return void this.callEvent("onEditPrevent", [_]);
              if (this.callEvent("onBeforeEditStart", [_]) === !1)
                return void this.callEvent("onEditPrevent", [_]);
              const f = this.show(_.id, _.columnName);
              f && f.then
                ? f.then(
                    function () {
                      this.setValue(), this.callEvent("onEditStart", [_]);
                    }.bind(this)
                  )
                : (this.setValue(), this.callEvent("onEditStart", [_]));
            },
            isVisible: function () {
              return !(!this._editor || !tt(this._placeholder, t.$root));
            },
            show: function (u, h) {
              this.isVisible() && this.save();
              var _ = { id: u, columnName: h },
                f = a.getColumn(_.columnName),
                y = this.getEditorConfig(f.name);
              if (!y) return;
              var v = a.$getConfig().editor_types[y.type],
                b = r(_.id, _.columnName);
              a.$grid_data.appendChild(b);
              const g = function () {
                  (this._editor = v),
                    (this._placeholder = b),
                    (this._itemId = _.id),
                    (this._columnName = _.columnName),
                    (this._editorType = y.type);
                  var p = n.getMapping();
                  p.onShow && p.onShow(this, b, a),
                    (b._onReMount = function () {
                      this.setValue();
                    }.bind(this));
                }.bind(this),
                m = v.show(_.id, f, y, b);
              if (m && m.then)
                return m.then(() => {
                  g();
                });
              g();
            },
            setValue: function () {
              var u = this.getState(),
                h = u.id,
                _ = u.columnName,
                f = a.getColumn(_),
                y = d.getItem(h),
                v = this.getEditorConfig(_);
              if (v) {
                var b = y[v.map_to];
                v.map_to == "auto" && (b = d.getItem(h)),
                  this._editor.set_value(b, h, f, this._placeholder),
                  this.focus();
              }
            },
            focus: function () {
              this._editor.focus(this._placeholder);
            },
            getValue: function () {
              var u = a.getColumn(this._columnName);
              return this._editor.get_value(this._itemId, u, this._placeholder);
            },
            _getItemValue: function () {
              var u = this.getEditorConfig(this._columnName);
              if (u) {
                var h = t.getTask(this._itemId)[u.map_to];
                return u.map_to == "auto" && (h = d.getItem(this._itemId)), h;
              }
            },
            isChanged: function () {
              var u = a.getColumn(this._columnName),
                h = this._getItemValue();
              return this._editor.is_changed(
                h,
                this._itemId,
                u,
                this._placeholder
              );
            },
            hide: function () {
              if (this._itemId) {
                var u = this._itemId,
                  h = this._columnName,
                  _ = n.getMapping();
                _.onHide && _.onHide(this, this._placeholder, a),
                  (this._itemId = null),
                  (this._columnName = null),
                  (this._editorType = null),
                  this._placeholder &&
                    (this._editor &&
                      this._editor.hide &&
                      this._editor.hide(this._placeholder),
                    (this._editor = null),
                    this._placeholder.parentNode &&
                      this._placeholder.parentNode.removeChild(
                        this._placeholder
                      ),
                    (this._placeholder = null),
                    this.callEvent("onEditEnd", [{ id: u, columnName: h }]));
              }
            },
            save: function () {
              if (
                this.isVisible() &&
                d.exists(this._itemId) &&
                this.isChanged()
              ) {
                var u = this._itemId,
                  h = this._columnName;
                if (d.exists(u)) {
                  var _ = d.getItem(u),
                    f = this.getEditorConfig(h),
                    y = {
                      id: u,
                      columnName: h,
                      newValue: this.getValue(),
                      oldValue: this._getItemValue(),
                    };
                  if (
                    this.callEvent("onBeforeSave", [y]) !== !1 &&
                    (!this._editor.is_valid ||
                      this._editor.is_valid(
                        y.newValue,
                        y.id,
                        a.getColumn(h),
                        this._placeholder
                      ))
                  ) {
                    var v = f.map_to,
                      b = y.newValue;
                    v != "auto"
                      ? ((_[v] = b),
                        s(_, v, t.config.inline_editors_date_processing),
                        d.updateItem(u))
                      : this._editor.save(u, a.getColumn(h), this._placeholder),
                      this.callEvent("onSave", [y]);
                  }
                  this.hide();
                }
              } else this.hide();
            },
            _findEditableCell: function (u, h) {
              var _ = u,
                f = a.getGridColumns()[_],
                y = f ? f.name : null;
              if (y) {
                for (; y && !this.getEditorConfig(y); )
                  y = this._findEditableCell(u + h, h);
                return y;
              }
              return null;
            },
            getNextCell: function (u) {
              return this._findEditableCell(
                a.getColumnIndex(this._columnName, !0) + u,
                u
              );
            },
            getFirstCell: function () {
              return this._findEditableCell(0, 1);
            },
            getLastCell: function () {
              return this._findEditableCell(a.getGridColumns().length - 1, -1);
            },
            editNextCell: function (u) {
              var h = this.getNextCell(1);
              if (h) {
                var _ = this.getNextCell(1);
                _ && this.getEditorConfig(_) && this.startEdit(this._itemId, _);
              } else if (u && this.moveRow(1)) {
                var f = this.moveRow(1);
                (h = this.getFirstCell()) &&
                  this.getEditorConfig(h) &&
                  this.startEdit(f, h);
              }
            },
            editPrevCell: function (u) {
              var h = this.getNextCell(-1);
              if (h) {
                var _ = this.getNextCell(-1);
                _ && this.getEditorConfig(_) && this.startEdit(this._itemId, _);
              } else if (u && this.moveRow(-1)) {
                var f = this.moveRow(-1);
                (h = this.getLastCell()) &&
                  this.getEditorConfig(h) &&
                  this.startEdit(f, h);
              }
            },
            moveRow: function (u) {
              for (
                var h = u > 0 ? t.getNext : t.getPrev,
                  _ = (h = t.bind(h, t))(this._itemId);
                t.isTaskExists(_) && t.isReadonly(t.getTask(_));

              )
                _ = h(_);
              return _;
            },
            editNextRow: function (u) {
              var h = this.getState().id;
              if (t.isTaskExists(h)) {
                var _ = null;
                (_ = u ? this.moveRow(1) : t.getNext(h)),
                  t.isTaskExists(_) && this.startEdit(_, this._columnName);
              }
            },
            editPrevRow: function (u) {
              var h = this.getState().id;
              if (t.isTaskExists(h)) {
                var _ = null;
                (_ = u ? this.moveRow(-1) : t.getPrev(h)),
                  t.isTaskExists(_) && this.startEdit(_, this._columnName);
              }
            },
            detachStore: function () {
              o.forEach(function (u) {
                d.detachEvent(u);
              }),
                l.forEach(function (u) {
                  t.detachEvent(u);
                }),
                (o = []),
                (l = []),
                (d = null),
                this.hide();
            },
            destructor: function () {
              this.detachStore(), this.detachAllEvents();
            },
          };
        return O(c, n), O(c, e), c;
      },
    };
    return O(i, n), O(i, e), i;
  }
  function Ot(t, n, e, i, a) {
    if (!t.start_date || !t.end_date) return null;
    var r = e.getItemTop(t.id),
      s = e.getItemHeight(t.id);
    if (r > n.y_end || r + s < n.y) return !1;
    var o = e.posFromDate(t.start_date),
      l = e.posFromDate(t.end_date),
      d = Math.min(o, l) - 200,
      c = Math.max(o, l) + 200;
    return !(d > n.x_end || c < n.x);
  }
  function Ve(t) {
    function n(r, s, o) {
      if (t._isAllowedUnscheduledTask(r) || !t._isTaskInTimelineLimits(r))
        return;
      var l = s.getItemPosition(r),
        d = o,
        c = s.$getTemplates(),
        u = t.getTaskType(r.type),
        h = s.getBarHeight(r.id, u == d.types.milestone),
        _ = 0;
      u == d.types.milestone && (_ = (h - l.height) / 2);
      var f = Math.floor((s.getItemHeight(r.id) - h) / 2);
      const y = t.config.baselines && r.baselines && r.baselines.length,
        v =
          t.config.baselines &&
          (t.config.baselines.render_mode == "separateRow" ||
            t.config.baselines.render_mode == "individualRow");
      if (y && v && r.bar_height !== "full" && r.bar_height < r.row_height)
        if (u === d.types.milestone) {
          let T = s.getBarHeight(r.id, !0),
            E = Math.sqrt(2 * T * T);
          f = Math.floor((E - h) / 2) + 2;
        } else f = 2;
      u == d.types.milestone && ((l.left -= Math.round(h / 2)), (l.width = h));
      var b = document.createElement("div"),
        g = Math.round(l.width);
      s.$config.item_attribute &&
        (b.setAttribute(s.$config.item_attribute, r.id),
        b.setAttribute(s.$config.bind + "_id", r.id)),
        d.show_progress &&
          u != d.types.milestone &&
          (function (T, E, C, D, A) {
            var I = 1 * T.progress || 0;
            C = Math.max(C, 0);
            var M = document.createElement("div"),
              L = Math.round(C * I);
            (L = Math.min(C, L)),
              (M.style.width = L + "px"),
              (M.className = "gantt_task_progress"),
              (M.innerHTML = A.progress_text(T.start_date, T.end_date, T)),
              D.rtl &&
                ((M.style.position = "absolute"), (M.style.right = "0px"));
            var N = document.createElement("div");
            (N.className = "gantt_task_progress_wrapper"),
              N.appendChild(M),
              E.appendChild(N);
            const P = !t.isReadonly(T),
              R = t.ext.dragTimeline && t.ext.dragTimeline._isDragInProgress();
            if (t.config.drag_progress && (P || R)) {
              var B = document.createElement("div"),
                H = L;
              D.rtl && (H = C - L),
                (B.style.left = H + "px"),
                (B.className = "gantt_task_progress_drag"),
                (B.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="9" viewBox="0 0 12 9" fill="none">
<path d="M5.58397 1.52543C5.78189 1.22856 6.21811 1.22856 6.41602 1.52543L10.5475 7.72265C10.769 8.05493 10.5308 8.5 10.1315 8.5L1.86852 8.5C1.46917 8.5 1.23097 8.05493 1.45249 7.72265L5.58397 1.52543Z" fill="var(--dhx-gantt-progress-handle-background)" stroke="var(--dhx-gantt-progress-handle-border)"/>
</svg>`),
                M.appendChild(B),
                E.appendChild(B);
            }
          })(r, b, g, d, c);
      var m = (function (T, E, C) {
        var D = document.createElement("div");
        return (
          t.getTaskType(T.type) != t.config.types.milestone
            ? (D.innerHTML = C.task_text(T.start_date, T.end_date, T))
            : t.getTaskType(T.type) == t.config.types.milestone &&
              E &&
              (D.style.height = D.style.width = E + "px"),
          (D.className = "gantt_task_content"),
          D
        );
      })(r, g, c);
      b.appendChild(m);
      var p = (function (T, E, C, D) {
        var A = D.$getConfig(),
          I = [T];
        E && I.push(E);
        var M = t.getState(),
          L = t.getTask(C);
        if (
          (t.getTaskType(L.type) == A.types.milestone
            ? I.push("gantt_milestone")
            : t.getTaskType(L.type) == A.types.project &&
              I.push("gantt_project"),
          I.push("gantt_bar_" + t.getTaskType(L.type)),
          t.isSummaryTask(L) && I.push("gantt_dependent_task"),
          t.isSplitTask(L) &&
            ((A.open_split_tasks && !L.$open) || !A.open_split_tasks) &&
            I.push("gantt_split_parent"),
          A.select_task && t.isSelectedTask(C) && I.push("gantt_selected"),
          C == M.drag_id &&
            (I.push("gantt_drag_" + M.drag_mode),
            M.touch_drag && I.push("gantt_touch_" + M.drag_mode)),
          M.link_source_id == C &&
            (I.push("gantt_link_source"),
            M.link_from_start
              ? I.push("gantt_link_from_start")
              : I.push("gantt_link_from_end")),
          M.link_target_id == C && I.push("gantt_link_target"),
          A.highlight_critical_path &&
            t.isCriticalTask &&
            t.isCriticalTask(L) &&
            I.push("gantt_critical_task"),
          M.link_landing_area &&
            M.link_target_id &&
            M.link_source_id &&
            M.link_target_id != M.link_source_id &&
            (M.link_target_id == C || M.link_source_id == C))
        ) {
          var N = M.link_source_id,
            P = M.link_from_start,
            R = M.link_to_start,
            B = "";
          (B = t.isLinkAllowed(N, C, P, R)
            ? R
              ? "link_start_allow"
              : "link_finish_allow"
            : R
            ? "link_start_deny"
            : "link_finish_deny"),
            I.push(B);
        }
        return I.join(" ");
      })("gantt_task_line", c.task_class(r.start_date, r.end_date, r), r.id, s);
      (r.color || r.progressColor || r.textColor) &&
        (p += " gantt_task_inline_color"),
        l.width < 20 && (p += " gantt_thin_task"),
        (b.className = p);
      var k = [
        "left:" + l.left + "px",
        "top:" + (f + l.top) + "px",
        "height:" + h + "px",
        "line-height:" + Math.max(h < 30 ? h - 2 : h, 0) + "px",
        "width:" + g + "px",
      ];
      (b.style.cssText = k.join(";")),
        r.color && b.style.setProperty("--dhx-gantt-task-background", r.color),
        r.textColor &&
          b.style.setProperty("--dhx-gantt-task-color", r.textColor),
        r.progressColor &&
          b.style.setProperty(
            "--dhx-gantt-task-progress-color",
            r.progressColor
          );
      var w = (function (T, E, C, D) {
        var A = "gantt_left " + i(!E.rtl, T),
          I = null;
        return (
          D && (I = { type: "marginRight", value: D }),
          e(T, C.leftside_text, A, I)
        );
      })(r, d, c, _);
      w && b.appendChild(w),
        (w = (function (T, E, C, D) {
          var A = "gantt_right " + i(!!E.rtl, T),
            I = null;
          return (
            D && (I = { type: "marginLeft", value: D }),
            e(T, C.rightside_text, A, I)
          );
        })(r, d, c, _)),
        w && b.appendChild(w),
        t._waiAria.setTaskBarAttr(r, b);
      var x = t.getState();
      const $ = !t.isReadonly(r),
        S = t.ext.dragTimeline && t.ext.dragTimeline._isDragInProgress();
      return (
        ($ || S) &&
          (d.drag_resize &&
            !t.isSummaryTask(r) &&
            u != d.types.milestone &&
            a(
              b,
              "gantt_task_drag",
              r,
              function (T) {
                var E = document.createElement("div");
                return (E.className = T), E;
              },
              d
            ),
          d.drag_links &&
            d.show_links &&
            a(
              b,
              "gantt_link_control",
              r,
              function (T) {
                var E = document.createElement("div");
                (E.className = T),
                  (E.style.cssText = [
                    "height:" + h + "px",
                    "line-height:" + h + "px",
                  ].join(";"));
                var C = document.createElement("div");
                C.className = "gantt_link_point";
                var D = !1;
                return (
                  x.link_source_id && d.touch && (D = !0),
                  (C.style.display = D ? "block" : ""),
                  E.appendChild(C),
                  E
                );
              },
              d,
              _
            )),
        b
      );
    }
    function e(r, s, o, l) {
      if (!s) return null;
      var d = s(r.start_date, r.end_date, r);
      if (!d) return null;
      var c = document.createElement("div");
      return (
        (c.className = "gantt_side_content " + o),
        (c.innerHTML = d),
        l && (c.style[l.type] = Math.abs(l.value) + "px"),
        c
      );
    }
    function i(r, s) {
      var o = r
        ? {
            $source: [t.config.links.start_to_start],
            $target: [
              t.config.links.start_to_start,
              t.config.links.finish_to_start,
            ],
          }
        : {
            $source: [
              t.config.links.finish_to_start,
              t.config.links.finish_to_finish,
            ],
            $target: [t.config.links.finish_to_finish],
          };
      for (var l in o)
        for (var d = s[l], c = 0; c < d.length; c++)
          for (var u = t.getLink(d[c]), h = 0; h < o[l].length; h++)
            if (u.type == o[l][h]) return "gantt_link_crossing";
      return "";
    }
    function a(r, s, o, l, d, c) {
      var u,
        h = t.getState();
      +o.start_date >= +h.min_date &&
        ((u = l(
          [s, d.rtl ? "task_right" : "task_left", "task_start_date"].join(" ")
        )).setAttribute("data-bind-property", "start_date"),
        c && (u.style.marginLeft = c + "px"),
        r.appendChild(u)),
        +o.end_date <= +h.max_date &&
          ((u = l(
            [s, d.rtl ? "task_left" : "task_right", "task_end_date"].join(" ")
          )).setAttribute("data-bind-property", "end_date"),
          c && (u.style.marginRight = c + "px"),
          r.appendChild(u));
    }
    return function (r, s, o) {
      var l = (o = s.$getConfig()).type_renderers[t.getTaskType(r.type)],
        d = n;
      return l
        ? l.call(
            t,
            r,
            function (c) {
              return d.call(t, c, s, o);
            },
            s
          )
        : d.call(t, r, s, o);
    };
  }
  function cr(t, n, e, i, a) {
    if (
      !(
        (t.start_date && t.end_date) ||
        (t.$auto_start_date && t.$auto_end_date)
      )
    )
      return null;
    var r = e.getItemTop(t.id),
      s = e.getItemHeight(t.id);
    if (r > n.y_end || r + s < n.y) return !1;
    const o = [];
    t.start_date && o.push(e.posFromDate(t.start_date)),
      t.end_date && o.push(e.posFromDate(t.end_date)),
      t.$auto_start_date && o.push(e.posFromDate(t.$auto_start_date)),
      t.$auto_end_date && o.push(e.posFromDate(t.$auto_end_date));
    var l = Math.min(...o) - 200,
      d = Math.max(...o) + 200;
    return !(l > n.x_end || d < n.x);
  }
  function ur(t) {
    function n(r, s, o) {
      if (t._isAllowedUnscheduledTask(r) || !t._isTaskInTimelineLimits(r))
        return;
      var l = s.getItemPosition(r),
        d = o,
        c = s.$getTemplates(),
        u = t.getTaskType(r.type),
        h = s.getBarHeight(r.id, u == d.types.milestone),
        _ = 0;
      u == d.types.milestone && (_ = (h - l.height) / 2);
      var f = Math.floor((s.getItemHeight(r.id) - h) / 2);
      const y = t.config.baselines && r.baselines && r.baselines.length,
        v =
          t.config.baselines &&
          (t.config.baselines.render_mode == "separateRow" ||
            t.config.baselines.render_mode == "individualRow");
      if (y && v && r.bar_height !== "full" && r.bar_height < r.row_height)
        if (u === d.types.milestone) {
          let T = s.getBarHeight(r.id, !0),
            E = Math.sqrt(2 * T * T);
          f = Math.floor((E - h) / 2) + 2;
        } else f = 2;
      var b = document.createElement("div"),
        g = Math.round(l.width);
      s.$config.item_attribute &&
        (b.setAttribute(s.$config.item_attribute, r.id),
        b.setAttribute(s.$config.bind + "_id", r.id));
      const m = document.createElement("div");
      m.classList.add(
        "gantt_task_line_planned",
        "gantt_task_line",
        "gantt_project"
      );
      const p = s.getItemPosition(r, r.start_date, r.end_date);
      (m.style.cssText = [
        "position:absolute",
        "left:" + p.left + "px",
        "top:" + (f / 2 + 1) + "px",
        "height:5px",
        "width:" + p.width + "px",
      ].join(";")),
        m.style.setProperty(
          "--dhx-gantt-scheduled-summary-bracket-size",
          "10px"
        ),
        b.appendChild(m);
      const k = document.createElement("div"),
        w = s.getItemPosition(
          r,
          r.$auto_start_date || r.start_date,
          r.$auto_end_date || r.end_date
        );
      k.classList.add(
        "gantt_task_line_actual",
        "gantt_task_line",
        "gantt_project"
      ),
        (k.style.cssText = [
          "position:absolute",
          "left:" + w.left + "px",
          "top:16px",
          "height:8px",
          "width:" + w.width + "px",
        ].join(";")),
        b.appendChild(k),
        d.show_progress &&
          u != d.types.milestone &&
          (function (T, E, C, D, A) {
            var I = 1 * T.progress || 0;
            C = Math.max(C - 2, 0);
            var M = document.createElement("div"),
              L = Math.round(C * I);
            (L = Math.min(C, L)),
              T.progressColor &&
                ((M.style.backgroundColor = T.progressColor),
                (M.style.opacity = 1)),
              (M.style.width = L + "px"),
              (M.className = "gantt_task_progress"),
              (M.innerHTML = A.progress_text(T.start_date, T.end_date, T)),
              D.rtl &&
                ((M.style.position = "absolute"), (M.style.right = "0px"));
            var N = document.createElement("div");
            if (
              ((N.className = "gantt_task_progress_wrapper"),
              N.appendChild(M),
              E.appendChild(N),
              t.config.drag_progress && !t.isReadonly(T))
            ) {
              var P = document.createElement("div"),
                R = L;
              D.rtl && (R = C - L),
                (P.style.left = R + "px"),
                (P.className = "gantt_task_progress_drag"),
                M.appendChild(P),
                E.appendChild(P);
            }
          })(r, k, g, d, c);
      var x = (function (T, E, C, D) {
        var A = D.$getConfig(),
          I = [T];
        E && I.push(E);
        var M = t.getState(),
          L = t.getTask(C);
        if (
          (t.getTaskType(L.type) == A.types.milestone
            ? I.push("gantt_milestone")
            : t.getTaskType(L.type) == A.types.project &&
              I.push("gantt_project"),
          I.push("gantt_bar_" + t.getTaskType(L.type)),
          t.isSummaryTask(L) && I.push("gantt_dependent_task"),
          t.isSplitTask(L) &&
            ((A.open_split_tasks && !L.$open) || !A.open_split_tasks) &&
            I.push("gantt_split_parent"),
          A.select_task && t.isSelectedTask(C) && I.push("gantt_selected"),
          C == M.drag_id &&
            (I.push("gantt_drag_" + M.drag_mode),
            M.touch_drag && I.push("gantt_touch_" + M.drag_mode)),
          M.link_source_id == C && I.push("gantt_link_source"),
          M.link_target_id == C && I.push("gantt_link_target"),
          A.highlight_critical_path &&
            t.isCriticalTask &&
            t.isCriticalTask(L) &&
            I.push("gantt_critical_task"),
          M.link_landing_area &&
            M.link_target_id &&
            M.link_source_id &&
            M.link_target_id != M.link_source_id &&
            (M.link_target_id == C || M.link_source_id == C))
        ) {
          var N = M.link_source_id,
            P = M.link_from_start,
            R = M.link_to_start,
            B = "";
          (B = t.isLinkAllowed(N, C, P, R)
            ? R
              ? "link_start_allow"
              : "link_finish_allow"
            : R
            ? "link_start_deny"
            : "link_finish_deny"),
            I.push(B);
        }
        return I.join(" ");
      })(
        "gantt_task_line",
        c.task_class(
          r.$auto_start_date || r.start_date,
          r.$auto_end_date || r.end_date,
          r
        ),
        r.id,
        s
      );
      (r.color || r.progressColor || r.textColor) &&
        (x += " gantt_task_inline_color"),
        l.width < 20 && (x += " gantt_thin_task"),
        (r.start_date > r.$auto_start_date || r.end_date < r.$auto_end_date) &&
          (x += " gantt_project_scheduling_conflict"),
        (b.className = x),
        (b.style.top = f + l.top + "px"),
        (b.style.height = (u == d.types.milestone ? l.height : h) + "px"),
        r.color && b.style.setProperty("--dhx-gantt-task-background", r.color),
        r.textColor &&
          b.style.setProperty("--dhx-gantt-task-color", r.textColor),
        r.progressColor &&
          b.style.setProperty(
            "--dhx-gantt-task-progress-color",
            r.progressColor
          );
      var $ = (function (T, E, C, D) {
        var A = "gantt_left " + i(!E.rtl, T),
          I = null;
        return (
          D && (I = { type: "marginRight", value: D }),
          e(T, C.leftside_text, A, I)
        );
      })(r, d, c, _);
      $ && m.appendChild($),
        ($ = (function (T, E, C, D) {
          var A = "gantt_right " + i(!!E.rtl, T),
            I = null;
          return (
            D && (I = { type: "marginLeft", value: D }),
            e(T, C.rightside_text, A, I)
          );
        })(r, d, c, _)),
        $ && m.appendChild($),
        t._waiAria.setTaskBarAttr(r, b);
      var S = t.getState();
      return (
        t.isReadonly(r) ||
          (d.drag_resize &&
            a(
              m,
              "gantt_task_drag",
              r,
              function (T) {
                var E = document.createElement("div");
                return (E.className = T), E;
              },
              d
            ),
          d.drag_links &&
            d.show_links &&
            a(
              m,
              "gantt_link_control",
              r,
              function (T) {
                var E = document.createElement("div");
                (E.className = T),
                  (E.style.cssText = [
                    "height:" + h + "px",
                    "line-height:" + h + "px",
                  ].join(";"));
                var C = document.createElement("div");
                C.className = "gantt_link_point";
                var D = !1;
                return (
                  S.link_source_id && d.touch && (D = !0),
                  (C.style.display = D ? "block" : ""),
                  E.appendChild(C),
                  E
                );
              },
              d,
              _
            )),
        b
      );
    }
    function e(r, s, o, l) {
      if (!s) return null;
      var d = s(r.start_date, r.end_date, r);
      if (!d) return null;
      var c = document.createElement("div");
      return (
        (c.className = "gantt_side_content " + o),
        (c.innerHTML = d),
        l && (c.style[l.type] = Math.abs(l.value) + "px"),
        c
      );
    }
    function i(r, s) {
      var o = r
        ? {
            $source: [t.config.links.start_to_start],
            $target: [
              t.config.links.start_to_start,
              t.config.links.finish_to_start,
            ],
          }
        : {
            $source: [
              t.config.links.finish_to_start,
              t.config.links.finish_to_finish,
            ],
            $target: [t.config.links.finish_to_finish],
          };
      for (var l in o)
        for (var d = s[l], c = 0; c < d.length; c++)
          for (var u = t.getLink(d[c]), h = 0; h < o[l].length; h++)
            if (u.type == o[l][h]) return "gantt_link_crossing";
      return "";
    }
    function a(r, s, o, l, d, c) {
      var u,
        h = t.getState();
      +o.start_date >= +h.min_date &&
        ((u = l(
          [s, d.rtl ? "task_right" : "task_left", "task_start_date"].join(" ")
        )).setAttribute("data-bind-property", "start_date"),
        c && (u.style.marginLeft = c + "px"),
        r.appendChild(u)),
        +o.end_date <= +h.max_date &&
          ((u = l(
            [s, d.rtl ? "task_left" : "task_right", "task_end_date"].join(" ")
          )).setAttribute("data-bind-property", "end_date"),
          c && (u.style.marginRight = c + "px"),
          r.appendChild(u));
    }
    return function (r, s, o) {
      var l = (o = s.$getConfig()).type_renderers[t.getTaskType(r.type)],
        d = n;
      return l
        ? l.call(
            t,
            r,
            function (c) {
              return d.call(t, c, s, o);
            },
            s
          )
        : d.call(t, r, s, o);
    };
  }
  function hr(t, n, e, i, a) {
    if (!a.isSplitTask(t)) return !1;
    var r = a.getSubtaskDates(t.id);
    return Ot(
      {
        id: t.id,
        start_date: r.start_date,
        end_date: r.end_date,
        parent: t.parent,
      },
      n,
      e
    );
  }
  function Ue(t, n, e) {
    return {
      top: n.getItemTop(t.id),
      height: n.getItemHeight(t.id),
      left: 0,
      right: 1 / 0,
    };
  }
  function Dt(t, n) {
    var e = 0,
      i = t.left.length - 1;
    if (n)
      for (var a = 0; a < t.left.length; a++) {
        var r = t.left[a];
        if ((r < n.x && (e = a), r > n.x_end)) {
          i = a;
          break;
        }
      }
    return { start: e, end: i };
  }
  function Ut(t, n, e, i) {
    var a = n.width[t];
    if (a <= 0) return !1;
    if (!i.config.smart_rendering || Vt(i)) return !0;
    var r = n.left[t] - a,
      s = n.left[t] + a;
    return r <= e.x_end && s >= e.x;
  }
  function _r(t, n) {
    var e = n.config.timeline_placeholder;
    if (
      ((t = t || []),
      e && t.filter((l) => l.id === "timeline_placeholder_task").length === 0)
    ) {
      var i = n.getState(),
        a = null,
        r = i.min_date,
        s = i.max_date;
      t.length && (a = t[t.length - 1].id);
      var o = {
        start_date: r,
        end_date: s,
        row_height: e.height || 0,
        id: "timeline_placeholder_task",
        unscheduled: !0,
        lastTaskId: a,
        calendar_id: e.calendar || "global",
        $source: [],
        $target: [],
      };
      t.push(o);
    }
  }
  function gr(t) {
    var n = {
        current_pos: null,
        dirs: { left: "left", right: "right", up: "up", down: "down" },
        path: [],
        clear: function () {
          (this.current_pos = null), (this.path = []);
        },
        point: function (a) {
          this.current_pos = t.copy(a);
        },
        get_lines: function (a) {
          this.clear(), this.point(a[0]);
          for (var r = 1; r < a.length; r++) this.line_to(a[r]);
          return this.get_path();
        },
        line_to: function (a) {
          var r = t.copy(a),
            s = this.current_pos,
            o = this._get_line(s, r);
          this.path.push(o), (this.current_pos = r);
        },
        get_path: function () {
          return this.path;
        },
        get_wrapper_sizes: function (a, r, s) {
          var o,
            l = r.$getConfig().link_wrapper_width,
            d = a.y - l / 2;
          switch (a.direction) {
            case this.dirs.left:
              o = {
                top: d,
                height: l,
                lineHeight: l,
                left: a.x - a.size - l / 2,
                width: a.size + l,
              };
              break;
            case this.dirs.right:
              o = {
                top: d,
                lineHeight: l,
                height: l,
                left: a.x - l / 2,
                width: a.size + l,
              };
              break;
            case this.dirs.up:
              o = {
                top: d - a.size,
                lineHeight: a.size + l,
                height: a.size + l,
                left: a.x - l / 2,
                width: l,
              };
              break;
            case this.dirs.down:
              o = {
                top: d,
                lineHeight: a.size + l,
                height: a.size + l,
                left: a.x - l / 2,
                width: l,
              };
          }
          return o;
        },
        get_line_sizes: function (a, r) {
          var s,
            o = r.$getConfig(),
            l = o.link_line_width,
            d = o.link_wrapper_width,
            c = a.size + l;
          switch (a.direction) {
            case this.dirs.left:
            case this.dirs.right:
              s = {
                height: l,
                width: c,
                marginTop: (d - l) / 2,
                marginLeft: (d - l) / 2,
              };
              break;
            case this.dirs.up:
            case this.dirs.down:
              s = {
                height: c,
                width: l,
                marginTop: (d - l) / 2,
                marginLeft: (d - l) / 2,
              };
          }
          return s;
        },
        render_line: function (a, r, s, o) {
          var l = this.get_wrapper_sizes(a, s, o),
            d = document.createElement("div");
          (d.style.cssText = [
            "top:" + l.top + "px",
            "left:" + l.left + "px",
            "height:" + l.height + "px",
            "width:" + l.width + "px",
          ].join(";")),
            (d.className = "gantt_line_wrapper");
          var c = this.get_line_sizes(a, s),
            u = document.createElement("div");
          return (
            (u.style.cssText = [
              "height:" + c.height + "px",
              "width:" + c.width + "px",
              "margin-top:" + c.marginTop + "px",
              "margin-left:" + c.marginLeft + "px",
            ].join(";")),
            (u.className = "gantt_link_line_" + a.direction),
            d.appendChild(u),
            d
          );
        },
        render_corner: function (a, r) {
          const s = a.radius,
            o = r.$getConfig(),
            l = o.link_line_width || 2,
            d = document.createElement("div");
          let c, u;
          return (
            d.classList.add("gantt_link_corner"),
            d.classList.add(
              `gantt_link_corner_${a.direction.from}_${a.direction.to}`
            ),
            (d.style.width = `${s}px`),
            (d.style.height = `${s}px`),
            a.direction.from === "right" && a.direction.to === "down"
              ? ((c = "Right"),
                (u = "Top"),
                (d.style.left = a.x - o.link_line_width / 2 + "px"),
                (d.style.top = `${a.y}px`))
              : a.direction.from === "down" && a.direction.to === "right"
              ? ((c = "Left"),
                (u = "Bottom"),
                (d.style.left = a.x - o.link_line_width / 2 + "px"),
                (d.style.top = `${a.y}px`))
              : a.direction.from === "right" && a.direction.to === "up"
              ? ((c = "Right"),
                (u = "Bottom"),
                (d.style.left = a.x - o.link_line_width / 2 + "px"),
                (d.style.top = a.y - s + "px"))
              : a.direction.from === "up" && a.direction.to === "right"
              ? ((c = "Left"),
                (u = "Top"),
                (d.style.left = a.x - o.link_line_width / 2 + "px"),
                (d.style.top = a.y - s + "px"))
              : a.direction.from === "left" && a.direction.to === "down"
              ? ((c = "Left"),
                (u = "Top"),
                (d.style.left = a.x - s - o.link_line_width / 2 + "px"),
                (d.style.top = `${a.y}px`))
              : a.direction.from === "down" && a.direction.to === "left"
              ? ((c = "Right"),
                (u = "Bottom"),
                (d.style.left = a.x - s - o.link_line_width / 2 + "px"),
                (d.style.top = `${a.y}px`))
              : a.direction.from === "left" && a.direction.to === "up"
              ? ((c = "Left"),
                (u = "Bottom"),
                (d.style.left = a.x - s - o.link_line_width / 2 + "px"),
                (d.style.top = a.y - s + "px"))
              : a.direction.from === "up" &&
                a.direction.to === "left" &&
                ((c = "Right"),
                (u = "Top"),
                (d.style.left = a.x - s - o.link_line_width / 2 + "px"),
                (d.style.top = a.y - s + "px")),
            (d.style[`border${u}Width`] = `${l}px`),
            (d.style[`border${c}Width`] = `${l}px`),
            (d.style[`border${c}Style`] = "solid"),
            (d.style[`border${u}Style`] = "solid"),
            (d.style[`border${u}${c}Radius`] = `${s}px`),
            d
          );
        },
        render_arrow(a, r) {
          var s = document.createElement("div"),
            o = a.y,
            l = a.x,
            d = r.link_arrow_size;
          s.style.setProperty("--dhx-gantt-icon-size", `${d}px`);
          var c = "gantt_link_arrow gantt_link_arrow_" + a.direction;
          return (
            (s.style.top = o + "px"),
            (s.style.left = l + "px"),
            (s.className = c),
            s
          );
        },
        _get_line: function (a, r) {
          var s = this.get_direction(a, r),
            o = { x: a.x, y: a.y, direction: this.get_direction(a, r) };
          return (
            s == this.dirs.left || s == this.dirs.right
              ? (o.size = Math.abs(a.x - r.x))
              : (o.size = Math.abs(a.y - r.y)),
            o
          );
        },
        get_direction: function (a, r) {
          return r.x < a.x
            ? this.dirs.left
            : r.x > a.x
            ? this.dirs.right
            : r.y > a.y
            ? this.dirs.down
            : this.dirs.up;
        },
      },
      e = {
        path: [],
        clear: function () {
          this.path = [];
        },
        current: function () {
          return this.path[this.path.length - 1];
        },
        point: function (a) {
          return a ? (this.path.push(t.copy(a)), a) : this.current();
        },
        point_to: function (a, r, s) {
          s = s ? { x: s.x, y: s.y } : t.copy(this.point());
          var o = n.dirs;
          switch (a) {
            case o.left:
              s.x -= r;
              break;
            case o.right:
              s.x += r;
              break;
            case o.up:
              s.y -= r;
              break;
            case o.down:
              s.y += r;
          }
          return this.point(s);
        },
        get_points: function (a, r, s, o) {
          var l = this.get_endpoint(a, r, s, o),
            d = t.config,
            c = l.e_y - l.y,
            u = l.e_x - l.x,
            h = n.dirs,
            _ = r.getItemHeight(a.source);
          this.clear(), this.point({ x: l.x, y: l.y });
          var f = 2 * d.link_arrow_size,
            y = this.get_line_type(a, r.$getConfig()),
            v = l.e_x > l.x;
          if (y.from_start && y.to_start)
            this.point_to(h.left, f),
              v
                ? (this.point_to(h.down, c), this.point_to(h.right, u))
                : (this.point_to(h.right, u), this.point_to(h.down, c)),
              this.point_to(h.right, f);
          else if (!y.from_start && y.to_start)
            if (
              (c !== 0 && (v = l.e_x > l.x + 2 * f),
              this.point_to(h.right, f),
              v)
            )
              (u -= f), this.point_to(h.down, c), this.point_to(h.right, u);
            else {
              u -= 2 * f;
              var b = c > 0 ? 1 : -1;
              this.point_to(h.down, b * (_ / 2)),
                this.point_to(h.right, u),
                this.point_to(h.down, b * (Math.abs(c) - _ / 2)),
                this.point_to(h.right, f);
            }
          else
            y.from_start || y.to_start
              ? y.from_start &&
                !y.to_start &&
                (c !== 0 && (v = l.e_x > l.x - 2 * f),
                this.point_to(h.left, f),
                v
                  ? ((u += 2 * f),
                    (b = c > 0 ? 1 : -1),
                    this.point_to(h.down, b * (_ / 2)),
                    this.point_to(h.right, u),
                    this.point_to(h.down, b * (Math.abs(c) - _ / 2)),
                    this.point_to(h.left, f))
                  : ((u += f),
                    this.point_to(h.down, c),
                    this.point_to(h.right, u)))
              : (this.point_to(h.right, f),
                v
                  ? (this.point_to(h.right, u), this.point_to(h.down, c))
                  : (this.point_to(h.down, c), this.point_to(h.right, u)),
                this.point_to(h.left, f));
          return this.path;
        },
        get_line_type: function (a, r) {
          var s = r.links,
            o = !1,
            l = !1;
          return (
            a.type == s.start_to_start
              ? (o = l = !0)
              : a.type == s.finish_to_finish
              ? (o = l = !1)
              : a.type == s.finish_to_start
              ? ((o = !1), (l = !0))
              : a.type == s.start_to_finish
              ? ((o = !0), (l = !1))
              : t.assert(!1, "Invalid link type"),
            r.rtl && ((o = !o), (l = !l)),
            { from_start: o, to_start: l }
          );
        },
        get_endpoint: function (a, r, s, o) {
          var l = r.$getConfig(),
            d = this.get_line_type(a, l),
            c = d.from_start,
            u = d.to_start,
            h = i(s, r, l),
            _ = i(o, r, l);
          return {
            x: c ? h.left : h.left + h.width,
            e_x: u ? _.left : _.left + _.width,
            y: h.top + h.rowHeight / 2 - 1,
            e_y: _.top + _.rowHeight / 2 - 1,
          };
        },
      };
    function i(a, r, s) {
      var o = r.getItemPosition(a);
      let l = ee(t, r, a),
        d = l.maxHeight,
        c = l.splitChild;
      const u =
        t.config.baselines &&
        (t.config.baselines.render_mode == "separateRow" ||
          t.config.baselines.render_mode == "individualRow") &&
        a.baselines &&
        a.baselines.length;
      let h;
      l.shrinkHeight && (o.rowHeight = d);
      let _ = t.getTaskType(a.type) == s.types.milestone;
      if (_) {
        let f = r.getBarHeight(a.id, !0);
        (h = Math.sqrt(2 * f * f)),
          l.shrinkHeight && d < f && ((f = d), (h = d)),
          (o.left -= h / 2),
          (o.width = h);
      }
      if (c)
        if (d >= o.height) {
          const f = Ft(t, a.parent);
          u || f
            ? _
              ? ((o.rowHeight = o.height + 4),
                (o.left += (o.width - o.rowHeight + 4) / 2),
                (o.width = o.rowHeight - 3))
              : (o.rowHeight = o.height + 6)
            : _ && (o.left += (h - o.height) / 2);
        } else
          (o.rowHeight = d + 2),
            _ &&
              ((o.left += (o.width - o.rowHeight + 4) / 2),
              (o.width = o.rowHeight - 3));
      else u && (o.rowHeight = o.height + 4);
      return o;
    }
    return {
      render: function (a, r, s) {
        var o = t.getTask(a.source);
        if (o.hide_bar) return;
        var l = t.getTask(a.target);
        if (l.hide_bar) return;
        var d = e.get_endpoint(a, r, o, l),
          c = d.e_y - d.y;
        if (!(d.e_x - d.x) && !c) return null;
        var u = e.get_points(a, r, o, l);
        const h = (function (v, b) {
            const g = b.link_radius || 4,
              m = b.link_arrow_size || 6,
              p = [];
            for (let w = 0; w < v.length; w++) {
              const x = v[w],
                $ = v[w + 1];
              if (!$ || b.link_radius <= 1) p.push({ type: "line", data: x });
              else if (x.direction !== $.direction) {
                if (x.size < g || $.size < g) {
                  p.push({ type: "line", data: x });
                  continue;
                }
                (x.size -= g), p.push({ type: "line", data: x });
                let S = x.x,
                  T = x.y - b.link_line_width / 2;
                switch (x.direction) {
                  case "right":
                    S += x.size;
                    break;
                  case "left":
                    S -= x.size;
                    break;
                  case "down":
                    T += x.size;
                    break;
                  case "up":
                    T -= x.size;
                }
                const E = {
                  x: S,
                  y: T,
                  direction: { from: x.direction, to: $.direction },
                  radius: g,
                };
                switch ((p.push({ type: "corner", data: E }), $.direction)) {
                  case "right":
                    ($.x += g), ($.size -= g);
                    break;
                  case "left":
                    ($.x -= g), ($.size -= g);
                    break;
                  case "down":
                    ($.y += g), ($.size -= g);
                    break;
                  case "up":
                    ($.y -= g), ($.size -= g);
                }
              } else p.push({ type: "line", data: x });
            }
            const k = v[v.length - 1];
            if (k.direction === "right" || k.direction === "left") {
              k.size -= (3 * m) / 4;
              let w =
                  k.direction === "right" ? k.x + k.size : k.x - k.size - m / 2,
                x = k.y - b.link_line_width / 2 - m / 2 + 1;
              k.direction === "left" ? ((x -= 1), (w -= 2)) : (w -= 1);
              const $ = { x: w, y: x, size: m, direction: k.direction };
              p.push({ type: "line", data: k }),
                p.push({ type: "arrow", data: $ });
            } else p.push({ type: "line", data: k });
            return p;
          })(
            n.get_lines(u, r).filter((v) => v.size > 0),
            s
          ),
          _ = (function (v, b, g, m) {
            const p = document.createElement("div");
            return (
              v.forEach((k) => {
                let w;
                k.type === "line"
                  ? (w = n.render_line(k.data, null, b, g.source))
                  : k.type === "corner"
                  ? (w = n.render_corner(k.data, b))
                  : k.type === "arrow" && (w = n.render_arrow(k.data, m)),
                  p.appendChild(w);
              }),
              p
            );
          })(h, r, a, s);
        var f = "gantt_task_link";
        a.color && (f += " gantt_link_inline_color");
        var y = t.templates.link_class ? t.templates.link_class(a) : "";
        return (
          y && (f += " " + y),
          s.highlight_critical_path &&
            t.isCriticalLink &&
            t.isCriticalLink(a) &&
            (f += " gantt_critical_link"),
          (_.className = f),
          r.$config.link_attribute &&
            (_.setAttribute(r.$config.link_attribute, a.id),
            _.setAttribute("link_id", a.id)),
          a.color &&
            _.style.setProperty("--dhx-gantt-link-background", a.color),
          t._waiAria.linkAttr(a, _),
          _
        );
      },
      update: null,
      isInViewPort: qn,
      getVisibleRange: Gn(),
    };
  }
  function fr(t, n, e, i, a) {
    if (
      a.$ui.getView("grid") &&
      ((a.config.keyboard_navigation && a.getSelectedId()) ||
        (a.ext.inlineEditors && a.ext.inlineEditors.getState().id))
    )
      return !!t.$expanded_branch;
    var r = e.getItemTop(t.id),
      s = e.getItemHeight(t.id);
    return !(r > n.y_end || r + s < n.y);
  }
  function Kn(t) {
    let n = {};
    return (
      t.$data.tasksStore.attachEvent("onStoreUpdated", function () {
        n = {};
      }),
      function (e, i, a, r) {
        const s = e.id + "_" + i + "_" + a.unit + "_" + a.step;
        let o;
        return (
          (o = n[s]
            ? n[s]
            : (n[s] = (function (l, d, c, u) {
                let h,
                  _ = !1,
                  f = {};
                t.config.process_resource_assignments &&
                d === t.config.resource_property
                  ? ((h =
                      l.$role == "task"
                        ? t.getResourceAssignments(l.$resource_id, l.$task_id)
                        : t.getResourceAssignments(l.id)),
                    (_ = !0))
                  : (h = l.$role == "task" ? [] : t.getTaskBy(d, l.id)),
                  (f = (function ($, S, T) {
                    const E = S.unit,
                      C = S.step,
                      D = {},
                      A = {};
                    for (let I = 0; I < $.length; I++) {
                      const M = $[I];
                      let L = M;
                      if ((T && (L = t.getTask(M.task_id)), L.unscheduled))
                        continue;
                      let N = M.start_date || L.start_date,
                        P = M.end_date || L.end_date;
                      T &&
                        (M.start_date &&
                          (N = new Date(
                            Math.max(
                              M.start_date.valueOf(),
                              L.start_date.valueOf()
                            )
                          )),
                        M.end_date &&
                          (P = new Date(
                            Math.min(M.end_date.valueOf(), L.end_date.valueOf())
                          )),
                        M.mode &&
                          M.mode == "fixedDates" &&
                          ((N = M.start_date), (P = M.end_date)));
                      let R = Bt(S.trace_x, N.valueOf()),
                        B = new Date(
                          S.trace_x[R] || t.date[E + "_start"](new Date(N))
                        ),
                        H = new Date(Math.min(N.valueOf(), B.valueOf())),
                        F = t.config.work_time ? t.getTaskCalendar(L) : t;
                      for (A[F.id] = {}; H < P; ) {
                        const G = A[F.id],
                          j = H.valueOf();
                        (H = t.date.add(H, C, E)),
                          G[j] !== !1 &&
                            (D[j] || (D[j] = { tasks: [], assignments: [] }),
                            D[j].tasks.push(L),
                            T && D[j].assignments.push(M));
                      }
                    }
                    return D;
                  })(h, c, _));
                const y = c.unit,
                  v = c.step,
                  b = [];
                let g, m, p, k, w;
                const x = u.$getConfig();
                for (let $ = 0; $ < c.trace_x.length; $++)
                  (g = new Date(c.trace_x[$])),
                    (m = t.date.add(g, v, y)),
                    (w = f[g.valueOf()] || {}),
                    (p = w.tasks || []),
                    (k = w.assignments || []),
                    p.length || x.resource_render_empty_cells
                      ? b.push({
                          start_date: g,
                          end_date: m,
                          tasks: p,
                          assignments: k,
                        })
                      : b.push(null);
                return b;
              })(e, i, a, r))),
          o
        );
      }
    );
  }
  function pr(t, n, e, i) {
    var a = 100 * (1 - (1 * t || 0)),
      r = i.posFromDate(n),
      s = i.posFromDate(e),
      o = document.createElement("div");
    return (
      (o.className = "gantt_histogram_hor_bar"),
      (o.style.top = a + "%"),
      (o.style.left = r + "px"),
      (o.style.width = s - r + 1 + "px"),
      o
    );
  }
  function mr(t, n, e) {
    if (t === n) return null;
    var i = 1 - Math.max(t, n),
      a = Math.abs(t - n),
      r = document.createElement("div");
    return (
      (r.className = "gantt_histogram_vert_bar"),
      (r.style.top = 100 * i + "%"),
      (r.style.height = 100 * a + "%"),
      (r.style.left = e + "px"),
      r
    );
  }
  function vr(t) {
    var n = Kn(t),
      e = {},
      i = {},
      a = {};
    function r(l, d) {
      var c = e[l];
      c && c[d] && c[d].parentNode && c[d].parentNode.removeChild(c[d]);
    }
    function s(l, d, c, u, h, _, f) {
      var y = a[l.id];
      y && y.parentNode && y.parentNode.removeChild(y);
      var v = (function (b, g, m, p) {
        for (
          var k = g.getScale(),
            w = document.createElement("div"),
            x = Dt(k, p),
            $ = x.start;
          $ <= x.end;
          $++
        ) {
          var S = k.trace_x[$],
            T = k.trace_x[$ + 1] || t.date.add(S, k.step, k.unit),
            E = k.trace_x[$].valueOf(),
            C = Math.min(b[E] / m, 1) || 0;
          if (C < 0) return null;
          var D = Math.min(b[T.valueOf()] / m, 1) || 0,
            A = pr(C, S, T, g);
          A && w.appendChild(A);
          var I = mr(C, D, g.posFromDate(T));
          I && w.appendChild(I);
        }
        return w;
      })(c, h, _, f);
      return (
        v &&
          d &&
          (v.setAttribute("data-resource-id", l.id),
          v.setAttribute(h.$config.item_attribute, l.id),
          (v.style.position = "absolute"),
          (v.style.top = d.top + 1 + "px"),
          (v.style.height = h.getItemHeight(l.id) - 1 + "px"),
          (v.style.left = 0)),
        v
      );
    }
    function o(l, d, c, u, h, _, f) {
      var y = h.histogram_cell_class(
          _.start_date,
          _.end_date,
          l,
          _.tasks,
          _.assignments
        ),
        v = h.histogram_cell_label(
          _.start_date,
          _.end_date,
          l,
          _.tasks,
          _.assignments
        ),
        b = h.histogram_cell_allocated(
          _.start_date,
          _.end_date,
          l,
          _.tasks,
          _.assignments
        ),
        g = f.getItemHeight(l.id) - 1;
      if (y || v) {
        var m = document.createElement("div");
        return (
          (m.className = ["gantt_histogram_cell", y].join(" ")),
          m.setAttribute(f.$config.item_attribute, l.id),
          (m.style.cssText = [
            "left:" + d.left + "px",
            "width:" + d.width + "px",
            "height:" + g + "px",
            "line-height:" + g + "px",
            "top:" + (d.top + 1) + "px",
          ].join(";")),
          v && (v = "<div class='gantt_histogram_label'>" + v + "</div>"),
          b &&
            (v =
              "<div class='gantt_histogram_fill' style='height:" +
              100 * Math.min(b / c || 0, 1) +
              "%;'></div>" +
              v),
          v && (m.innerHTML = v),
          m
        );
      }
      return null;
    }
    return {
      render: function (l, d, c, u) {
        var h = d.$getTemplates(),
          _ = d.getScale(),
          f = n(l, c.resource_property, _, d),
          y = [],
          v = {},
          b = l.capacity || d.$config.capacity || 24;
        (e[l.id] = {}), (i[l.id] = null), (a[l.id] = null);
        for (var g = !!u, m = Dt(_, u), p = m.start; p <= m.end; p++) {
          var k = f[p];
          if (k && (!g || Ut(p, _, u, t))) {
            var w = h.histogram_cell_capacity(
              k.start_date,
              k.end_date,
              l,
              k.tasks,
              k.assignments
            );
            v[k.start_date.valueOf()] = w || 0;
            var x = d.getItemPosition(l, k.start_date, k.end_date),
              $ = o(l, x, b, 0, h, k, d);
            $ && (y.push($), (e[l.id][p] = $));
          }
        }
        var S = null;
        if (y.length) {
          S = document.createElement("div");
          for (var T = 0; T < y.length; T++) S.appendChild(y[T]);
          var E = s(l, x, v, 0, d, b, u);
          E && (S.appendChild(E), (a[l.id] = E)), (i[l.id] = S);
        }
        return S;
      },
      update: function (l, d, c, u, h) {
        var _ = c.$getTemplates(),
          f = c.getScale(),
          y = n(l, u.resource_property, f, c),
          v = l.capacity || c.$config.capacity || 24,
          b = {},
          g = !!h,
          m = Dt(f, h),
          p = {};
        if (e && e[l.id]) for (var k in e[l.id]) p[k] = k;
        for (var w = m.start; w <= m.end; w++) {
          var x = y[w];
          if (((p[w] = !1), x)) {
            var $ = _.histogram_cell_capacity(
              x.start_date,
              x.end_date,
              l,
              x.tasks,
              x.assignments
            );
            b[x.start_date.valueOf()] = $ || 0;
            var S = c.getItemPosition(l, x.start_date, x.end_date);
            if (!g || Ut(w, f, h, t)) {
              var T = e[l.id];
              if (T && T[w])
                T && T[w] && !T[w].parentNode && d.appendChild(T[w]);
              else {
                var E = o(l, S, v, 0, _, x, c);
                E && (d.appendChild(E), (e[l.id][w] = E));
              }
            } else r(l.id, w);
          }
        }
        for (var k in p) p[k] !== !1 && r(l.id, k);
        var C = s(l, S, b, 0, c, v, h);
        C && (d.appendChild(C), (a[l.id] = C));
      },
      getRectangle: Ue,
      getVisibleRange: et,
    };
  }
  function Ge(t, n, e, i, a, r) {
    const s = { id: t.id, parent: t.id };
    function o(c) {
      if (!(c[r.start_date] && c[r.end_date])) return !1;
      for (let u = 0; u < r.length; u++) if (!c[r[u]]) return !1;
      return !0;
    }
    const l = o(t);
    let d = !1;
    return (
      l && ((s.start_date = t[r.start_date]), (s.end_date = t[r.end_date])),
      t.render == "split" &&
        a.eachTask(function (c) {
          o(c) &&
            ((d = !0),
            (s.start_date = s.start_date || c[r.start_date]),
            (s.end_date = s.end_date || c[r.end_date]),
            s.start_date < c[r.start_date] && (s.start_date = c[r.start_date]),
            s.end_date > c[r.end_date] && (s.end_date = c[r.end_date]));
        }),
      !(!l && !d) && Ot(s, n, e)
    );
  }
  function kr(t, n, e, i, a) {
    return a.config.auto_scheduling &&
      a.config.auto_scheduling.show_constraints !== !1
      ? Ge(t, n, e, 0, a, {
          start_date: "constraint_date",
          end_date: "constraint_date",
          additional_properties: ["constraint_type"],
        })
      : !1;
  }
  function yr(t) {
    const n = {};
    for (let i in t.config.constraint_types)
      n[t.config.constraint_types[i]] = i;
    function e(i, a, r) {
      const s = (function (_) {
        const f = t.getConstraintType(_);
        return n[f].toLowerCase();
      })(i);
      if (s == "asap" || s == "alap") return !1;
      const o = document.createElement("div"),
        l = t.getTaskPosition(i, i.constraint_date, i.constraint_date);
      let { height: d, marginTop: c } = Ln(t, a, l, 30, i, r),
        u = d,
        h = 0;
      switch (s) {
        case "snet":
        case "fnet":
        case "mso":
          h = t.config.rtl ? 1 : -u - 1;
          break;
        case "snlt":
        case "fnlt":
        case "mfo":
          h = t.config.rtl ? -u - 1 : 1;
      }
      switch (
        (i.type === t.config.types.milestone && (c -= 1),
        (o.style.height = d + "px"),
        (o.style.width = u + "px"),
        (o.style.left = l.left + "px"),
        (o.style.top = l.top + "px"),
        (o.style.marginLeft = h + "px"),
        (o.style.marginTop = c + "px"),
        (o.className = "gantt_constraint_marker gantt_constraint_marker_" + s),
        s)
      ) {
        case "snet":
        case "snlt":
        case "fnet":
        case "fnlt":
          o.innerHTML = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Start No Later Than">
<line id="Line 3" x1="30.5" y1="6.92097e-08" x2="30.5" y2="32" stroke="#555D63" stroke-width="3" stroke-dasharray="3 3"/>
<path id="Vector" d="m 18.3979,23.5 v -6 H 3.05161 L 3,14.485 H 18.3979 V 8.5 L 27,16 Z" fill="#555D63"/>
</g>
</svg>
`;
          break;
        case "mfo":
        case "mso":
          o.innerHTML = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
<g id="Must Start On ">
<path id="Vector" d="m 18.3979,23.5 v -6 H 3.05161 L 3,14.485 H 18.3979 V 8.5 L 27,16 Z" fill="#555D63"/>
<line id="line" x1="30.5" y1="-6.55671e-08" x2="30.5" y2="32" stroke="black" stroke-opacity="0.7" stroke-width="3"/>
</g>
</svg>
`;
      }
      return o.setAttribute("data-task-id", i.id), o;
    }
    return {
      render: function (i, a, r, s) {
        if (
          !t.config.auto_scheduling_compatibility &&
          t.config.auto_scheduling &&
          t.config.auto_scheduling.show_constraints !== !1
        ) {
          const o = document.createElement("div");
          if (
            ((o.className = "gantt_constraint_nodes"),
            o.setAttribute("data-task-row-id", i.id),
            i.constraint_date && i.constraint_type)
          ) {
            const l = e(i, a);
            l && o.appendChild(l);
          }
          if (ft(i)) {
            const l = Ft(t, i.id);
            t.eachTask(function (d) {
              if (d.constraint_date && d.constraint_type) {
                const c = e(d, a, l);
                c && o.appendChild(c);
              }
            }, i.id);
          }
          if (o.childNodes.length) return o;
        }
      },
      isInViewPort: kr,
      getVisibleRange: et,
    };
  }
  function br(t, n, e, i, a) {
    return Ge(t, n, e, 0, a, { start_date: "deadline", end_date: "deadline" });
  }
  function $r(t, n, e, i, a) {
    let r = !1;
    const s = { start_date: "start_date", end_date: "end_date" };
    return (
      t.type == a.config.types.milestone && (s.end_date = s.start_date),
      t.baselines && (r = Xn(t, n, e, i, a, s)),
      ft(t) &&
        a.eachTask(function (o) {
          r ||
            (o.baselines &&
              o.baselines.length &&
              (o.type == a.config.types.milestone &&
                (s.end_date = s.start_date),
              Xn(o, n, e, i, a, s) && (r = !0)));
        }, t.id),
      r
    );
  }
  function Xn(t, n, e, i, a, r) {
    for (var s = 0; s < t.baselines.length; s++)
      if (
        Ge(
          {
            id: t.id,
            parent: t.parent,
            start_date: t.baselines[s].start_date,
            end_date: t.baselines[s].end_date,
          },
          n,
          e,
          0,
          a,
          r
        )
      )
        return !0;
  }
  const xr = {
      init: function (t, n) {
        var e = t.$services.getService("dnd");
        if (n.$config.bind && t.getDatastore(n.$config.bind)) {
          var i = new e(n.$grid_data, { updates_per_second: 60 });
          t.defined(n.$getConfig().dnd_sensitivity) &&
            (i.config.sensitivity = n.$getConfig().dnd_sensitivity),
            i.attachEvent(
              "onBeforeDragStart",
              t.bind(function (o, l) {
                var d = a(l);
                if (
                  !d ||
                  (t.hideQuickInfo && t.hideQuickInfo(),
                  dt(l.target, ".gantt_grid_editor_placeholder"))
                )
                  return !1;
                var c = d.getAttribute(n.$config.item_attribute);
                if (s(c)) return !1;
                var u = r().getItem(c);
                return (
                  !t.isReadonly(u) &&
                  ((i.config.initial_open_state = u.$open),
                  !!t.callEvent("onRowDragStart", [
                    c,
                    l.target || l.srcElement,
                    l,
                  ]) && void 0)
                );
              }, t)
            ),
            i.attachEvent(
              "onAfterDragStart",
              t.bind(function (o, l) {
                var d = a(l);
                i.config.marker.innerHTML = d.outerHTML;
                var c = i.config.marker.firstChild;
                c && (c.style.position = "static"),
                  (i.config.id = d.getAttribute(n.$config.item_attribute));
                var u = r(),
                  h = u.getItem(i.config.id);
                (i.config.index = u.getBranchIndex(i.config.id)),
                  (i.config.parent = h.parent),
                  (h.$open = !1),
                  (h.$transparent = !0),
                  this.refreshData();
              }, t)
            ),
            (i.lastTaskOfLevel = function (o) {
              for (
                var l = null, d = r().getItems(), c = 0, u = d.length;
                c < u;
                c++
              )
                d[c].$level == o && (l = d[c]);
              return l ? l.id : null;
            }),
            (i._getGridPos = t.bind(function (o) {
              var l = Y(n.$grid_data),
                d = l.x + n.$grid.scrollLeft,
                c = o.pos.y - 10,
                u = n.getItemHeight(i.config.id);
              c < l.y && (c = l.y);
              var h = n.getTotalHeight();
              c > l.y + h - u && (c = l.y + h - u);
              const _ = l.y + l.height;
              return c > _ - u && (c = _ - u), (l.x = d), (l.y = c), l;
            }, t)),
            (i._getTargetY = t.bind(function (o) {
              var l = Y(n.$grid_data),
                d = n.$state.scrollTop || 0,
                c = t.$grid_data.getBoundingClientRect().height + d,
                u = o.pageY - l.y + d;
              return u > c ? (u = c) : u < d && (u = d), u;
            }, t)),
            (i._getTaskByY = t.bind(function (o, l) {
              var d = r();
              o = o || 0;
              var c = n.getItemIndexByTopPosition(o);
              return (c = l < c ? c - 1 : c) > d.countVisible() - 1
                ? null
                : d.getIdByIndex(c);
            }, t)),
            i.attachEvent(
              "onDragMove",
              t.bind(function (o, l) {
                var d = t.$grid_data.getBoundingClientRect(),
                  c =
                    d.height + d.y + (n.$state.scrollTop || 0) + window.scrollY,
                  u = i.config,
                  h = i._getGridPos(l);
                t._waiAria.reorderMarkerAttr(u.marker);
                var _ = n.$getConfig(),
                  f = r();
                h.y < c
                  ? (u.marker.style.top = h.y + "px")
                  : (u.marker.style.top = c + "px"),
                  (u.marker.style.left = h.x + 10 + "px");
                const y = Y(t.$root);
                h.width > y.width &&
                  ((u.marker.style.width = y.width - 10 - 2 + "px"),
                  (u.marker.style.overflow = "hidden"));
                var v = f.getItem(i.config.id),
                  b = i._getTargetY(l),
                  g = i._getTaskByY(b, f.getIndexById(v.id));
                function m(D, A) {
                  return (
                    !f.isChildOf(p.id, A.id) &&
                    (D.$level == A.$level || _.order_branch_free)
                  );
                }
                if (
                  (f.exists(g) ||
                    ((g = i.lastTaskOfLevel(
                      _.order_branch_free ? v.$level : 0
                    )) == i.config.id &&
                      (g = null)),
                  f.exists(g))
                ) {
                  var p = f.getItem(g),
                    k = n.getItemTop(p.id),
                    w = n.getItemHeight(p.id);
                  if (k + w / 2 < b) {
                    var x = f.getIndexById(p.id),
                      $ = f.getNext(p.id),
                      S = f.getItem($);
                    if (s($)) {
                      var T = f.getPrev(S.id);
                      S = f.getItem(T);
                    }
                    if (S) {
                      if (S.id == v.id)
                        return _.order_branch_free &&
                          f.isChildOf(v.id, p.id) &&
                          f.getChildren(p.id).length == 1
                          ? void f.move(
                              v.id,
                              f.getBranchIndex(p.id) + 1,
                              f.getParent(p.id)
                            )
                          : void 0;
                      p = S;
                    } else if (
                      (($ = f.getIdByIndex(x)),
                      (S = f.getItem($)),
                      s($) && ((T = f.getPrev(S.id)), (S = f.getItem(T))),
                      m(S, v) && S.id != v.id)
                    )
                      return void f.move(v.id, -1, f.getParent(S.id));
                  } else if (
                    _.order_branch_free &&
                    p.id != v.id &&
                    m(p, v) &&
                    !s(p.id)
                  ) {
                    if (!f.hasChild(p.id))
                      return (p.$open = !0), void f.move(v.id, -1, p.id);
                    if (f.getIndexById(p.id) || w / 3 < b) return;
                  }
                  (x = f.getIndexById(p.id)), (T = f.getIdByIndex(x - 1));
                  for (
                    var E = f.getItem(T), C = 1;
                    (!E || E.id == p.id) && x - C >= 0;

                  )
                    (T = f.getIdByIndex(x - C)), (E = f.getItem(T)), C++;
                  if (v.id == p.id || s(p.id)) return;
                  m(p, v) && v.id != p.id
                    ? f.move(v.id, 0, 0, p.id)
                    : p.$level != v.$level - 1 || f.getChildren(p.id).length
                    ? E &&
                      m(E, v) &&
                      v.id != E.id &&
                      f.move(v.id, -1, f.getParent(E.id))
                    : f.move(v.id, 0, p.id);
                }
                return !0;
              }, t)
            ),
            i.attachEvent(
              "onDragEnd",
              t.bind(function () {
                var o = r(),
                  l = o.getItem(i.config.id);
                (l.$transparent = !1),
                  (l.$open = i.config.initial_open_state),
                  this.callEvent("onBeforeRowDragEnd", [
                    i.config.id,
                    i.config.parent,
                    i.config.index,
                  ]) === !1
                    ? (o.move(i.config.id, i.config.index, i.config.parent),
                      (l.$drop_target = null))
                    : this.callEvent("onRowDragEnd", [
                        i.config.id,
                        l.$drop_target,
                      ]),
                  t.render(),
                  this.refreshData();
              }, t)
            );
        }
        function a(o) {
          return Q(o, n.$config.item_attribute);
        }
        function r() {
          return t.getDatastore(n.$config.bind);
        }
        function s(o) {
          return jt(o, t, r());
        }
      },
    },
    at = {
      createDropTargetObject: function (t) {
        var n = {
          targetParent: null,
          targetIndex: 0,
          targetId: null,
          child: !1,
          nextSibling: !1,
          prevSibling: !1,
        };
        return t && O(n, t, !0), n;
      },
      nextSiblingTarget: function (t, n, e) {
        var i = this.createDropTargetObject();
        return (
          (i.targetId = n),
          (i.nextSibling = !0),
          (i.targetParent = e.getParent(i.targetId)),
          (i.targetIndex = e.getBranchIndex(i.targetId)),
          (e.getParent(t) != i.targetParent ||
            i.targetIndex < e.getBranchIndex(t)) &&
            (i.targetIndex += 1),
          i
        );
      },
      prevSiblingTarget: function (t, n, e) {
        var i = this.createDropTargetObject();
        return (
          (i.targetId = n),
          (i.prevSibling = !0),
          (i.targetParent = e.getParent(i.targetId)),
          (i.targetIndex = e.getBranchIndex(i.targetId)),
          e.getParent(t) == i.targetParent &&
            i.targetIndex > e.getBranchIndex(t) &&
            (i.targetIndex -= 1),
          i
        );
      },
      firstChildTarget: function (t, n, e) {
        var i = this.createDropTargetObject();
        return (
          (i.targetId = n),
          (i.targetParent = i.targetId),
          (i.targetIndex = 0),
          (i.child = !0),
          i
        );
      },
      lastChildTarget: function (t, n, e) {
        var i = e.getChildren(n),
          a = this.createDropTargetObject();
        return (
          (a.targetId = i[i.length - 1]),
          (a.targetParent = n),
          (a.targetIndex = i.length),
          (a.nextSibling = !0),
          a
        );
      },
    };
  function Zn(t, n, e, i, a) {
    for (var r = n; i.exists(r); ) {
      var s = i.calculateItemLevel(i.getItem(r));
      if ((s === e || s === e - 1) && i.getBranchIndex(r) > -1) break;
      r = a ? i.getPrev(r) : i.getNext(r);
    }
    return i.exists(r)
      ? i.calculateItemLevel(i.getItem(r)) === e
        ? a
          ? at.nextSiblingTarget(t, r, i)
          : at.prevSiblingTarget(t, r, i)
        : at.firstChildTarget(t, r, i)
      : null;
  }
  function qe(t, n, e, i) {
    return Zn(t, n, e, i, !0);
  }
  function Qn(t, n, e, i) {
    return Zn(t, n, e, i, !1);
  }
  function ti(t, n, e, i, a, r) {
    var s;
    if (n !== a.$getRootId()) {
      var o = a.getItem(n),
        l = a.calculateItemLevel(o);
      if (l === r) {
        var d = a.getPrevSibling(n);
        e < 0.5 && !d
          ? (s = at.prevSiblingTarget(t, n, a))
          : (e < 0.5 && (n = d), (s = at.nextSiblingTarget(t, n, a)));
      } else if (l > r)
        a.eachParent(function (f) {
          a.calculateItemLevel(f) === r && (n = f.id);
        }, o),
          (s = qe(t, n, r, a));
      else {
        var c = qe(t, n, r, a),
          u = Qn(t, n, r, a);
        s = e < 0.5 ? c : u;
      }
    } else {
      var h = a.$getRootId(),
        _ = a.getChildren(h);
      (s = at.createDropTargetObject()),
        (s =
          _.length && i >= 0
            ? qe(
                t,
                (function (f) {
                  for (var y = f.getNext(); f.exists(y); ) {
                    var v = f.getNext(y);
                    if (!f.exists(v)) return y;
                    y = v;
                  }
                  return null;
                })(a),
                r,
                a
              )
            : Qn(t, h, r, a));
    }
    return s;
  }
  function ei(t, n) {
    var e = Y(n.$grid_data);
    return (
      (t.x += e.x + n.$grid.scrollLeft),
      (t.y += e.y - n.$grid_data.scrollTop),
      t
    );
  }
  function Ye(t, n, e = 0) {
    const i = Y(t.$root);
    return n > i.width && (n = i.width - e - 2), n;
  }
  const ni = {
      removeLineHighlight: function (t) {
        t.markerLine &&
          t.markerLine.parentNode &&
          t.markerLine.parentNode.removeChild(t.markerLine),
          (t.markerLine = null);
      },
      highlightPosition: function (t, n, e) {
        var i = (function (r, s) {
          var o = Y(s.$grid_data),
            l = lt(r, s.$grid_data),
            d = o.x + s.$grid.scrollLeft,
            c = l.y - 10,
            u = s.getItemHeight(r.targetId);
          c < o.y && (c = o.y);
          var h = s.getTotalHeight();
          return (
            c > o.y + h - u && (c = o.y + h - u),
            (o.x = d),
            (o.y = c),
            (o.width = Ye(s.$gantt, o.width, 9)),
            o
          );
        })(t, e);
        (n.marker.style.left = i.x + 9 + "px"),
          (n.marker.style.width = i.width + "px"),
          (n.marker.style.overflow = "hidden");
        var a = n.markerLine;
        a ||
          (((a = document.createElement("div")).className =
            "gantt_drag_marker gantt_grid_dnd_marker"),
          (a.innerHTML = "<div class='gantt_grid_dnd_marker_line'></div>"),
          (a.style.pointerEvents = "none")),
          t.child
            ? (function (r, s, o) {
                var l = r.targetParent,
                  d = ei({ x: 0, y: o.getItemTop(l) }, o),
                  c =
                    o.$grid_data.getBoundingClientRect().bottom +
                    window.scrollY;
                let u = Ye(o.$gantt, o.$grid_data.offsetWidth);
                (s.innerHTML =
                  "<div class='gantt_grid_dnd_marker_folder'></div>"),
                  (s.style.width = u + "px"),
                  (s.style.top = d.y + "px"),
                  (s.style.left = d.x + "px"),
                  (s.style.height = o.getItemHeight(l) + "px"),
                  d.y > c && (s.style.top = c + "px");
              })(t, a, e)
            : (function (r, s, o) {
                var l = (function (u, h) {
                    var _ = h.$config.rowStore,
                      f = { x: 0, y: 0 },
                      y = h.$grid_data.querySelector(".gantt_tree_indent"),
                      v = 15,
                      b = 0;
                    y && (v = y.offsetWidth);
                    var g = 40;
                    if (u.targetId !== _.$getRootId()) {
                      var m = h.getItemTop(u.targetId),
                        p = h.getItemHeight(u.targetId);
                      if (
                        ((b = _.exists(u.targetId)
                          ? _.calculateItemLevel(_.getItem(u.targetId))
                          : 0),
                        u.prevSibling)
                      )
                        f.y = m;
                      else if (u.nextSibling) {
                        var k = 0;
                        _.eachItem(function (w) {
                          _.getIndexById(w.id) !== -1 && k++;
                        }, u.targetId),
                          (f.y = m + p + k * p);
                      } else (f.y = m + p), (b += 1);
                    }
                    return (
                      (f.x = g + b * v),
                      (f.width = Ye(
                        h.$gantt,
                        Math.max(h.$grid_data.offsetWidth - f.x, 0),
                        f.x
                      )),
                      ei(f, h)
                    );
                  })(r, o),
                  d =
                    o.$grid_data.getBoundingClientRect().bottom +
                    window.scrollY;
                (s.innerHTML =
                  "<div class='gantt_grid_dnd_marker_line'></div>"),
                  (s.style.left = l.x + "px"),
                  (s.style.height = "4px");
                var c = l.y - 2;
                (s.style.top = c + "px"),
                  (s.style.width = l.width + "px"),
                  c > d && (s.style.top = d + "px");
              })(t, a, e),
          n.markerLine || (document.body.appendChild(a), (n.markerLine = a));
      },
    },
    wr = {
      init: function (t, n) {
        var e = t.$services.getService("dnd");
        if (n.$config.bind && t.getDatastore(n.$config.bind)) {
          var i = new e(n.$grid_data, { updates_per_second: 60 });
          t.defined(n.$getConfig().dnd_sensitivity) &&
            (i.config.sensitivity = n.$getConfig().dnd_sensitivity),
            i.attachEvent(
              "onBeforeDragStart",
              t.bind(function (o, l) {
                var d = a(l);
                if (
                  !d ||
                  (t.hideQuickInfo && t.hideQuickInfo(),
                  dt(l.target, ".gantt_grid_editor_placeholder"))
                )
                  return !1;
                var c = d.getAttribute(n.$config.item_attribute),
                  u = n.$config.rowStore.getItem(c);
                return (
                  !t.isReadonly(u) &&
                  !r(c) &&
                  ((i.config.initial_open_state = u.$open),
                  !!t.callEvent("onRowDragStart", [
                    c,
                    l.target || l.srcElement,
                    l,
                  ]) && void 0)
                );
              }, t)
            ),
            i.attachEvent(
              "onAfterDragStart",
              t.bind(function (o, l) {
                var d = a(l);
                i.config.marker.innerHTML = d.outerHTML;
                var c = i.config.marker.firstChild;
                c &&
                  ((i.config.marker.style.opacity = 0.4),
                  (c.style.position = "static"),
                  (c.style.pointerEvents = "none")),
                  (i.config.id = d.getAttribute(n.$config.item_attribute));
                var u = n.$config.rowStore,
                  h = u.getItem(i.config.id);
                (i.config.level = u.calculateItemLevel(h)),
                  (i.config.drop_target = at.createDropTargetObject({
                    targetParent: u.getParent(h.id),
                    targetIndex: u.getBranchIndex(h.id),
                    targetId: h.id,
                    nextSibling: !0,
                  })),
                  (h.$open = !1),
                  (h.$transparent = !0),
                  this.refreshData();
              }, t)
            ),
            i.attachEvent(
              "onDragMove",
              t.bind(function (o, l) {
                var d = s(l);
                return (
                  (d &&
                    t.callEvent("onBeforeRowDragMove", [
                      i.config.id,
                      d.targetParent,
                      d.targetIndex,
                    ]) !== !1) ||
                    (d = at.createDropTargetObject(i.config.drop_target)),
                  ni.highlightPosition(d, i.config, n),
                  (i.config.drop_target = d),
                  t._waiAria.reorderMarkerAttr(i.config.marker),
                  this.callEvent("onRowDragMove", [
                    i.config.id,
                    d.targetParent,
                    d.targetIndex,
                  ]),
                  !0
                );
              }, t)
            ),
            i.attachEvent(
              "onDragEnd",
              t.bind(function () {
                var o = n.$config.rowStore,
                  l = o.getItem(i.config.id);
                ni.removeLineHighlight(i.config),
                  (l.$transparent = !1),
                  (l.$open = i.config.initial_open_state);
                var d = i.config.drop_target;
                this.callEvent("onBeforeRowDragEnd", [
                  i.config.id,
                  d.targetParent,
                  d.targetIndex,
                ]) === !1
                  ? (l.$drop_target = null)
                  : (o.move(i.config.id, d.targetIndex, d.targetParent),
                    t.render(),
                    this.callEvent("onRowDragEnd", [
                      i.config.id,
                      d.targetParent,
                      d.targetIndex,
                    ])),
                  o.refresh(l.id);
              }, t)
            );
        }
        function a(o) {
          return Q(o, n.$config.item_attribute);
        }
        function r(o) {
          return jt(o, t, t.getDatastore(n.$config.bind));
        }
        function s(o) {
          var l,
            d = (function (f) {
              var y = lt(f, n.$grid_data).y,
                v = n.$config.rowStore;
              document.doctype || (y += window.scrollY), (y = y || 0);
              var b = n.$state.scrollTop || 0,
                g =
                  t.$grid_data.getBoundingClientRect().height +
                  b +
                  window.scrollY,
                m = b,
                p = n.getItemIndexByTopPosition(n.$state.scrollTop);
              if ((v.exists(p) || (p = v.countVisible() - 1), p < 0))
                return v.$getRootId();
              var k = v.getIdByIndex(p),
                w = n.$state.scrollTop / n.getItemHeight(k),
                x = w - Math.floor(w);
              x > 0.1 &&
                x < 0.9 &&
                ((g -= n.getItemHeight(k) * x),
                (m += n.getItemHeight(k) * (1 - x)));
              const $ = Y(n.$grid_data),
                S = $.y + $.height,
                T = i.config.marker.offsetHeight;
              y + T + window.scrollY >= g &&
                (i.config.marker.style.top = S - T + "px"),
                y >= g
                  ? (y = g)
                  : y <= m &&
                    ((y = m), (i.config.marker.style.top = $.y + "px"));
              var E = n.getItemIndexByTopPosition(y);
              if (E > v.countVisible() - 1 || E < 0) return v.$getRootId();
              var C = v.getIdByIndex(E);
              return r(C) ? v.getPrevSibling(C) : v.getIdByIndex(E);
            })(o),
            c = null,
            u = n.$config.rowStore,
            h = !n.$getConfig().order_branch_free,
            _ = lt(o, n.$grid_data).y;
          return (
            document.doctype || (_ += window.scrollY),
            d !== u.$getRootId() &&
              (c = (_ - n.getItemTop(d)) / n.getItemHeight(d)),
            h
              ? (l = ti(i.config.id, d, c, _, u, i.config.level)) &&
                l.targetParent &&
                r(l.targetParent) &&
                ((d = u.getPrevSibling(l.targetParent)),
                (l = ti(i.config.id, d, c, _, u, i.config.level)))
              : (l = (function (f, y, v, b, g) {
                  var m;
                  if (y !== g.$getRootId())
                    m =
                      v < 0.25
                        ? at.prevSiblingTarget(f, y, g)
                        : !(v > 0.6) || (g.hasChild(y) && g.getItem(y).$open)
                        ? at.firstChildTarget(f, y, g)
                        : at.nextSiblingTarget(f, y, g);
                  else {
                    var p = g.$getRootId();
                    m =
                      g.hasChild(p) && b >= 0
                        ? at.lastChildTarget(f, p, g)
                        : at.firstChildTarget(f, p, g);
                  }
                  return m;
                })(i.config.id, d, c, _, u)),
            l
          );
        }
      },
    };
  var Sr = function (t) {
    return {
      onCreated: function (n) {
        (n.$config = O(n.$config, { bind: "task" })),
          n.$config.id == "grid" &&
            (this.extendGantt(n),
            (t.ext.inlineEditors = t.ext._inlineEditors.createEditors(n)),
            t.ext.inlineEditors.init()),
          (this._mouseDelegates = Pe(t));
      },
      onInitialized: function (n) {
        var e = n.$getConfig();
        e.order_branch &&
          (e.order_branch == "marker"
            ? wr.init(n.$gantt, n)
            : xr.init(n.$gantt, n)),
          this.initEvents(n, t),
          n.$config.id == "grid" && this.extendDom(n);
      },
      onDestroyed: function (n) {
        n.$config.id == "grid" && t.ext.inlineEditors.detachStore(),
          this.clearEvents(n, t);
      },
      initEvents: function (n, e) {
        this._mouseDelegates.delegate(
          "click",
          "gantt_row",
          e.bind(function (i, a, r) {
            const s = n.$getConfig();
            if (a !== null) {
              const o = this.getTask(a);
              if (s.scroll_on_click) {
                const l = !e._is_icon_open_click(i),
                  d = e.$ui.getView("timeline");
                l && d && this.showDate(o.start_date);
              }
              e.callEvent("onTaskRowClick", [a, r]);
            }
          }, e),
          n.$grid
        ),
          this._mouseDelegates.delegate(
            "click",
            "gantt_grid_head_cell",
            e.bind(function (i, a, r) {
              var s = r.getAttribute("data-column-id");
              if (e.callEvent("onGridHeaderClick", [s, i])) {
                var o = n.$getConfig();
                if (s != "add") {
                  if (o.sort && s) {
                    for (var l, d = s, c = 0; c < o.columns.length; c++)
                      if (o.columns[c].name == s) {
                        l = o.columns[c];
                        break;
                      }
                    if (
                      l &&
                      l.sort !== void 0 &&
                      l.sort !== !0 &&
                      !(d = l.sort)
                    )
                      return;
                    var u =
                      this._sort && this._sort.direction && this._sort.name == s
                        ? this._sort.direction
                        : "desc";
                    (u = u == "desc" ? "asc" : "desc"),
                      (this._sort = { name: s, direction: u }),
                      this.sort(d, u == "desc");
                  }
                } else
                  e.$services
                    .getService("mouseEvents")
                    .callHandler("click", "gantt_add", n.$grid, [i, o.root_id]);
              }
            }, e),
            n.$grid
          ),
          this._mouseDelegates.delegate(
            "click",
            "gantt_add",
            e.bind(function (i, a, r) {
              if (!n.$getConfig().readonly)
                return this.createTask({}, a || e.config.root_id), !1;
            }, e),
            n.$grid
          );
      },
      clearEvents: function (n, e) {
        this._mouseDelegates.destructor(), (this._mouseDelegates = null);
      },
      extendDom: function (n) {
        (t.$grid = n.$grid),
          (t.$grid_scale = n.$grid_scale),
          (t.$grid_data = n.$grid_data);
      },
      extendGantt: function (n) {
        (t.getGridColumns = t.bind(n.getGridColumns, n)),
          n.attachEvent("onColumnResizeStart", function () {
            return t.callEvent("onColumnResizeStart", arguments);
          }),
          n.attachEvent("onColumnResize", function () {
            return t.callEvent("onColumnResize", arguments);
          }),
          n.attachEvent("onColumnResizeEnd", function () {
            return t.callEvent("onColumnResizeEnd", arguments);
          }),
          n.attachEvent("onColumnResizeComplete", function (e, i) {
            t.config.grid_width = i;
          }),
          n.attachEvent("onBeforeRowResize", function () {
            return t.callEvent("onBeforeRowResize", arguments);
          }),
          n.attachEvent("onRowResize", function () {
            return t.callEvent("onRowResize", arguments);
          }),
          n.attachEvent("onBeforeRowResizeEnd", function () {
            return t.callEvent("onBeforeRowResizeEnd", arguments);
          }),
          n.attachEvent("onAfterRowResize", function () {
            return t.callEvent("onAfterRowResize", arguments);
          });
      },
    };
  };
  const Tr = {
    createTaskDND: function () {
      var t;
      return {
        extend: function (n) {
          n.roundTaskDates = function (e) {
            t.round_task_dates(e);
          };
        },
        init: function (n, e) {
          return (
            (t = (function (i, a) {
              var r = a.$services;
              return {
                drag: null,
                dragMultiple: {},
                _events: {
                  before_start: {},
                  before_finish: {},
                  after_finish: {},
                },
                _handlers: {},
                init: function () {
                  (this._domEvents = a._createDomEventScope()),
                    this.clear_drag_state();
                  var s = a.config.drag_mode;
                  this.set_actions(),
                    r.getService("state").registerProvider(
                      "tasksDnd",
                      z(function () {
                        return {
                          drag_id: this.drag ? this.drag.id : void 0,
                          drag_mode: this.drag ? this.drag.mode : void 0,
                          drag_from_start: this.drag ? this.drag.left : void 0,
                        };
                      }, this)
                    );
                  var o = {
                    before_start: "onBeforeTaskDrag",
                    before_finish: "onBeforeTaskChanged",
                    after_finish: "onAfterTaskDrag",
                  };
                  for (var l in this._events)
                    for (var d in s) this._events[l][d] = o[l];
                  (this._handlers[s.move] = this._move),
                    (this._handlers[s.resize] = this._resize),
                    (this._handlers[s.progress] = this._resize_progress);
                },
                set_actions: function () {
                  var s = i.$task_data;
                  this._domEvents.attach(
                    s,
                    "mousemove",
                    a.bind(function (o) {
                      this.on_mouse_move(o);
                    }, this)
                  ),
                    this._domEvents.attach(
                      s,
                      "mousedown",
                      a.bind(function (o) {
                        this.on_mouse_down(o);
                      }, this)
                    ),
                    this._domEvents.attach(
                      document.body,
                      "mouseup",
                      a.bind(function (o) {
                        this.on_mouse_up(o);
                      }, this)
                    );
                },
                clear_drag_state: function () {
                  (this.drag = {
                    id: null,
                    mode: null,
                    pos: null,
                    start_x: null,
                    start_y: null,
                    obj: null,
                    left: null,
                  }),
                    (this.dragMultiple = {});
                },
                _resize: function (s, o, l) {
                  var d = i.$getConfig(),
                    c = this._drag_task_coords(s, l);
                  l.left
                    ? ((s.start_date = a.dateFromPos(c.start + o)),
                      s.start_date ||
                        (s.start_date = new Date(a.getState().min_date)))
                    : ((s.end_date = a.dateFromPos(c.end + o)),
                      s.end_date ||
                        (s.end_date = new Date(a.getState().max_date)));
                  var u = this._calculateMinDuration(
                    d.min_duration,
                    d.duration_unit
                  );
                  s.end_date - s.start_date < d.min_duration &&
                    (l.left
                      ? (s.start_date = a.calculateEndDate(
                          s.end_date,
                          -u,
                          d.duration_unit,
                          s
                        ))
                      : (s.end_date = a.calculateEndDate(
                          s.start_date,
                          u,
                          d.duration_unit,
                          s
                        ))),
                    a._init_task_timing(s);
                },
                _calculateMinDuration: function (s, o) {
                  return Math.ceil(
                    s /
                      {
                        minute: 6e4,
                        hour: 36e5,
                        day: 864e5,
                        week: 6048e5,
                        month: 24192e5,
                        year: 31356e6,
                      }[o]
                  );
                },
                _resize_progress: function (s, o, l) {
                  var d = this._drag_task_coords(s, l),
                    c = i.$getConfig().rtl
                      ? d.start - l.pos.x
                      : l.pos.x - d.start,
                    u = Math.max(0, c);
                  s.progress = Math.min(1, u / Math.abs(d.end - d.start));
                },
                _find_max_shift: function (s, o) {
                  var l;
                  for (var d in s) {
                    var c = s[d],
                      u = a.getTask(c.id);
                    if (!u.unscheduled) {
                      var h = this._drag_task_coords(u, c),
                        _ = a.posFromDate(new Date(a.getState().min_date)),
                        f = a.posFromDate(new Date(a.getState().max_date));
                      if (h.end + o > f) {
                        var y = f - h.end;
                        (y < l || l === void 0) && (l = y);
                      } else if (h.start + o < _) {
                        var v = _ - h.start;
                        (v > l || l === void 0) && (l = v);
                      }
                    }
                  }
                  return l;
                },
                _move: function (s, o, l, d) {
                  var c = this._drag_task_coords(s, l),
                    u = null,
                    h = null;
                  d
                    ? ((u = new Date(+l.obj.start_date + d)),
                      (h = new Date(+l.obj.end_date + d)))
                    : ((u = a.dateFromPos(c.start + o)),
                      (h = a.dateFromPos(c.end + o))),
                    u
                      ? h
                        ? ((s.start_date = u), (s.end_date = h))
                        : ((s.end_date = new Date(a.getState().max_date)),
                          (s.start_date = a.dateFromPos(
                            a.posFromDate(s.end_date) - (c.end - c.start)
                          )))
                      : ((s.start_date = new Date(a.getState().min_date)),
                        (s.end_date = a.dateFromPos(
                          a.posFromDate(s.start_date) + (c.end - c.start)
                        )));
                },
                _drag_task_coords: function (s, o) {
                  return {
                    start: (o.obj_s_x =
                      o.obj_s_x || a.posFromDate(s.start_date)),
                    end: (o.obj_e_x = o.obj_e_x || a.posFromDate(s.end_date)),
                  };
                },
                _mouse_position_change: function (s, o) {
                  var l = s.x - o.x,
                    d = s.y - o.y;
                  return Math.sqrt(l * l + d * d);
                },
                _is_number: function (s) {
                  return !isNaN(parseFloat(s)) && isFinite(s);
                },
                on_mouse_move: function (s) {
                  if (this.drag.start_drag) {
                    var o = lt(s, a.$task_data),
                      l = this.drag.start_drag.start_x,
                      d = this.drag.start_drag.start_y;
                    (Date.now() - this.drag.timestamp > 50 ||
                      (this._is_number(l) &&
                        this._is_number(d) &&
                        this._mouse_position_change({ x: l, y: d }, o) > 20)) &&
                      this._start_dnd(s);
                  }
                  if (this.drag.mode) {
                    if (!Sn(this, 40)) return;
                    this._update_on_move(s);
                  }
                },
                _update_item_on_move: function (s, o, l, d, c, u) {
                  var h = a.getTask(o),
                    _ = a.mixin({}, h),
                    f = a.mixin({}, h);
                  this._handlers[l].apply(this, [f, s, d, u]),
                    a.mixin(h, f, !0),
                    a.callEvent("onTaskDrag", [h.id, l, f, _, c]),
                    a.mixin(h, f, !0),
                    a.refreshTask(o);
                },
                _update_on_move: function (s) {
                  var o = this.drag,
                    l = i.$getConfig();
                  if (o.mode) {
                    var d = lt(s, i.$task_data);
                    if (o.pos && o.pos.x == d.x) return;
                    o.pos = d;
                    var c = a.dateFromPos(d.x);
                    if (!c || isNaN(c.getTime())) return;
                    var u = d.x - o.start_x,
                      h = a.getTask(o.id);
                    if (this._handlers[o.mode]) {
                      if (o.mode === l.drag_mode.move) {
                        var _ = {};
                        this._isMultiselect() &&
                          a.getSelectedTasks().indexOf(o.id) >= 0 &&
                          (_ = this.dragMultiple);
                        var f = !1;
                        if (a.isSummaryTask(h) && a.config.drag_project) {
                          var y = {};
                          (y[o.id] = X(o)),
                            (f = !0),
                            (_ = O(y, this.dragMultiple));
                        }
                        var v = this._find_max_shift(_, u);
                        let m;
                        if (
                          (v !== void 0 && (u = v),
                          this._update_item_on_move(u, o.id, o.mode, o, s),
                          v === void 0)
                        ) {
                          const p = a.posFromDate(o.obj.start_date),
                            k = a.posFromDate(o.obj.end_date);
                          if (o.handle_offset === void 0) {
                            const x = k - p,
                              $ = o.start_x - p;
                            o.handle_offset = $ / x;
                          }
                          let w = p + Math.abs(k - p) * o.handle_offset;
                          m = c - a.dateFromPos(w);
                        }
                        for (var b in _) {
                          var g = _[b];
                          f && g.id != o.id && (a._bulk_dnd = !0),
                            this._update_item_on_move(u, g.id, g.mode, g, s, m);
                        }
                        a._bulk_dnd = !1;
                      } else this._update_item_on_move(u, o.id, o.mode, o, s);
                      a._update_parents(o.id);
                    }
                  }
                },
                on_mouse_down: function (s, o) {
                  if (s.button != 2 || s.button === void 0) {
                    var l = i.$getConfig(),
                      d = a.locate(s),
                      c = null;
                    if (
                      (a.isTaskExists(d) && (c = a.getTask(d)),
                      !a.isReadonly(c) && !this.drag.mode)
                    ) {
                      this.clear_drag_state();
                      var u = it((o = o || s.target || s.srcElement)),
                        h = this._get_drag_mode(u, o);
                      if (!u || !h)
                        return o.parentNode
                          ? this.on_mouse_down(s, o.parentNode)
                          : void 0;
                      if (h)
                        if (
                          h.mode &&
                          h.mode != l.drag_mode.ignore &&
                          l["drag_" + h.mode]
                        ) {
                          if (
                            ((d = a.locate(o)),
                            (c = a.copy(a.getTask(d) || {})),
                            a.isReadonly(c))
                          )
                            return this.clear_drag_state(), !1;
                          if (
                            a.isSummaryTask(c) &&
                            c.auto_scheduling !== !1 &&
                            !l.drag_project &&
                            h.mode != l.drag_mode.progress
                          )
                            return void this.clear_drag_state();
                          h.id = d;
                          var _ = lt(s, a.$task_data);
                          (h.start_x = _.x),
                            (h.start_y = _.y),
                            (h.obj = c),
                            (this.drag.start_drag = h),
                            (this.drag.timestamp = Date.now());
                        } else this.clear_drag_state();
                      else if (
                        a.checkEvent("onMouseDown") &&
                        a.callEvent("onMouseDown", [u.split(" ")[0]]) &&
                        o.parentNode
                      )
                        return this.on_mouse_down(s, o.parentNode);
                    }
                  }
                },
                _fix_dnd_scale_time: function (s, o) {
                  var l = i.$getConfig(),
                    d = a.getScale().unit,
                    c = a.getScale().step;
                  function u(h) {
                    if (a.config.correct_work_time) {
                      var _ = i.$getConfig();
                      a.isWorkTime(h.start_date, void 0, h) ||
                        (h.start_date = a.calculateEndDate({
                          start_date: h.start_date,
                          duration: -1,
                          unit: _.duration_unit,
                          task: h,
                        }));
                    }
                  }
                  l.round_dnd_dates || ((d = "minute"), (c = l.time_step)),
                    o.mode == l.drag_mode.resize
                      ? o.left
                        ? ((s.start_date = a.roundDate({
                            date: s.start_date,
                            unit: d,
                            step: c,
                          })),
                          u(s))
                        : ((s.end_date = a.roundDate({
                            date: s.end_date,
                            unit: d,
                            step: c,
                          })),
                          (function (h) {
                            if (a.config.correct_work_time) {
                              var _ = i.$getConfig();
                              a.isWorkTime(
                                new Date(h.end_date - 1),
                                void 0,
                                h
                              ) ||
                                (h.end_date = a.calculateEndDate({
                                  start_date: h.end_date,
                                  duration: 1,
                                  unit: _.duration_unit,
                                  task: h,
                                }));
                            }
                          })(s))
                      : o.mode == l.drag_mode.move &&
                        ((s.start_date = a.roundDate({
                          date: s.start_date,
                          unit: d,
                          step: c,
                        })),
                        u(s),
                        (s.end_date = a.calculateEndDate(s)));
                },
                _fix_working_times: function (s, o) {
                  var l = i.$getConfig();
                  (o = o || { mode: l.drag_mode.move }).mode ==
                  l.drag_mode.resize
                    ? o.left
                      ? (s.start_date = a.getClosestWorkTime({
                          date: s.start_date,
                          dir: "future",
                          task: s,
                        }))
                      : (s.end_date = a.getClosestWorkTime({
                          date: s.end_date,
                          dir: "past",
                          task: s,
                        }))
                    : o.mode == l.drag_mode.move && a.correctTaskWorkTime(s);
                },
                _finalize_mouse_up: function (s, o, l, d) {
                  var c = a.getTask(s);
                  if (
                    (o.work_time &&
                      o.correct_work_time &&
                      this._fix_working_times(c, l),
                    this._fix_dnd_scale_time(c, l),
                    this._fireEvent("before_finish", l.mode, [
                      s,
                      l.mode,
                      a.copy(l.obj),
                      d,
                    ]))
                  ) {
                    var u = s;
                    a._init_task_timing(c),
                      this.clear_drag_state(),
                      a.updateTask(c.id),
                      this._fireEvent("after_finish", l.mode, [u, l.mode, d]);
                  } else if (
                    (this.clear_drag_state(),
                    s == l.id &&
                      ((l.obj._dhx_changed = !1), a.mixin(c, l.obj, !0)),
                    a.refreshTask(c.id),
                    c.$level > 100)
                  ) {
                    let h = !1;
                    a.eachParent(function (_) {
                      if (!h && _.type === a.config.types.project) {
                        const f = {
                          start_date: _.start_date,
                          end_date: _.end_date,
                        };
                        a.resetProjectDates(_),
                          (+f.start_date == +_.start_date &&
                            +f.end_date == +_.end_date) ||
                            (h = !0);
                      }
                    }, c.id),
                      h && a.refreshData();
                  } else
                    a.eachParent(function (h) {
                      if (h.type === a.config.types.project) {
                        const _ = {
                          start_date: h.start_date,
                          end_date: h.end_date,
                        };
                        a.resetProjectDates(h),
                          (+_.start_date == +h.start_date &&
                            +_.end_date == +h.end_date) ||
                            a.refreshTask(h.id);
                      }
                    }, c.id);
                },
                on_mouse_up: function (s) {
                  var o = this.drag;
                  if (o.mode && o.id) {
                    var l = i.$getConfig(),
                      d = a.getTask(o.id),
                      c = this.dragMultiple,
                      u = !1,
                      h = 0;
                    o.mode === l.drag_mode.move &&
                      ((a.isSummaryTask(d) && l.drag_project) ||
                        this._isMultiselect()) &&
                      ((u = !0), (h = Object.keys(c).length));
                    var _ = function () {
                      if (u)
                        for (var f in c)
                          c[f].id != o.id &&
                            this._finalize_mouse_up(c[f].id, l, c[f], s);
                      this._finalize_mouse_up(o.id, l, o, s);
                    };
                    u && h > 10
                      ? a.batchUpdate(
                          function () {
                            _.call(this);
                          }.bind(this)
                        )
                      : _.call(this);
                  }
                  this.clear_drag_state();
                },
                _get_drag_mode: function (s, o) {
                  var l = i.$getConfig().drag_mode,
                    d = { mode: null, left: null };
                  switch ((s || "").split(" ")[0]) {
                    case "gantt_task_line":
                    case "gantt_task_content":
                      d.mode = l.move;
                      break;
                    case "gantt_task_drag":
                      d.mode = l.resize;
                      var c = o.getAttribute("data-bind-property");
                      d.left = c == "start_date";
                      break;
                    case "gantt_task_progress_drag":
                      d.mode = l.progress;
                      break;
                    case "gantt_link_control":
                    case "gantt_link_point":
                      d.mode = l.ignore;
                      break;
                    default:
                      d = null;
                  }
                  return d;
                },
                _start_dnd: function (s) {
                  var o = (this.drag = this.drag.start_drag);
                  delete o.start_drag;
                  var l = i.$getConfig(),
                    d = o.id;
                  if (
                    l["drag_" + o.mode] &&
                    a.callEvent("onBeforeDrag", [d, o.mode, s]) &&
                    this._fireEvent("before_start", o.mode, [d, o.mode, s])
                  ) {
                    delete o.start_drag;
                    var c = a.getTask(d);
                    if (a.isReadonly(c)) return void this.clear_drag_state();
                    if (this._isMultiselect()) {
                      var u = a.getSelectedTasks();
                      u.indexOf(o.id) >= 0 &&
                        st(
                          u,
                          a.bind(function (h) {
                            var _ = a.getTask(h);
                            a.isSummaryTask(_) &&
                              a.config.drag_project &&
                              o.mode == l.drag_mode.move &&
                              this._addSubtasksToDragMultiple(_.id),
                              (this.dragMultiple[h] = a.mixin(
                                { id: _.id, obj: a.copy(_) },
                                this.drag
                              ));
                          }, this)
                        );
                    }
                    a.isSummaryTask(c) &&
                      a.config.drag_project &&
                      o.mode == l.drag_mode.move &&
                      this._addSubtasksToDragMultiple(c.id),
                      a.callEvent("onTaskDragStart", []);
                  } else this.clear_drag_state();
                },
                _fireEvent: function (s, o, l) {
                  a.assert(this._events[s], "Invalid stage:{" + s + "}");
                  var d = this._events[s][o];
                  return (
                    a.assert(d, "Unknown after drop mode:{" + o + "}"),
                    a.assert(l, "Invalid event arguments"),
                    !a.checkEvent(d) || a.callEvent(d, l)
                  );
                },
                round_task_dates: function (s) {
                  var o = this.drag,
                    l = i.$getConfig();
                  o || (o = { mode: l.drag_mode.move }),
                    this._fix_dnd_scale_time(s, o);
                },
                destructor: function () {
                  this._domEvents.detachAll();
                },
                _isMultiselect: function () {
                  return (
                    a.config.drag_multiple &&
                    !!(a.getSelectedTasks && a.getSelectedTasks().length > 0)
                  );
                },
                _addSubtasksToDragMultiple: function (s) {
                  a.eachTask(
                    function (o) {
                      this.dragMultiple[o.id] = a.mixin(
                        { id: o.id, obj: a.copy(o) },
                        this.drag
                      );
                    },
                    s,
                    this
                  );
                },
              };
            })(n, e)),
            (n._tasks_dnd = t),
            t.init(e)
          );
        },
        destructor: function () {
          t && (t.destructor(), (t = null));
        },
      };
    },
  };
  var Er = function (t, n) {
    var e, i, a, r, s;
    function o() {
      return {
        link_source_id: r,
        link_target_id: i,
        link_from_start: s,
        link_to_start: a,
        link_landing_area: e,
      };
    }
    var l = n.$services,
      d = l.getService("state"),
      c = l.getService("dnd");
    d.registerProvider("linksDnD", o);
    var u = "gantt_link_point",
      h = "gantt_link_control",
      _ = new c(t.$task_bars, {
        sensitivity: 0,
        updates_per_second: 60,
        mousemoveContainer: n.$root,
        selector: "." + u,
        preventDefault: !0,
      });
    function f(m, p) {
      var k,
        w = _.getPosition(m),
        x = (function (A) {
          var I = 0,
            M = 0;
          return (
            A && ((I = A.offsetWidth || 0), (M = A.offsetHeight || 0)),
            { width: I, height: M }
          );
        })(p),
        $ = { right: (k = n.$root).offsetWidth, bottom: k.offsetHeight },
        S = n.config.tooltip_offset_x || 10,
        T = n.config.tooltip_offset_y || 10,
        E = n.config.scroll_size || 18,
        C = n.$container.getBoundingClientRect().y + window.scrollY,
        D = {
          y: w.y + T,
          x: w.x + S,
          bottom: w.y + x.height + T + E,
          right: w.x + x.width + S + E,
        };
      return (
        D.bottom > $.bottom + C && (D.y = $.bottom + C - x.height - T),
        D.right > $.right && (D.x = $.right - x.width - S),
        D
      );
    }
    function y(m) {
      var p = o();
      p.link_source_id &&
        p.link_target_id &&
        n.isLinkAllowed(
          p.link_source_id,
          p.link_target_id,
          p.link_from_start,
          p.link_to_start
        );
      var k =
        "<div class='" +
        n.templates.drag_link_class(
          p.link_source_id,
          p.link_from_start,
          p.link_target_id,
          p.link_to_start
        ) +
        "'>" +
        n.templates.drag_link(
          p.link_source_id,
          p.link_from_start,
          p.link_target_id,
          p.link_to_start
        ) +
        "</div>";
      m.innerHTML = k;
    }
    function v() {
      (r = s = i = null), (a = !0);
    }
    function b(m, p, k, w) {
      var x = (function () {
          return (
            (_._direction && _._direction.parentNode) ||
              ((_._direction = document.createElement("div")),
              t.$task_links.appendChild(_._direction)),
            _._direction
          );
        })(),
        $ = o(),
        S = ["gantt_link_direction"];
      n.templates.link_direction_class &&
        S.push(
          n.templates.link_direction_class(
            $.link_source_id,
            $.link_from_start,
            $.link_target_id,
            $.link_to_start
          )
        );
      var T = Math.sqrt(Math.pow(k - m, 2) + Math.pow(w - p, 2));
      if ((T = Math.max(0, T - 3))) {
        x.className = S.join(" ");
        var E = (w - p) / (k - m),
          C = Math.atan(E);
        g(m, k, p, w) == 2
          ? (C += Math.PI)
          : g(m, k, p, w) == 3 && (C -= Math.PI);
        var D = Math.sin(C),
          A = Math.cos(C),
          I = Math.round(p),
          M = Math.round(m),
          L = [
            "-webkit-transform: rotate(" + C + "rad)",
            "-moz-transform: rotate(" + C + "rad)",
            "-ms-transform: rotate(" + C + "rad)",
            "-o-transform: rotate(" + C + "rad)",
            "transform: rotate(" + C + "rad)",
            "width:" + Math.round(T) + "px",
          ];
        if (window.navigator.userAgent.indexOf("MSIE 8.0") != -1) {
          L.push(
            '-ms-filter: "' +
              (function (R, B) {
                return (
                  "progid:DXImageTransform.Microsoft.Matrix(M11 = " +
                  B +
                  ",M12 = -" +
                  R +
                  ",M21 = " +
                  R +
                  ",M22 = " +
                  B +
                  ",SizingMethod = 'auto expand')"
                );
              })(D, A) +
              '"'
          );
          var N = Math.abs(Math.round(m - k)),
            P = Math.abs(Math.round(w - p));
          switch (g(m, k, p, w)) {
            case 1:
              I -= P;
              break;
            case 2:
              (M -= N), (I -= P);
              break;
            case 3:
              M -= N;
          }
        }
        L.push("top:" + I + "px"),
          L.push("left:" + M + "px"),
          (x.style.cssText = L.join(";"));
      }
    }
    function g(m, p, k, w) {
      return p >= m ? (w <= k ? 1 : 4) : w <= k ? 2 : 3;
    }
    _.attachEvent(
      "onBeforeDragStart",
      n.bind(function (m, p) {
        var k = p.target || p.srcElement;
        if ((v(), n.getState("tasksDnd").drag_id)) return !1;
        if (mt(k, u)) {
          mt(k, "task_start_date") && (s = !0);
          var w = n.locate(p);
          r = w;
          var x = n.getTask(w);
          return n.isReadonly(x)
            ? (v(), !1)
            : ((this._dir_start = {
                x:
                  _.config.original_element_sizes.x +
                  _.config.original_element_sizes.width / 2,
                y:
                  _.config.original_element_sizes.y +
                  _.config.original_element_sizes.height / 2,
              }),
              !0);
        }
        return !1;
      }, this)
    ),
      _.attachEvent(
        "onAfterDragStart",
        n.bind(function (m, p) {
          n.config.touch && n.refreshData(), y(_.config.marker);
        }, this)
      ),
      _.attachEvent(
        "onDragMove",
        n.bind(function (m, p) {
          var k = _.config,
            w = f(p, k.marker);
          (function (A, I) {
            (A.style.left = I.x + "px"), (A.style.top = I.y + "px");
          })(k.marker, w);
          var x = !!mt(p, h),
            $ = i,
            S = e,
            T = a,
            E = n.locate(p),
            C = !0;
          if (
            (tt(Et(p), n.$root) || ((x = !1), (E = null)),
            x && ((C = !mt(p, "task_end_date")), (x = !!E)),
            (i = E),
            (e = x),
            (a = C),
            x)
          ) {
            const A = mt(p, h).querySelector(`.${u}`);
            if (A) {
              const I = un(A, t.$task_bg);
              this._dir_end = {
                x: I.x + A.offsetWidth / 2,
                y: I.y + A.offsetHeight / 2,
              };
            }
          } else (this._dir_end = lt(p, t.$task_data)), n.env.isEdge && (this._dir_end.y += window.scrollY);
          var D = !(S == x && $ == E && T == C);
          return (
            D && ($ && n.refreshTask($, !1), E && n.refreshTask(E, !1)),
            D && y(k.marker),
            b(
              this._dir_start.x,
              this._dir_start.y,
              this._dir_end.x,
              this._dir_end.y
            ),
            !0
          );
        }, this)
      ),
      _.attachEvent(
        "onDragEnd",
        n.bind(function () {
          var m = o();
          if (
            m.link_source_id &&
            m.link_target_id &&
            m.link_source_id != m.link_target_id
          ) {
            var p = n._get_link_type(m.link_from_start, m.link_to_start),
              k = {
                source: m.link_source_id,
                target: m.link_target_id,
                type: p,
              };
            k.type &&
              n.isLinkAllowed(k) &&
              n.callEvent("onLinkCreated", [k]) &&
              n.addLink(k);
          }
          v(),
            n.config.touch
              ? n.refreshData()
              : (m.link_source_id && n.refreshTask(m.link_source_id, !1),
                m.link_target_id && n.refreshTask(m.link_target_id, !1)),
            _._direction &&
              (_._direction.parentNode &&
                _._direction.parentNode.removeChild(_._direction),
              (_._direction = null));
        }, this)
      ),
      n.attachEvent(
        "onGanttRender",
        n.bind(function () {
          _._direction &&
            b(
              this._dir_start.x,
              this._dir_start.y,
              this._dir_end.x,
              this._dir_end.y
            );
        }, this)
      );
  };
  const Cr = function () {
    return { init: Er };
  };
  var Dr = function (t) {
      var n = t.$services;
      return {
        onCreated: function (e) {
          var i = e.$config;
          (i.bind = U(i.bind) ? i.bind : "task"),
            (i.bindLinks = U(i.bindLinks) ? i.bindLinks : "link"),
            (e._linksDnD = Cr()),
            (e._tasksDnD = Tr.createTaskDND()),
            e._tasksDnD.extend(e),
            (this._mouseDelegates = Pe(t));
        },
        onInitialized: function (e) {
          this._attachDomEvents(t),
            this._attachStateProvider(t, e),
            e._tasksDnD.init(e, t),
            e._linksDnD.init(e, t),
            e.$config.id == "timeline" && this.extendDom(e);
        },
        onDestroyed: function (e) {
          this._clearDomEvents(t),
            this._clearStateProvider(t),
            e._tasksDnD && e._tasksDnD.destructor();
        },
        extendDom: function (e) {
          (t.$task = e.$task),
            (t.$task_scale = e.$task_scale),
            (t.$task_data = e.$task_data),
            (t.$task_bg = e.$task_bg),
            (t.$task_links = e.$task_links),
            (t.$task_bars = e.$task_bars);
        },
        _clearDomEvents: function () {
          this._mouseDelegates.destructor(), (this._mouseDelegates = null);
        },
        _attachDomEvents: function (e) {
          function i(a, r) {
            if (a && this.callEvent("onLinkDblClick", [a, r])) {
              var s = this.getLink(a);
              if (this.isReadonly(s)) return;
              var o =
                this.locale.labels.link +
                " " +
                this.templates.link_description(this.getLink(a)) +
                " " +
                this.locale.labels.confirm_link_deleting;
              window.setTimeout(
                function () {
                  e._delete_link_confirm({
                    link: s,
                    message: o,
                    title: "",
                    callback: function () {
                      e.deleteLink(a);
                    },
                  });
                },
                this.config.touch ? 300 : 1
              );
            }
          }
          this._mouseDelegates.delegate(
            "click",
            "gantt_task_link",
            e.bind(function (a, r) {
              var s = this.locate(a, this.config.link_attribute);
              s && this.callEvent("onLinkClick", [s, a]);
            }, e),
            this.$task
          ),
            this._mouseDelegates.delegate(
              "click",
              "gantt_scale_cell",
              e.bind(function (a, r) {
                var s = lt(a, e.$task_data),
                  o = e.dateFromPos(s.x),
                  l = Math.floor(e.columnIndexByDate(o)),
                  d = e.getScale().trace_x[l];
                e.callEvent("onScaleClick", [a, d]);
              }, e),
              this.$task
            ),
            this._mouseDelegates.delegate(
              "doubleclick",
              "gantt_task_link",
              e.bind(function (a, r, s) {
                (r = this.locate(a, e.config.link_attribute)),
                  i.call(this, r, a);
              }, e),
              this.$task
            ),
            this._mouseDelegates.delegate(
              "doubleclick",
              "gantt_link_point",
              e.bind(function (a, r, s) {
                r = this.locate(a);
                var o = this.getTask(r),
                  l = null;
                return (
                  s.parentNode &&
                    it(s.parentNode) &&
                    (l =
                      it(s.parentNode).indexOf("_left") > -1
                        ? o.$target[0]
                        : o.$source[0]),
                  l && i.call(this, l, a),
                  !1
                );
              }, e),
              this.$task
            );
        },
        _attachStateProvider: function (e, i) {
          var a = i;
          n.getService("state").registerProvider("tasksTimeline", function () {
            return {
              scale_unit: a._tasks ? a._tasks.unit : void 0,
              scale_step: a._tasks ? a._tasks.step : void 0,
            };
          });
        },
        _clearStateProvider: function () {
          n.getService("state").unregisterProvider("tasksTimeline");
        },
      };
    },
    Ar = function (t) {
      return {
        getVerticalScrollbar: function () {
          return t.$ui.getView("scrollVer");
        },
        getHorizontalScrollbar: function () {
          return t.$ui.getView("scrollHor");
        },
        _legacyGridResizerClass: function (n) {
          for (var e = n.getCellsByType("resizer"), i = 0; i < e.length; i++) {
            var a = e[i],
              r = !1,
              s = a.$parent.getPrevSibling(a.$id);
            if (s && s.$config && s.$config.id === "grid") r = !0;
            else {
              var o = a.$parent.getNextSibling(a.$id);
              o && o.$config && o.$config.id === "grid" && (r = !0);
            }
            r &&
              (a.$config.css =
                (a.$config.css ? a.$config.css + " " : "") +
                "gantt_grid_resize_wrap");
          }
        },
        onCreated: function (n) {
          var e = !0;
          this._legacyGridResizerClass(n),
            n.attachEvent("onBeforeResize", function () {
              var i = t.$ui.getView("timeline");
              i &&
                (i.$config.hidden = i.$parent.$config.hidden =
                  !t.config.show_chart);
              var a = t.$ui.getView("grid");
              if (a) {
                var r = a._getColsTotalWidth(),
                  s = !t.config.show_grid || !t.config.grid_width || r === 0;
                if (
                  (e && !s && r !== !1 && (t.config.grid_width = r),
                  (a.$config.hidden = a.$parent.$config.hidden = s),
                  !a.$config.hidden)
                ) {
                  var o = a._getGridWidthLimits();
                  if (
                    (o[0] &&
                      t.config.grid_width < o[0] &&
                      (t.config.grid_width = o[0]),
                    o[1] &&
                      t.config.grid_width > o[1] &&
                      (t.config.grid_width = o[1]),
                    i && t.config.show_chart)
                  ) {
                    if (
                      ((a.$config.width = t.config.grid_width - 1),
                      !a.$config.scrollable &&
                        a.$config.scrollY &&
                        t.$root.offsetWidth)
                    ) {
                      var l = a.$gantt.$layout.$container.offsetWidth,
                        d = t.$ui.getView(a.$config.scrollY).$config.width,
                        c = l - (a.$config.width + d) - 4;
                      c < 0 &&
                        ((a.$config.width += c), (t.config.grid_width += c));
                    }
                    if (e)
                      (a.$parent.$config.width = t.config.grid_width),
                        a.$parent.$config.group &&
                          t.$layout._syncCellSizes(a.$parent.$config.group, {
                            value: a.$parent.$config.width,
                            isGravity: !1,
                          });
                    else if (i && !tt(i.$task, n.$view)) {
                      if (!a.$config.original_grid_width) {
                        var u = t.skins[t.skin];
                        u && u.config && u.config.grid_width
                          ? (a.$config.original_grid_width =
                              u.config.grid_width)
                          : (a.$config.original_grid_width = 0);
                      }
                      (t.config.grid_width = a.$config.original_grid_width),
                        (a.$parent.$config.width = t.config.grid_width);
                    } else
                      a.$parent._setContentSize(a.$config.width, null),
                        t.$layout._syncCellSizes(a.$parent.$config.group, {
                          value: t.config.grid_width,
                          isGravity: !1,
                        });
                  } else
                    i &&
                      tt(i.$task, n.$view) &&
                      (a.$config.original_grid_width = t.config.grid_width),
                      e || (a.$parent.$config.width = 0);
                }
                e = !1;
              }
            }),
            this._initScrollStateEvents(n);
        },
        _initScrollStateEvents: function (n) {
          (t._getVerticalScrollbar = this.getVerticalScrollbar),
            (t._getHorizontalScrollbar = this.getHorizontalScrollbar);
          var e = this.getVerticalScrollbar(),
            i = this.getHorizontalScrollbar();
          e &&
            e.attachEvent("onScroll", function (a, r, s) {
              var o = t.getScrollState();
              t.callEvent("onGanttScroll", [o.x, a, o.x, r]);
            }),
            i &&
              i.attachEvent("onScroll", function (a, r, s) {
                var o = t.getScrollState();
                t.callEvent("onGanttScroll", [a, o.y, r, o.y]);
                var l = t.$ui.getView("grid");
                l &&
                  l.$grid_data &&
                  !l.$config.scrollable &&
                  ((l.$grid_data.style.left = l.$grid.scrollLeft + "px"),
                  (l.$grid_data.scrollLeft = l.$grid.scrollLeft));
              }),
            n.attachEvent("onResize", function () {
              e && !t.$scroll_ver && (t.$scroll_ver = e.$scroll_ver),
                i && !t.$scroll_hor && (t.$scroll_hor = i.$scroll_hor);
            });
        },
        _findGridResizer: function (n, e) {
          for (
            var i, a = n.getCellsByType("resizer"), r = !0, s = 0;
            s < a.length;
            s++
          ) {
            var o = a[s];
            o._getSiblings();
            var l = o._behind,
              d = o._front;
            if ((l && l.$content === e) || (l.isChild && l.isChild(e))) {
              (i = o), (r = !0);
              break;
            }
            if ((d && d.$content === e) || (d.isChild && d.isChild(e))) {
              (i = o), (r = !1);
              break;
            }
          }
          return { resizer: i, gridFirst: r };
        },
        onInitialized: function (n) {
          var e = t.$ui.getView("grid"),
            i = this._findGridResizer(n, e);
          if (i.resizer) {
            var a,
              r = i.gridFirst,
              s = i.resizer;
            if (s.$config.mode !== "x") return;
            s.attachEvent("onResizeStart", function (o, l) {
              var d = t.$ui.getView("grid"),
                c = d ? d.$parent : null;
              if (c) {
                var u = d._getGridWidthLimits();
                d.$config.scrollable || (c.$config.minWidth = u[0]),
                  (c.$config.maxWidth = u[1]);
              }
              return (a = r ? o : l), t.callEvent("onGridResizeStart", [a]);
            }),
              s.attachEvent("onResize", function (o, l) {
                var d = r ? o : l;
                return t.callEvent("onGridResize", [a, d]);
              }),
              s.attachEvent("onResizeEnd", function (o, l, d, c) {
                var u = r ? o : l,
                  h = r ? d : c,
                  _ = t.$ui.getView("grid"),
                  f = _ ? _.$parent : null;
                f && (f.$config.minWidth = void 0);
                var y = t.callEvent("onGridResizeEnd", [u, h]);
                return y && h !== 0 && (t.config.grid_width = h), y;
              });
          }
        },
        onDestroyed: function (n) {},
      };
    };
  const Mr = {
    init: function (t) {
      function n(r, s) {
        var o = s(t);
        o.onCreated && o.onCreated(r),
          r.attachEvent("onReady", function () {
            o.onInitialized && o.onInitialized(r);
          }),
          r.attachEvent("onDestroy", function () {
            o.onDestroyed && o.onDestroyed(r);
          });
      }
      var e = za(t);
      e.registerView("cell", xt),
        e.registerView("resizer", qa),
        e.registerView("scrollbar", Ya),
        e.registerView("layout", Yn, function (r) {
          (r.$config ? r.$config.id : null) === "main" && n(r, Ar);
        }),
        e.registerView("viewcell", Ga),
        e.registerView("multiview", Ua),
        e.registerView("timeline", je, function (r) {
          ((r.$config ? r.$config.id : null) !== "timeline" &&
            r.$config.bind != "task") ||
            n(r, Dr);
        }),
        e.registerView("grid", ne, function (r) {
          ((r.$config ? r.$config.id : null) !== "grid" &&
            r.$config.bind != "task") ||
            n(r, Sr);
        }),
        e.registerView("resourceGrid", Xa),
        e.registerView("resourceTimeline", Jn),
        e.registerView("resourceHistogram", Za);
      var i = (function (r) {
          var s = Wa(r);
          return {
            getDataRender: function (o) {
              return r.$services.getService("layer:" + o) || null;
            },
            createDataRender: function (o) {
              var l = o.name,
                d = o.defaultContainer,
                c = o.defaultContainerSibling,
                u = s.createGroup(
                  d,
                  c,
                  function (h, _) {
                    if (!u.filters) return !0;
                    for (var f = 0; f < u.filters.length; f++)
                      if (u.filters[f](h, _) === !1) return !1;
                  },
                  Va
                );
              return (
                r.$services.setService("layer:" + l, function () {
                  return u;
                }),
                r.attachEvent("onGanttReady", function () {
                  u.addLayer();
                }),
                u
              );
            },
            init: function () {
              var o = this.createDataRender(
                  {
                    name: "task",
                    defaultContainer: function () {
                      return r.$task_data
                        ? r.$task_data
                        : r.$ui.getView("timeline")
                        ? r.$ui.getView("timeline").$task_data
                        : void 0;
                    },
                    defaultContainerSibling: function () {
                      return r.$task_links
                        ? r.$task_links
                        : r.$ui.getView("timeline")
                        ? r.$ui.getView("timeline").$task_links
                        : void 0;
                    },
                    filter: function (d) {},
                  },
                  r
                ),
                l = this.createDataRender(
                  {
                    name: "link",
                    defaultContainer: function () {
                      return r.$task_data
                        ? r.$task_data
                        : r.$ui.getView("timeline")
                        ? r.$ui.getView("timeline").$task_data
                        : void 0;
                    },
                  },
                  r
                );
              return {
                addTaskLayer: function (d) {
                  const c = et;
                  return (
                    typeof d == "function"
                      ? (d = { renderer: { render: d, getVisibleRange: c } })
                      : d.renderer &&
                        !d.renderer.getVisibleRange &&
                        (d.renderer.getVisibleRange = c),
                    (d.view = "timeline"),
                    o.addLayer(d)
                  );
                },
                _getTaskLayers: function () {
                  return o.getLayers();
                },
                removeTaskLayer: function (d) {
                  o.removeLayer(d);
                },
                _clearTaskLayers: function () {
                  o.clear();
                },
                addLinkLayer: function (d) {
                  const c = Gn();
                  return (
                    typeof d == "function"
                      ? (d = { renderer: { render: d, getVisibleRange: c } })
                      : d.renderer &&
                        !d.renderer.getVisibleRange &&
                        (d.renderer.getVisibleRange = c),
                    (d.view = "timeline"),
                    d &&
                      d.renderer &&
                      (d.renderer.getRectangle ||
                        d.renderer.isInViewPort ||
                        (d.renderer.isInViewPort = qn)),
                    l.addLayer(d)
                  );
                },
                _getLinkLayers: function () {
                  return l.getLayers();
                },
                removeLinkLayer: function (d) {
                  l.removeLayer(d);
                },
                _clearLinkLayers: function () {
                  l.clear();
                },
              };
            },
          };
        })(t),
        a = dr(t);
      return (
        (t.ext.inlineEditors = a),
        (t.ext._inlineEditors = a),
        a.init(t),
        {
          factory: e,
          mouseEvents: Fa.init(t),
          layersApi: i.init(),
          render: {
            gridLine: function () {
              return (function (r) {
                return {
                  render: function (s, o, l, d) {
                    for (
                      var c = o.getGridColumns(),
                        u = o.$getTemplates(),
                        h = o.$config.rowStore,
                        _ = [],
                        f = 0;
                      f < c.length;
                      f++
                    ) {
                      var y,
                        v,
                        b,
                        g = f == c.length - 1,
                        m = c[f];
                      m.name == "add"
                        ? ((v =
                            "<div " +
                            (S = r._waiAria.gridAddButtonAttrString(m)) +
                            " class='gantt_add'></div>"),
                          (b = ""))
                        : (nt((v = m.template ? m.template(s) : s[m.name])) &&
                            (v = u.date_grid(v, s, m.name)),
                          v == null && (v = ""),
                          (b = v),
                          (v =
                            "<div class='gantt_tree_content'>" + v + "</div>"));
                      var p = "gantt_cell" + (g ? " gantt_last_cell" : ""),
                        k = [];
                      if (m.tree) {
                        p += " gantt_cell_tree";
                        for (var w = 0; w < s.$level; w++)
                          k.push(u.grid_indent(s));
                        !h.hasChild(s.id) ||
                        (r.isSplitTask(s) && !r.config.open_split_tasks)
                          ? (k.push(u.grid_blank(s)), k.push(u.grid_file(s)))
                          : (k.push(u.grid_open(s)), k.push(u.grid_folder(s)));
                      }
                      var x = "width:" + (m.width - (g ? 1 : 0)) + "px;";
                      if (this.defined(m.align)) {
                        var $ = {
                          right: "flex-end",
                          left: "flex-start",
                          center: "center",
                        }[m.align];
                        x +=
                          "text-align:" +
                          m.align +
                          ";justify-content:" +
                          $ +
                          ";";
                      }
                      var S = r._waiAria.gridCellAttrString(m, b, s);
                      k.push(v),
                        (y =
                          "<div class='" +
                          p +
                          "' data-column-index='" +
                          f +
                          "' data-column-name='" +
                          m.name +
                          "' style='" +
                          x +
                          "' " +
                          S +
                          ">" +
                          k.join("") +
                          "</div>"),
                        _.push(y);
                    }
                    switch (((p = ""), h.$config.name)) {
                      case "task":
                        p = r.getGlobalTaskIndex(s.id) % 2 == 0 ? "" : " odd";
                        break;
                      case "resource":
                        p = h.visibleOrder.indexOf(s.id) % 2 == 0 ? "" : " odd";
                    }
                    if (
                      ((p += s.$transparent ? " gantt_transparent" : ""),
                      (p += s.$dataprocessor_class
                        ? " " + s.$dataprocessor_class
                        : ""),
                      u.grid_row_class)
                    ) {
                      var T = u.grid_row_class.call(
                        r,
                        s.start_date,
                        s.end_date,
                        s
                      );
                      T && (p += " " + T);
                    }
                    h.isSelected(s.id) && (p += " gantt_selected");
                    var E = document.createElement("div");
                    E.className =
                      "gantt_row" + p + " gantt_row_" + r.getTaskType(s.type);
                    var C = o.getItemHeight(s.id);
                    return (
                      (E.style.height = C + "px"),
                      (E.style.lineHeight = C + "px"),
                      l.smart_rendering &&
                        ((E.style.position = "absolute"),
                        (E.style.left = "0px"),
                        (E.style.top = o.getItemTop(s.id) + "px")),
                      o.$config.item_attribute &&
                        (E.setAttribute(o.$config.item_attribute, s.id),
                        E.setAttribute(o.$config.bind + "_id", s.id)),
                      r._waiAria.taskRowAttr(s, E),
                      (E.innerHTML = _.join("")),
                      E
                    );
                  },
                  update: null,
                  getRectangle: ae,
                  isInViewPort: fr,
                  getVisibleRange: et,
                  onrender: function (s, o, l) {
                    for (var d = l.getGridColumns(), c = 0; c < d.length; c++) {
                      var u = d[c];
                      if (u.onrender) {
                        var h = o.querySelector(
                          `[data-column-name="${u.name}"]`
                        );
                        if (h) {
                          var _ = u.onrender(s, h);
                          if (_ && typeof _ == "string") h.innerHTML = _;
                          else if (
                            _ &&
                            typeof _ == "object" &&
                            r.config.external_render
                          ) {
                            var f = r.config.external_render;
                            f.isElement(_) && f.renderElement(_, h);
                          }
                        }
                      }
                    }
                  },
                };
              })(t);
            },
            taskBg: function () {
              return (function (r) {
                var s = {},
                  o = {};
                function l(_, f) {
                  return !(!s[_.id][f] || !s[_.id][f].parentNode);
                }
                function d(_, f) {
                  s[_] &&
                    s[_][f] &&
                    s[_][f].parentNode &&
                    s[_][f].parentNode.removeChild(s[_][f]);
                }
                function c(_) {
                  var f,
                    y = _.$getTemplates();
                  return (
                    y.task_cell_class !== void 0
                      ? ((f = y.task_cell_class),
                        (console.warn || console.log)(
                          "gantt.templates.task_cell_class template is deprecated and will be removed soon. Please use gantt.templates.timeline_cell_class instead."
                        ))
                      : (f = y.timeline_cell_class),
                    f
                  );
                }
                function u(_) {
                  return _.$getTemplates().timeline_cell_content;
                }
                function h(_, f, y, v, b, g, m, p) {
                  var k = _.width[f],
                    w = "";
                  if (Ut(f, _, v, r)) {
                    var x = g(y, _.trace_x[f]),
                      $ = "";
                    if ((m && ($ = m(y, _.trace_x[f])), p.static_background)) {
                      var S = !(!x && !$);
                      if (!p.static_background_cells || !S) return null;
                    }
                    if (s[y.id][f]) return (o[y.id][f] = f), s[y.id][f];
                    var T = document.createElement("div");
                    return (
                      (T.style.width = k + "px"),
                      (w =
                        "gantt_task_cell" +
                        (f == b - 1 ? " gantt_last_cell" : "")),
                      x && (w += " " + x),
                      (T.className = w),
                      $ && (T.innerHTML = $),
                      (T.style.position = "absolute"),
                      (T.style.left = _.left[f] + "px"),
                      (s[y.id][f] = T),
                      (o[y.id][f] = f),
                      T
                    );
                  }
                  return null;
                }
                return {
                  render: function (_, f, y, v) {
                    var b = f.$getTemplates(),
                      g = f.getScale(),
                      m = g.count;
                    if (y.static_background && !y.static_background_cells)
                      return null;
                    var p,
                      k = document.createElement("div"),
                      w = c(f),
                      x = u(f);
                    if (
                      ((p =
                        v && y.smart_rendering && !Vt(r)
                          ? Dt(g, v.x)
                          : { start: 0, end: m - 1 }),
                      y.show_task_cells)
                    ) {
                      (s[_.id] = {}), (o[_.id] = {});
                      for (var $ = p.start; $ <= p.end; $++) {
                        var S = h(g, $, _, v, m, w, x, y);
                        S && k.appendChild(S);
                      }
                    }
                    const T = f.$config.rowStore,
                      E = T.getIndexById(_.id) % 2 != 0;
                    var C = b.task_row_class(_.start_date, _.end_date, _),
                      D =
                        "gantt_task_row" +
                        (E ? " odd" : "") +
                        (C ? " " + C : "");
                    if (
                      (T.isSelected(_.id) && (D += " gantt_selected"),
                      (k.className = D),
                      y.smart_rendering
                        ? ((k.style.position = "absolute"),
                          (k.style.top = f.getItemTop(_.id) + "px"),
                          (k.style.width = "100%"))
                        : (k.style.position = "relative"),
                      (k.style.height = f.getItemHeight(_.id) + "px"),
                      _.id == "timeline_placeholder_task")
                    ) {
                      var A = 0;
                      _.lastTaskId &&
                        (A =
                          f.getItemTop(_.lastTaskId) +
                          f.getItemHeight(_.lastTaskId));
                      var I = (_.row_height || f.$task_data.offsetHeight) - A;
                      I < 0 && (I = 0),
                        y.smart_rendering && (k.style.top = A + "px"),
                        (k.style.height = I + "px");
                    }
                    return (
                      f.$config.item_attribute &&
                        (k.setAttribute(f.$config.item_attribute, _.id),
                        k.setAttribute(f.$config.bind + "_id", _.id)),
                      k
                    );
                  },
                  update: function (_, f, y, v, b) {
                    var g = y.getScale(),
                      m = g.count,
                      p = c(y),
                      k = u(y);
                    if (v.show_task_cells) {
                      s[_.id] || (s[_.id] = {}), o[_.id] || (o[_.id] = {});
                      var w = Dt(g, b);
                      for (var x in o[_.id]) {
                        var $ = o[_.id][x];
                        (Number($) < w.start || Number($) > w.end) &&
                          d(_.id, $);
                      }
                      o[_.id] = {};
                      for (var S = w.start; S <= w.end; S++) {
                        var T = h(g, S, _, b, m, p, k, v);
                        !T && l(_, S)
                          ? d(_.id, S)
                          : T && !T.parentNode && f.appendChild(T);
                      }
                    }
                  },
                  getRectangle: Ue,
                  getVisibleRange: et,
                  prepareData: _r,
                };
              })(t);
            },
            taskBar: function () {
              return (function (r) {
                return {
                  render: Ve(r),
                  update: null,
                  isInViewPort: Ot,
                  getVisibleRange: et,
                };
              })(t);
            },
            timedProjectBar: function () {
              return (function (r) {
                return {
                  render: ur(r),
                  update: null,
                  isInViewPort: cr,
                  getVisibleRange: et,
                };
              })(t);
            },
            taskRollupBar: function () {
              return (function (r) {
                const s = Ve(r),
                  o = {};
                function l(u, h, _, f, y) {
                  let v = !0;
                  return f.smart_rendering && (v = Ot(u, h, _)), v;
                }
                function d(u, h, _, f) {
                  const y = r.copy(r.getTask(h.id));
                  if (
                    ((y.$rendered_at = u.id),
                    r.callEvent("onBeforeRollupTaskDisplay", [
                      y.id,
                      y,
                      u.id,
                    ]) === !1)
                  )
                    return;
                  const v = s(y, _);
                  if (!v) return;
                  const b = _.getBarHeight(
                      u.id,
                      h.type == r.config.types.milestone
                    ),
                    g = Math.floor((_.getItemHeight(u.id) - b) / 2);
                  return (
                    (v.style.top = f.top + g + "px"),
                    v.classList.add("gantt_rollup_child"),
                    v.setAttribute("data-rollup-parent-id", u.id),
                    v
                  );
                }
                function c(u, h) {
                  return u + "_" + h;
                }
                return {
                  render: function (u, h, _, f) {
                    if (u.rollup !== !1 && u.$rollup && u.$rollup.length) {
                      const y = document.createElement("div"),
                        v = r.getTaskPosition(u);
                      return (
                        f && ((f.y = 0), (f.y_end = r.$task_bg.scrollHeight)),
                        u.$rollup.forEach(function (b) {
                          if (!r.isTaskExists(b)) return;
                          const g = r.getTask(b);
                          if (!l(g, f, h, _)) return;
                          const m = d(u, g, h, v);
                          m
                            ? ((o[c(g.id, u.id)] = m), y.appendChild(m))
                            : (o[c(g.id, u.id)] = !1);
                        }),
                        y
                      );
                    }
                    return !1;
                  },
                  update: function (u, h, _, f, y) {
                    const v = document.createElement("div"),
                      b = r.getTaskPosition(u);
                    (y.y = 0),
                      (y.y_end = r.$task_bg.scrollHeight),
                      u.$rollup.forEach(function (g) {
                        const m = r.getTask(g),
                          p = c(m.id, u.id);
                        let k = l(m, y, _, f);
                        if (k !== !!o[p])
                          if (k) {
                            const w = d(u, m, _, b);
                            o[p] = w || !1;
                          } else o[p] = !1;
                        o[p] && v.appendChild(o[p]),
                          (h.innerHTML = ""),
                          h.appendChild(v);
                      });
                  },
                  isInViewPort: Ot,
                  getVisibleRange: et,
                };
              })(t);
            },
            taskSplitBar: function () {
              return (function (r) {
                const s = Ve(r),
                  o = {};
                function l(h, _, f, y, v) {
                  let b = !h.hide_bar;
                  return y.smart_rendering && b && (b = Ot(h, _, f)), b;
                }
                function d(h, _, f, y, v) {
                  if (_.hide_bar) return;
                  const b = r.isSummaryTask(_);
                  b && r.resetProjectDates(_);
                  const g = r.copy(r.getTask(_.id));
                  if (
                    ((g.$rendered_at = h.id),
                    r.callEvent("onBeforeSplitTaskDisplay", [g.id, g, h.id]) ===
                      !1)
                  )
                    return;
                  const m = s(g, f);
                  if (!m) return;
                  const p = _.type === r.config.types.milestone;
                  let k;
                  const w = y.rowHeight,
                    x = f.getBarHeight(g.id, p);
                  let $ = Math.floor((f.getItemHeight(h.id) - x) / 2);
                  p && (k = Mn(x)),
                    v && ($ = p ? Math.floor((k - x) / 2) + 2 : 2);
                  const S = m.querySelector(
                      ".gantt_link_control.task_start_date"
                    ),
                    T = m.querySelector(".gantt_link_control.task_end_date");
                  if (p) {
                    if (k > w) {
                      ($ = 2), (m.style.height = w - $ + "px");
                      const E = In(w),
                        C = (E - w) / 2,
                        D = m.querySelector(".gantt_task_content");
                      ($ = Math.abs(C)),
                        (S.style.marginLeft = C + "px"),
                        (T.style.marginRight = C + "px"),
                        (S.style.height = T.style.height = E + "px"),
                        (m.style.width =
                          D.style.height =
                          D.style.width =
                            E + "px"),
                        (m.style.left =
                          f.getItemPosition(g).left - E / 2 + "px");
                    }
                  } else
                    x + $ > w &&
                      (($ = 0),
                      (m.style.height =
                        m.style.lineHeight =
                        S.style.height =
                        T.style.height =
                          w + "px"));
                  return (
                    (m.style.top = y.top + $ + "px"),
                    m.classList.add("gantt_split_child"),
                    b && m.classList.add("gantt_split_subproject"),
                    m
                  );
                }
                function c(h, _) {
                  return h + "_" + _;
                }
                function u(h, _) {
                  return (
                    r.isSplitTask(h) &&
                    ((_.open_split_tasks && !h.$open) || !_.open_split_tasks) &&
                    r.hasChild(h.id)
                  );
                }
                return {
                  render: function (h, _, f, y) {
                    if (u(h, f)) {
                      const v = document.createElement("div"),
                        b = r.getTaskPosition(h),
                        g = Ft(r, h.id);
                      return (
                        r.hasChild(h.id) &&
                          r.eachTask(function (m) {
                            if (!l(m, y, _, f)) return;
                            const p = d(h, m, _, b, g);
                            p
                              ? ((o[c(m.id, h.id)] = p), v.appendChild(p))
                              : (o[c(m.id, h.id)] = !1);
                          }, h.id),
                        v
                      );
                    }
                    return !1;
                  },
                  update: function (h, _, f, y, v) {
                    if (u(h, y)) {
                      const b = document.createElement("div"),
                        g = r.getTaskPosition(h),
                        m = Ft(r, h.id);
                      r.eachTask(function (p) {
                        const k = c(p.id, h.id);
                        let w = l(p, v, f, y);
                        if (w !== !!o[k])
                          if (w) {
                            const x = d(h, p, f, g, m);
                            o[k] = x || !1;
                          } else o[k] = !1;
                        o[k] && b.appendChild(o[k]),
                          (_.innerHTML = ""),
                          _.appendChild(b);
                      }, h.id);
                    }
                  },
                  isInViewPort: hr,
                  getVisibleRange: et,
                };
              })(t);
            },
            taskConstraints: function () {
              return yr(t);
            },
            taskDeadline: function () {
              return (function (r) {
                function s(o, l, d) {
                  const c = document.createElement("div"),
                    u = r.getTaskPosition(o, o.deadline, o.deadline),
                    { height: h, marginTop: _ } = Ln(r, l, u, 20, o, d);
                  let f = h;
                  return (
                    r.config.rtl && (u.left += f),
                    (c.style.left = u.left - f + "px"),
                    (c.style.top = u.top + "px"),
                    (c.style.marginTop = _ + "px"),
                    (c.style.width = f + "px"),
                    (c.style.height = h + "px"),
                    (c.style.fontSize = h + "px"),
                    (c.className = "gantt_task_deadline"),
                    c.setAttribute("data-task-id", o.id),
                    c
                  );
                }
                return {
                  render: function (o, l, d, c) {
                    const u = document.createElement("div");
                    if (
                      ((u.className = "gantt_deadline_nodes"),
                      u.setAttribute("data-task-row-id", o.id),
                      o.deadline)
                    ) {
                      const h = s(o, l);
                      u.appendChild(h);
                    }
                    if (ft(o)) {
                      const h = Ft(r, o.id);
                      r.eachTask(function (_) {
                        if (_.deadline) {
                          const f = s(_, l, h);
                          u.appendChild(f);
                        }
                      }, o.id);
                    }
                    if (u.childNodes.length) return u;
                  },
                  isInViewPort: br,
                  getVisibleRange: et,
                };
              })(t);
            },
            taskBaselines: function () {
              return (function (r) {
                function s(o, l, d, c, u) {
                  const h = document.createElement("div");
                  let _ = l.end_date,
                    f = o.type === r.config.types.milestone;
                  f && (_ = l.start_date);
                  const y = r.getTaskPosition(o, l.start_date, _);
                  let v,
                    b = 0;
                  if (f) {
                    let T = c.getBarHeight(o.id, !0);
                    (v = Mn(T)), (b = Math.floor((v - T) / 4));
                  }
                  let g = ee(r, c, o, y.rowHeight).maxHeight,
                    m = y.top + 1 + b,
                    p = c.getBarHeight(o.id, o.type);
                  const k = r.config.baselines.row_height,
                    w = r.config.baselines.bar_height;
                  let x, $;
                  switch (r.config.baselines.render_mode) {
                    case "separateRow":
                      (m += y.height + (k - w) / 2), (p = w);
                      break;
                    case "individualRow":
                      (x = k * d), (m += y.height + x + (k - w) / 2), (p = w);
                      break;
                    default:
                      ($ = 1),
                        u
                          ? ((g = ee(r, c, o).maxHeight),
                            b
                              ? g >= v
                                ? ($ = (g - p) / 2 - 1 - b)
                                : ((p = In(g)),
                                  (m = y.top),
                                  ($ = Math.abs(p - g) / 2),
                                  (b = 0))
                              : (g > p && ($ = (g - p) / 2 - 1), ($ -= b)),
                            o.bar_height || ($ -= 1))
                          : (o.bar_height &&
                              y.rowHeight >= o.bar_height &&
                              ($ = (y.rowHeight - o.bar_height) / 2 - 1),
                            ($ += b),
                            o.bar_height || ($ += 2),
                            f && ($ += 1));
                  }
                  let S = y.top + g + 1 - b;
                  return (
                    !(m + p > S && ((p -= m + p - S), p <= 0)) &&
                    ((h.style.left = y.left + "px"),
                    (h.style.width = y.width + "px"),
                    (h.style.top = m + "px"),
                    (h.style.height = Math.floor(p) + "px"),
                    $ && (h.style.marginTop = $ + "px"),
                    (h.className = `gantt_task_baseline gantt_task_baseline_${d} ${
                      l.className || ""
                    }`),
                    f
                      ? ((h.className += " gantt_milestone_baseline"),
                        (h.style.width = h.style.height = p + "px"),
                        (h.style.marginLeft = Math.floor(-p / 2) + "px"))
                      : (h.innerHTML = r.templates.baseline_text(o, l, d)),
                    h.setAttribute("data-task-id", o.id),
                    h.setAttribute("data-baseline-id", l.id),
                    h)
                  );
                }
                return {
                  render: function (o, l, d, c) {
                    if (!r.config.baselines.render_mode) return;
                    const u = document.createElement("div");
                    return (
                      (u.className = "gantt_baseline_nodes"),
                      u.setAttribute("data-task-row-id", o.id),
                      o.baselines &&
                        o.baselines.length &&
                        o.baselines.forEach(function (h, _) {
                          const f = s(o, h, _, l);
                          f && u.appendChild(f);
                        }),
                      ft(o) &&
                        r.eachTask(function (h) {
                          h.baselines &&
                            h.baselines.length &&
                            h.baselines.forEach(function (_, f) {
                              const y = s(h, _, f, l, !0);
                              y && u.appendChild(y);
                            });
                        }, o.id),
                      u.childNodes.length ? u : void 0
                    );
                  },
                  isInViewPort: $r,
                  getVisibleRange: et,
                };
              })(t);
            },
            link: function () {
              return gr(t);
            },
            resourceRow: function () {
              return (function (r) {
                var s = Kn(r),
                  o = {};
                function l(c, u, h, _, f) {
                  var y = h.resource_cell_class(
                      u.start_date,
                      u.end_date,
                      c,
                      u.tasks,
                      u.assignments
                    ),
                    v = h.resource_cell_value(
                      u.start_date,
                      u.end_date,
                      c,
                      u.tasks,
                      u.assignments
                    ),
                    b = f.getItemHeight(c.id) - 1;
                  if (y || v) {
                    var g = f.getItemPosition(c, u.start_date, u.end_date),
                      m = document.createElement("div");
                    return (
                      m.setAttribute(f.$config.item_attribute, c.id),
                      (m.className = ["gantt_resource_marker", y].join(" ")),
                      (m.style.cssText = [
                        "left:" + g.left + "px",
                        "width:" + g.width + "px",
                        "height:" + b + "px",
                        "line-height:" + b + "px",
                        "top:" + g.top + "px",
                      ].join(";")),
                      v && (m.innerHTML = v),
                      m
                    );
                  }
                  return null;
                }
                function d(c, u) {
                  o[c] &&
                    o[c][u] &&
                    o[c][u].parentNode &&
                    o[c][u].parentNode.removeChild(o[c][u]);
                }
                return {
                  render: function (c, u, h, _) {
                    var f = u.$getTemplates(),
                      y = u.getScale(),
                      v = s(c, h.resource_property, u.getScale(), u),
                      b = !!_,
                      g = [];
                    o[c.id] = {};
                    for (var m = Dt(y, _), p = m.start; p <= m.end; p++) {
                      var k = v[p];
                      if (k && (!b || Ut(p, y, _, r))) {
                        var w = l(c, k, f, 0, u);
                        w && (g.push(w), (o[c.id][p] = w));
                      }
                    }
                    var x = null;
                    if (g.length) {
                      x = document.createElement("div");
                      for (var $ = 0; $ < g.length; $++) x.appendChild(g[$]);
                    }
                    return x;
                  },
                  update: function (c, u, h, _, f) {
                    var y = h.$getTemplates(),
                      v = h.getScale(),
                      b = s(c, _.resource_property, h.getScale(), h),
                      g = Dt(v, f),
                      m = {};
                    if (o && o[c.id]) for (var p in o[c.id]) m[p] = p;
                    for (var k = g.start; k <= g.end; k++) {
                      var w = b[k];
                      if (((m[k] = !1), w))
                        if (Ut(k, v, f, r))
                          if (o[c.id] && o[c.id][k])
                            o[c.id] &&
                              o[c.id][k] &&
                              !o[c.id][k].parentNode &&
                              u.appendChild(o[c.id][k]);
                          else {
                            var x = l(c, w, y, 0, h);
                            x && (u.appendChild(x), (o[c.id][k] = x));
                          }
                        else d(c.id, k);
                    }
                    for (var p in m) m[p] !== !1 && d(c.id, p);
                  },
                  getRectangle: Ue,
                  getVisibleRange: et,
                };
              })(t);
            },
            resourceHistogram: function () {
              return vr(t);
            },
            gridTaskRowResizer: function () {
              return (function (r) {
                return {
                  render: function (s, o, l) {
                    var d = o.$getConfig(),
                      c = document.createElement("div");
                    return (
                      (c.className = "gantt_task_grid_row_resize_wrap"),
                      (c.style.top =
                        o.getItemTop(s.id) + o.getItemHeight(s.id) + "px"),
                      (c.innerHTML =
                        "<div class='gantt_task_grid_row_resize' role='cell'></div>"),
                      c.setAttribute(d.task_grid_row_resizer_attribute, s.id),
                      r._waiAria.rowResizerAttr(c),
                      c
                    );
                  },
                  update: null,
                  getRectangle: ae,
                  getVisibleRange: et,
                };
              })(t);
            },
          },
          layersService: {
            getDataRender: function (r) {
              return i.getDataRender(r, t);
            },
            createDataRender: function (r) {
              return i.createDataRender(r, t);
            },
          },
        }
      );
    },
  };
  function Je(t, n) {
    const e = getComputedStyle(n.$root).getPropertyValue("--dhx-gantt-theme");
    let i,
      a = !!e;
    if (a) i = e;
    else {
      var r = n.skin;
      if (((i = r), !r || t))
        for (
          var s = document.getElementsByTagName("link"), o = 0;
          o < s.length;
          o++
        ) {
          var l = s[o].href.match("dhtmlxgantt_([a-z_]+).css");
          if (l && (n.skins[l[1]] || !r)) {
            i = l[1];
            break;
          }
        }
    }
    (n._theme_info = { theme: i, cssVarTheme: a }), (n.skin = i || "terrace");
    var d = n.skins[n.skin] || n.skins.terrace;
    (function (h, _, f) {
      for (var y in _) (h[y] === void 0 || f) && (h[y] = _[y]);
    })(n.config, d.config, t),
      a || (n.config.link_radius = 1);
    var c = n.getGridColumns();
    for (
      c[1] && !n.defined(c[1].width) && (c[1].width = d._second_column_width),
        c[2] && !n.defined(c[2].width) && (c[2].width = d._third_column_width),
        o = 0;
      o < c.length;
      o++
    ) {
      var u = c[o];
      u.name == "add" &&
        (u.width || (u.width = 44),
        (n.defined(u.min_width) && n.defined(u.max_width)) ||
          ((u.min_width = u.min_width || u.width),
          (u.max_width = u.max_width || u.width)),
        u.min_width && (u.min_width = +u.min_width),
        u.max_width && (u.max_width = +u.max_width),
        u.width &&
          ((u.width = +u.width),
          (u.width =
            u.min_width && u.min_width > u.width ? u.min_width : u.width),
          (u.width =
            u.max_width && u.max_width < u.width ? u.max_width : u.width)));
    }
    d.config.task_height &&
      (n.config.task_height = d.config.task_height || "full"),
      d.config.bar_height &&
        (n.config.bar_height = d.config.bar_height || "full"),
      d._lightbox_template && (n._lightbox_template = d._lightbox_template),
      d._redefine_lightbox_buttons &&
        ((n.config.buttons_right = d._redefine_lightbox_buttons.buttons_right),
        (n.config.buttons_left = d._redefine_lightbox_buttons.buttons_left)),
      n.resetLightbox();
  }
  function Ir(t) {
    var n = null,
      e = !1,
      i = null,
      a = { started: !1 },
      r = {};
    function s(_) {
      return _ && tt(_, t.$root) && _.offsetHeight;
    }
    function o() {
      var _ = !!document.querySelector(".gantt_drag_marker"),
        f =
          !!document.querySelector(
            ".gantt_drag_marker.gantt_grid_resize_area"
          ) ||
          !!document.querySelector(
            ".gantt_drag_marker.gantt_row_grid_resize_area"
          ),
        y = !!document.querySelector(".gantt_link_direction"),
        v = t.getState(),
        b = v.autoscroll;
      return (e = _ && !f && !y), !((!v.drag_mode && !_) || f) || b;
    }
    function l(_) {
      if ((i && (clearTimeout(i), (i = null)), _)) {
        var f = t.config.autoscroll_speed;
        f && f < 10 && (f = 10),
          (i = setTimeout(function () {
            n = setInterval(u, f || 50);
          }, t.config.autoscroll_delay || 10));
      }
    }
    function d(_) {
      _
        ? (l(!0), a.started || ((a.x = r.x), (a.y = r.y), (a.started = !0)))
        : (n && (clearInterval(n), (n = null)), l(!1), (a.started = !1));
    }
    function c(_) {
      var f = o();
      if (((!n && !i) || f || d(!1), !t.config.autoscroll || !f)) return !1;
      (r = { x: _.clientX, y: _.clientY }),
        _.type == "touchmove" &&
          ((r.x = _.targetTouches[0].clientX),
          (r.y = _.targetTouches[0].clientY)),
        !n && f && d(!0);
    }
    function u() {
      if (!o()) return d(!1), !1;
      var _ = s(t.$task) ? t.$task : s(t.$grid) ? t.$grid : t.$root;
      if (_) {
        var f = !1;
        [
          ".gantt_drag_marker.gantt_grid_resize_area",
          ".gantt_drag_marker .gantt_row.gantt_row_task",
          ".gantt_drag_marker.gantt_grid_dnd_marker",
        ].forEach(function (C) {
          f = f || !!document.querySelector(C);
        }),
          f && (_ = t.$grid);
        var y = Y(_),
          v = r.x - y.x,
          b = r.y - y.y + window.scrollY,
          g = e ? 0 : h(v, y.width, a.x - y.x),
          m = h(b, y.height, a.y - y.y + window.scrollY),
          p = t.getScrollState(),
          k = p.y,
          w = p.inner_height,
          x = p.height,
          $ = p.x,
          S = p.inner_width,
          T = p.width;
        ((m && !w) || (m < 0 && !k) || (m > 0 && k + w >= x + 2)) && (m = 0),
          ((g && !S) || (g < 0 && !$) || (g > 0 && $ + S >= T)) && (g = 0);
        var E = t.config.autoscroll_step;
        E && E < 2 && (E = 2),
          (m *= E || 30),
          ((g *= E || 30) || m) &&
            (function (C, D) {
              var A = t.getScrollState(),
                I = null,
                M = null;
              C &&
                ((I = A.x + C),
                (I = Math.min(A.width, I)),
                (I = Math.max(0, I))),
                D &&
                  ((M = A.y + D),
                  (M = Math.min(A.height, M)),
                  (M = Math.max(0, M))),
                t.scrollTo(I, M);
            })(g, m);
      }
    }
    function h(_, f, y) {
      return _ - 50 < 0 && _ < y ? -1 : _ > f - 50 && _ > y ? 1 : 0;
    }
    t.attachEvent("onGanttReady", function () {
      if (!K(t)) {
        var _ = Ct(t.$root) || document.body;
        t.eventRemove(_, "mousemove", c),
          t.event(_, "mousemove", c),
          t.eventRemove(_, "touchmove", c),
          t.event(_, "touchmove", c),
          t.eventRemove(_, "pointermove", c),
          t.event(_, "pointermove", c);
      }
    }),
      t.attachEvent("onDestroy", function () {
        d(!1);
      });
  }
  var Ke, Xe;
  typeof window < "u" &&
    window.jQuery &&
    ((Ke = window.jQuery),
    (Xe = []),
    (Ke.fn.dhx_gantt = function (t) {
      if (typeof (t = t || {}) != "string") {
        var n = [];
        return (
          this.each(function () {
            if (this && this.getAttribute)
              if (this.gantt || window.gantt.$root == this)
                n.push(
                  typeof this.gantt == "object" ? this.gantt : window.gantt
                );
              else {
                var e =
                  window.gantt.$container && window.Gantt
                    ? window.Gantt.getGanttInstance()
                    : window.gantt;
                for (var i in t) i != "data" && (e.config[i] = t[i]);
                e.init(this), t.data && e.parse(t.data), n.push(e);
              }
          }),
          n.length === 1 ? n[0] : n
        );
      }
      if (Xe[t]) return Xe[t].apply(this, []);
      Ke.error("Method " + t + " does not exist on jQuery.dhx_gantt");
    })),
    typeof window < "u" &&
      window.dhtmlx &&
      (window.dhtmlx.attaches || (window.dhtmlx.attaches = {}),
      (window.dhtmlx.attaches.attachGantt = function (t, n, e) {
        var i = document.createElement("DIV");
        (e = e || window.gantt),
          (i.id = "gantt_" + e.uid()),
          (i.style.width = "100%"),
          (i.style.height = "100%"),
          (i.cmp = "grid"),
          document.body.appendChild(i),
          this.attachObject(i.id),
          (this.dataType = "gantt"),
          (this.dataObj = e);
        var a = this.vs[this.av];
        return (
          (a.grid = e),
          e.init(i.id, t, n),
          (i.firstChild.style.border = "none"),
          (a.gridId = i.id),
          (a.gridObj = i),
          this.vs[this._viewRestore()].grid
        );
      })),
    typeof window < "u" &&
      window.dhtmlXCellObject !== void 0 &&
      (window.dhtmlXCellObject.prototype.attachGantt = function (t, n, e) {
        e = e || window.gantt;
        var i = document.createElement("DIV");
        return (
          (i.id = "gantt_" + e.uid()),
          (i.style.width = "100%"),
          (i.style.height = "100%"),
          (i.cmp = "grid"),
          document.body.appendChild(i),
          this.attachObject(i.id),
          (this.dataType = "gantt"),
          (this.dataObj = e),
          e.init(i.id, t, n),
          (i.firstChild.style.border = "none"),
          (i = null),
          this.callEvent("_onContentAttach", []),
          this.dataObj
        );
      });
  const Lr = ["ctrlKey", "altKey", "shiftKey", "metaKey"],
    Nr = [
      [
        { unit: "month", date: "%M", step: 1 },
        { unit: "day", date: "%d", step: 1 },
      ],
      [{ unit: "day", date: "%d %M", step: 1 }],
      [
        { unit: "day", date: "%d %M", step: 1 },
        { unit: "hour", date: "%H:00", step: 8 },
      ],
      [
        { unit: "day", date: "%d %M", step: 1 },
        { unit: "hour", date: "%H:00", step: 1 },
      ],
    ];
  class Pr {
    constructor(n) {
      (this.zoomIn = () => {
        const e = this.getCurrentLevel() - 1;
        e < 0 || this.setLevel(e);
      }),
        (this.zoomOut = () => {
          const e = this.getCurrentLevel() + 1;
          e > this._levels.length - 1 || this.setLevel(e);
        }),
        (this.getCurrentLevel = () => this._activeLevelIndex),
        (this.getLevels = () => this._levels),
        (this.setLevel = (e) => {
          const i = this._getZoomIndexByName(e);
          i === -1 &&
            this.$gantt.assert(
              i !== -1,
              "Invalid zoom level for gantt.ext.zoom.setLevel. " +
                e +
                " is not an expected value."
            ),
            this._setLevel(i, 0);
        }),
        (this._getZoomIndexByName = (e) => {
          let i = -1;
          if (typeof e == "string") {
            if (!isNaN(Number(e)) && this._levels[Number(e)]) i = Number(e);
            else
              for (let a = 0; a < this._levels.length; a++)
                if (this._levels[a].name === e) {
                  i = a;
                  break;
                }
          } else i = e;
          return i;
        }),
        (this._getVisibleDate = () => {
          if (!this.$gantt.$task) return null;
          const e = this.$gantt.getScrollState().x,
            i = this.$gantt.$task.offsetWidth;
          this._visibleDate = this.$gantt.dateFromPos(e + i / 2);
        }),
        (this._setLevel = (e, i) => {
          this._activeLevelIndex = e;
          const a = this.$gantt,
            r = a.copy(this._levels[this._activeLevelIndex]),
            s = a.copy(r);
          if (
            (delete s.name,
            a.mixin(a.config, s, !0),
            ["resourceTimeline", "resourceHistogram"].forEach(function (o) {
              const l = a.$ui.getView(o);
              if (l) {
                const d = l.$getConfig();
                d.fixed_scales || a.mixin(d, s, !0);
              }
            }),
            a.$root && a.$task)
          ) {
            if (i) {
              const o = this.$gantt.dateFromPos(
                i + this.$gantt.getScrollState().x
              );
              this.$gantt.render();
              const l = this.$gantt.posFromDate(o);
              this.$gantt.scrollTo(l - i);
            } else {
              const o = this.$gantt.$task.offsetWidth;
              this._visibleDate || this._getVisibleDate();
              const l = this._visibleDate;
              this.$gantt.render();
              const d = this.$gantt.posFromDate(l);
              this.$gantt.scrollTo(d - o / 2);
            }
            this.callEvent("onAfterZoom", [this._activeLevelIndex, r]);
          }
        }),
        (this._attachWheelEvent = (e) => {
          const i = kt.isFF ? "wheel" : "mousewheel";
          let a;
          (a = typeof e.element == "function" ? e.element() : e.element),
            a &&
              this._domEvents.attach(
                a,
                i,
                this.$gantt.bind(function (r) {
                  if (
                    this._useKey &&
                    (Lr.indexOf(this._useKey) < 0 || !r[this._useKey])
                  )
                    return !1;
                  if (typeof this._handler == "function")
                    return this._handler.apply(this, [r]), !0;
                }, this),
                { passive: !1 }
              );
        }),
        (this._defaultHandler = (e) => {
          const i = this.$gantt.$task.getBoundingClientRect().x,
            a = e.clientX - i;
          let r = !1;
          (this.$gantt.env.isFF ? -40 * e.deltaY : e.wheelDelta) > 0 &&
            (r = !0),
            e.preventDefault(),
            e.stopPropagation(),
            this._setScaleSettings(r, a);
        }),
        (this._setScaleDates = () => {
          this._initialStartDate &&
            this._initialEndDate &&
            ((this.$gantt.config.start_date = this._initialStartDate),
            (this.$gantt.config.end_date = this._initialEndDate));
        }),
        (this.$gantt = n),
        (this._domEvents = this.$gantt._createDomEventScope());
    }
    init(n) {
      this.$gantt.env.isNode ||
        ((this._initialStartDate = n.startDate),
        (this._initialEndDate = n.endDate),
        (this._activeLevelIndex = n.activeLevelIndex ? n.activeLevelIndex : 0),
        (this._levels = this._mapScales(n.levels || Nr)),
        (this._handler = n.handler || this._defaultHandler),
        (this._minColumnWidth = n.minColumnWidth || 60),
        (this._maxColumnWidth = n.maxColumnWidth || 240),
        (this._widthStep = n.widthStep || (3 / 8) * n.minColumnWidth),
        (this._useKey = n.useKey),
        this._initialized ||
          (ct(this),
          this.$gantt.attachEvent("onGanttScroll", () => {
            this._getVisibleDate();
          })),
        this._domEvents.detachAll(),
        n.trigger === "wheel" &&
          (this.$gantt.$root
            ? this._attachWheelEvent(n)
            : this.$gantt.attachEvent("onGanttLayoutReady", () => {
                this.$gantt.attachEvent(
                  "onGanttRender",
                  () => {
                    this._attachWheelEvent(n);
                  },
                  { once: !0 }
                );
              })),
        (this._initialized = !0),
        this.setLevel(this._activeLevelIndex));
    }
    _mapScales(n) {
      return n.map((e) => (Array.isArray(e) ? { scales: e } : e));
    }
    _setScaleSettings(n, e) {
      n ? this._stepUp(e) : this._stepDown(e);
    }
    _stepUp(n) {
      if (this._activeLevelIndex >= this._levels.length - 1) return;
      let e = this._activeLevelIndex;
      if ((this._setScaleDates(), this._widthStep)) {
        let i = this.$gantt.config.min_column_width + this._widthStep;
        i > this._maxColumnWidth && ((i = this._minColumnWidth), e++),
          (this.$gantt.config.min_column_width = i);
      } else e++;
      this._setLevel(e, n);
    }
    _stepDown(n) {
      if (this._activeLevelIndex < 1) return;
      let e = this._activeLevelIndex;
      if ((this._setScaleDates(), this._widthStep)) {
        let i = this.$gantt.config.min_column_width - this._widthStep;
        i < this._minColumnWidth && ((i = this._maxColumnWidth), e--),
          (this.$gantt.config.min_column_width = i);
      } else e--;
      this._setLevel(e, n);
    }
  }
  function Rr(t) {
    function n() {
      if (
        (t.config.touch != "force" &&
          (t.config.touch =
            (t.config.touch &&
              (navigator.userAgent.indexOf("Mobile") != -1 ||
                navigator.userAgent.indexOf("iPad") != -1 ||
                navigator.userAgent.indexOf("Android") != -1 ||
                navigator.userAgent.indexOf("Touch") != -1)) ||
            (navigator.platform === "MacIntel" &&
              navigator.maxTouchPoints > 1)),
        t.config.touch)
      ) {
        var r = !0;
        try {
          document.createEvent("TouchEvent");
        } catch {
          r = !1;
        }
        r
          ? t._touch_events(
              ["touchmove", "touchstart", "touchend"],
              function (s) {
                return s.touches && s.touches.length > 1
                  ? null
                  : s.touches[0]
                  ? {
                      target: s.target,
                      pageX: s.touches[0].pageX,
                      pageY: s.touches[0].pageY,
                      clientX: s.touches[0].clientX,
                      clientY: s.touches[0].clientY,
                    }
                  : s;
              },
              function (s) {
                return s.defaultPrevented;
              }
            )
          : window.navigator.pointerEnabled
          ? t._touch_events(
              ["pointermove", "pointerdown", "pointerup"],
              function (s) {
                return s.pointerType == "mouse" ? null : s;
              },
              function (s) {
                return !s || s.pointerType == "mouse";
              }
            )
          : window.navigator.msPointerEnabled &&
            t._touch_events(
              ["MSPointerMove", "MSPointerDown", "MSPointerUp"],
              function (s) {
                return s.pointerType == s.MSPOINTER_TYPE_MOUSE ? null : s;
              },
              function (s) {
                return !s || s.pointerType == s.MSPOINTER_TYPE_MOUSE;
              }
            );
      }
    }
    function e(r) {
      var s = r.$config.scrollX ? t.$ui.getView(r.$config.scrollX) : null,
        o = r.$config.scrollY ? t.$ui.getView(r.$config.scrollY) : null,
        l = { x: null, y: null };
      return (
        s && s.getScrollState().visible && (l.x = s.$view.scrollLeft),
        o && o.getScrollState().visible && (l.y = o.$view.scrollTop),
        l
      );
    }
    function i() {
      var r;
      return (
        t.$ui.getView("timeline") && (r = t.$ui.getView("timeline")._tasks_dnd),
        r
      );
    }
    (t.config.touch_drag = 75),
      (t.config.touch = !0),
      (t.config.touch_feedback = !0),
      (t.config.touch_feedback_duration = 1),
      (t._prevent_touch_scroll = !1),
      (t._touch_feedback = function () {
        t.config.touch_feedback &&
          navigator.vibrate &&
          navigator.vibrate(t.config.touch_feedback_duration);
      }),
      t.attachEvent("onGanttReady", function () {
        t.$container && n();
      }),
      t.attachEvent("onGanttLayoutReady", function () {
        t.$container && t.attachEvent("onGanttRender", n, { once: !0 });
      });
    var a = [];
    t._touch_events = function (r, s, o) {
      var l,
        d = 0,
        c = !1,
        u = !1,
        h = null,
        _ = null,
        f = null,
        y = [],
        v = null;
      let b = {};
      for (var g = 0; g < a.length; g++)
        t.eventRemove(a[g][0], a[g][1], a[g][2]);
      (a = []).push([
        t.$container,
        r[0],
        function (p) {
          var k = i();
          if (!o(p) && c) {
            _ && clearTimeout(_);
            var w = s(p);
            if (k && (k.drag.id || k.drag.start_drag))
              return (
                k.on_mouse_move(w),
                p.preventDefault && p.preventDefault(),
                (p.cancelBubble = !0),
                !1
              );
            if (!t._prevent_touch_scroll) {
              if (w && h) {
                var x = h.pageX - w.pageX,
                  $ = h.pageY - w.pageY;
                if (
                  (!u &&
                    (Math.abs(x) > 5 || Math.abs($) > 5) &&
                    ((u = !0), (d = 0), (l = v ? e(v) : t.getScrollState())),
                  u)
                ) {
                  var S,
                    T = l.x + x,
                    E = l.y + $;
                  if (
                    (v
                      ? ((function (C, D, A) {
                          var I = C.$config.scrollX
                              ? t.$ui.getView(C.$config.scrollX)
                              : null,
                            M = C.$config.scrollY
                              ? t.$ui.getView(C.$config.scrollY)
                              : null;
                          I && I.scrollTo(D, null), M && M.scrollTo(null, A);
                        })(v, T, E),
                        (S = e(v)))
                      : (t.scrollTo(T, E), (S = t.getScrollState())),
                    (l.x != S.x && $ > 2 * x) || (l.y != S.y && x > 2 * $))
                  )
                    return m(p);
                }
              }
              return m(p);
            }
            return !0;
          }
        },
      ]);
      try {
        document.addEventListener(
          "touchmove",
          function (p) {
            t._touch_drag && m(p);
          },
          { passive: !1 }
        );
      } catch {
        console.warn("Cannot prevent touch event for the page drag");
      }
      for (
        a.push([
          this.$container,
          "contextmenu",
          function (p) {
            if (c) return m(p);
          },
        ]),
          a.push([
            this.$container,
            r[1],
            function (p) {
              if (
                ((b = p.touches.length),
                document &&
                  document.body &&
                  document.body.classList.add("gantt_touch_active"),
                !o(p))
              )
                if (p.touches && p.touches.length > 1) c = !1;
                else {
                  (h = s(p)),
                    (v = (function (w) {
                      for (
                        var x = t.$layout.getCellsByType("viewCell"), $ = 0;
                        $ < x.length;
                        $++
                      ) {
                        var S = x[$].$view.getBoundingClientRect();
                        if (
                          w.clientX >= S.left &&
                          w.clientX <= S.right &&
                          w.clientY <= S.bottom &&
                          w.clientY >= S.top
                        )
                          return x[$];
                      }
                    })(h)),
                    t._locate_css(h, "gantt_hor_scroll") ||
                      t._locate_css(h, "gantt_ver_scroll") ||
                      (c = !0);
                  var k = i();
                  _ = setTimeout(function () {
                    var w = t.locate(h);
                    k &&
                      w &&
                      !t._locate_css(h, "gantt_link_control") &&
                      !t._locate_css(h, "gantt_grid_data") &&
                      (k.on_mouse_down(h),
                      k.drag &&
                        k.drag.start_drag &&
                        ((function (x) {
                          const $ = t._getTaskLayers();
                          let S = t.getTask(x);
                          if (S) {
                            let T = t.isTaskVisible(x);
                            if (T) {
                              f = x;
                              for (let E = 0; E < $.length; E++)
                                if (
                                  ((S = $[E].rendered[x]),
                                  S &&
                                    S.getAttribute(t.config.task_attribute) &&
                                    S.getAttribute(t.config.task_attribute) ==
                                      x)
                                ) {
                                  const C = S.cloneNode(!0);
                                  y.push(S),
                                    ($[E].rendered[x] = C),
                                    (S.style.display = "none"),
                                    (C.className += " gantt_drag_move "),
                                    S.parentNode.appendChild(C);
                                }
                            } else if (S.$split_subtask) {
                              let E = S.$rendered_parent;
                              if (((T = t.isTaskVisible(E)), !T)) return;
                              f = x;
                              for (let C = 0; C < $.length; C++) {
                                const D = $[C].rendered[E];
                                let A;
                                if (
                                  (D &&
                                    D.childNodes &&
                                    (A = D.querySelector(
                                      `[${t.config.task_attribute}="${S.id}"]`
                                    )),
                                  A)
                                ) {
                                  const I = A.cloneNode(!0);
                                  A.parentNode.appendChild(I),
                                    t.$task_bars.appendChild(A),
                                    (A.style.display = "none"),
                                    y.push(A),
                                    (A = null);
                                }
                              }
                            }
                          }
                        })(w),
                        k._start_dnd(h),
                        (t._touch_drag = !0),
                        t.refreshTask(w),
                        t._touch_feedback())),
                      (_ = null);
                  }, t.config.touch_drag);
                }
            },
          ]),
          a.push([
            this.$container,
            r[2],
            function (p) {
              if (
                (document &&
                  document.body &&
                  document.body.classList.remove("gantt_touch_active"),
                !o(p))
              ) {
                _ && clearTimeout(_), (t._touch_drag = !1), (c = !1);
                var k = s(p),
                  w = i();
                if (
                  (w && w.on_mouse_up(k),
                  f &&
                    t.isTaskExists(f) &&
                    (t.refreshTask(f),
                    y.length &&
                      (y.forEach(function ($) {
                        $.parentNode && $.parentNode.removeChild($);
                      }),
                      t._touch_feedback())),
                  (c = u = !1),
                  (y = []),
                  (f = null),
                  h && d)
                ) {
                  var x = new Date();
                  x - d < 500 && b <= 1
                    ? (t.$services.getService("mouseEvents").onDoubleClick(h),
                      m(p))
                    : (d = x);
                } else d = new Date();
              }
            },
          ]),
          g = 0;
        g < a.length;
        g++
      )
        t.event(a[g][0], a[g][1], a[g][2]);
      function m(p) {
        return (
          p && p.preventDefault && p.cancelable && p.preventDefault(),
          (p.cancelBubble = !0),
          !1
        );
      }
    };
  }
  function re() {
    console.log("Method is not implemented.");
  }
  function Gt() {}
  function pt(t) {
    return Gt;
  }
  (Gt.prototype.render = re),
    (Gt.prototype.set_value = re),
    (Gt.prototype.get_value = re),
    (Gt.prototype.focus = re);
  var se = {
    getHtmlSelect: function (t, n, e) {
      var i = "",
        a = this;
      return (
        st((t = t || []), function (r) {
          var s = [{ key: "value", value: r.key }];
          e == r.key && (s[s.length] = { key: "selected", value: "selected" }),
            r.attributes && (s = s.concat(r.attributes)),
            (i += a.getHtmlOption({ innerHTML: r.label }, s));
        }),
        qt("select", { innerHTML: i }, n)
      );
    },
    getHtmlOption: function (t, n) {
      return qt("option", t, n);
    },
    getHtmlButton: function (t, n) {
      return qt("button", t, n);
    },
    getHtmlDiv: function (t, n) {
      return qt("div", t, n);
    },
    getHtmlLabel: function (t, n) {
      return qt("label", t, n);
    },
    getHtmlInput: function (t) {
      return "<input" + ii(t || []) + ">";
    },
  };
  function qt(t, n, e) {
    return (
      (n = n || []),
      "<" + t + ii(e || []) + ">" + (n.innerHTML || "") + "</" + t + ">"
    );
  }
  function ii(t) {
    var n = "";
    return (
      st(t, function (e) {
        n += " " + e.key + "='" + e.value + "'";
      }),
      n
    );
  }
  function Ze(t) {
    const n = pt();
    function e() {
      return n.apply(this, arguments) || this;
    }
    return (
      W(e, n),
      (e.prototype.render = function (i) {
        const a = i.height ? `height:${i.height}px;` : "";
        let r = `<div class='gantt_cal_ltext gantt_section_${i.name}' ${
          a ? `style='${a}'` : ""
        }>`;
        return (
          (r += se.getHtmlSelect(i.options, [
            { key: "style", value: "width:100%;" },
            { key: "title", value: i.name },
          ])),
          (r += "</div>"),
          r
        );
      }),
      (e.prototype.set_value = function (i, a, r, s) {
        var o = i.firstChild;
        !o._dhx_onchange &&
          s.onchange &&
          ((o.onchange = s.onchange), (o._dhx_onchange = !0)),
          a === void 0 && (a = (o.options[0] || {}).value),
          (o.value = a || "");
      }),
      (e.prototype.get_value = function (i) {
        return i.firstChild.value;
      }),
      (e.prototype.focus = function (i) {
        var a = i.firstChild;
        t._focus(a, !0);
      }),
      e
    );
  }
  const _e = class _e {
    constructor() {
      (this.canParse = (n) => !isNaN(this.parse(n))),
        (this.format = (n) => String(n)),
        (this.parse = (n) => parseInt(n, 10));
    }
  };
  _e.create = (n = null) => new _e();
  let oe = _e;
  function Hr(t) {
    var n = Ze(t);
    function e() {
      return n.apply(this, arguments) || this;
    }
    function i(a, r) {
      var s = [],
        o = [];
      r &&
        ((s = t.getTaskByTime()),
        a.allow_root &&
          s.unshift({ id: t.config.root_id, text: a.root_label || "" }),
        (s = (function (u, h, _) {
          var f =
            h.filter ||
            function () {
              return !0;
            };
          u = u.slice(0);
          for (var y = 0; y < u.length; y++) {
            var v = u[y];
            (v.id == _ || t.isChildOf(v.id, _) || f(v.id, v) === !1) &&
              (u.splice(y, 1), y--);
          }
          return u;
        })(s, a, r)),
        a.sort && s.sort(a.sort));
      for (
        var l = a.template || t.templates.task_text, d = 0;
        d < s.length;
        d++
      ) {
        var c = l.apply(t, [s[d].start_date, s[d].end_date, s[d]]);
        c === void 0 && (c = ""), o.push({ key: s[d].id, label: c });
      }
      return (
        (a.options = o),
        (a.map_to = a.map_to || "parent"),
        t.form_blocks.select.render.apply(this, arguments)
      );
    }
    return (
      W(e, n),
      (e.prototype.render = function (a) {
        return i(a, !1);
      }),
      (e.prototype.set_value = function (a, r, s, o) {
        r === 0 && (r = "0"),
          !s.id && t.getState().lightbox && (s.id = t.getLightboxValues().id);
        var l = document.createElement("div");
        l.innerHTML = i(o, s.id);
        var d = l.removeChild(l.firstChild);
        return (
          (a.onselect = null),
          a.parentNode.replaceChild(d, a),
          t.form_blocks.select.set_value.apply(t, [d, r, s, o])
        );
      }),
      e
    );
  }
  function Or(t) {
    const n = pt();
    var e = {
      resources: {},
      resourcesValues: {},
      filter: {},
      eventsInitialized: {},
    };
    function i() {
      return n.apply(this, arguments) || this;
    }
    function a(l, d, c, u) {
      var h,
        _ = "";
      if (l)
        return (
          (h = [
            { key: "data-item-id", value: l.key },
            { key: "data-assignment-id", value: u || "" },
            { key: "class", value: "gantt_resource_amount_input" },
          ]),
          c && h.push({ key: "disabled", value: "disabled" }),
          l.options
            ? (_ += se.getHtmlSelect(l.options, h, d))
            : ((h[h.length] = { key: "value", value: d || "" }),
              (_ += se.getHtmlInput(h))),
          _
        );
    }
    function r(l) {
      return l === void 0
        ? ".gantt_resource_amount_input"
        : "[data-checked='" +
            (l ? "true" : "false") +
            "'] .gantt_resource_amount_input";
    }
    function s(l) {
      return e.resources[l.id];
    }
    function o(l) {
      return e.filter[l.id];
    }
    return (
      t.attachEvent("onAfterLightbox", function () {
        for (var l in e.filter)
          (e.filter[l].checkbox.checked = !1),
            (e.filter[l].input.value = ""),
            (e.filter[l].filterApplied = !1);
        e.resourcesValues = {};
      }),
      W(i, n),
      (i.prototype.render = function (l) {
        var d;
        l.options || (l.options = t.serverList("resourceOptions")),
          (l.map_to && l.map_to != "auto") ||
            (l.map_to = t.config.resource_property);
        var c =
            t.locale.labels.resources_filter_placeholder ||
            l.filter_placeholder ||
            "type to filter",
          u = t.locale.labels.resources_filter_label || "hide empty";
        return (
          (d =
            "<div" +
            (isNaN(l.height) ? "" : " style='height: " + l.height + "px;'") +
            " class='gantt_section_" +
            l.name +
            "'>"),
          (d +=
            "<div class='gantt_cal_ltext gantt_resources_filter'><input type='text' class='gantt_resources_filter_input' placeholder='" +
            c +
            "'> <label><input class='switch_unsetted' type='checkbox'><span class='matherial_checkbox_icon'></span>" +
            u +
            "</label></div>"),
          (d +=
            "<div class='gantt_cal_ltext gantt_resources' data-name='" +
            l.name +
            "'></div>"),
          (d += "</div>")
        );
      }),
      (i.prototype.set_value = function (l, d, c, u) {
        var h,
          _ = (function (y, v) {
            return (
              e.resources[v.id] ||
                (e.resources[v.id] = y.querySelector(".gantt_resources")),
              e.resources[v.id]
            );
          })(l, u),
          f = "";
        (function (y, v) {
          if (!e.filter[v.id]) {
            var b = y.querySelector(".gantt_resources_filter"),
              g = b.querySelector(".gantt_resources_filter_input"),
              m = b.querySelector(".switch_unsetted");
            e.filter[v.id] = {
              container: b,
              input: g,
              checkbox: m,
              filterApplied: !1,
            };
          }
          e.filter[v.id];
        })(l, u),
          (function (y, v, b, g) {
            if (e.eventsInitialized[b.id]) return;
            var m = function (S) {
              var T, E, C, D, A;
              k(b, y);
              var I = o(b);
              (A = I.checkbox),
                (D = I.input),
                (C = A.checked),
                (E = D.value.trim()),
                (I.filterApplied = !!E),
                t.getState().lightbox && (v = t.getLightboxValues()),
                (T = (function (L, N, P, R) {
                  var B, H;
                  if (R) {
                    var F = N[L.map_to] || [];
                    if ((Lt(F) || (F = [F]), (F = F.slice()).length === 0)) {
                      for (var G in ((F = []),
                      ((H = t.copy(L)).options = []),
                      e.resourcesValues[L.id]))
                        (j = e.resourcesValues[L.id][G]).value !== "" &&
                          F.push({ resource_id: G, value: j.value, id: j.id });
                      if (F.length === 0) return H;
                    } else
                      for (var G in e.resourcesValues[L.id]) {
                        var j;
                        (j = e.resourcesValues[L.id][G]).value !== "" &&
                          (fe(F, function (At) {
                            return At.id == G;
                          }) ||
                            F.push({
                              resource_id: G,
                              value: j.value,
                              id: j.id,
                            }));
                      }
                    for (var _t = {}, yt = 0; yt < F.length; yt++)
                      _t[F[yt].resource_id] = !0;
                    B = function (q) {
                      if (
                        _t[String(q.key)] &&
                        (P === "" ||
                          q.label.toLowerCase().indexOf(P.toLowerCase()) >= 0)
                      )
                        return q;
                    };
                  } else {
                    if (P === "") return L;
                    B = function (q) {
                      if (q.label.toLowerCase().indexOf(P.toLowerCase()) >= 0)
                        return q;
                    };
                  }
                  return (
                    ((H = t.copy(L)).options = (function (q, At) {
                      var Yt = [];
                      if (q.filter) return q.filter(At);
                      for (var Mt = 0; Mt < q.length; Mt++)
                        At(q[Mt], Mt) && (Yt[Yt.length] = q[Mt]);
                      return Yt;
                    })(H.options, B)),
                    H
                  );
                })(b, v, E, C));
              var M = v[b.map_to];
              g.form_blocks.resources.set_value(y, M, v, T);
            };
            function p(S) {
              var T,
                E = S.target;
              if (S.target.type === "checkbox") {
                (T = E.parentNode.querySelector(r())).disabled = !E.checked;
                var C = T.getAttribute("data-item-id"),
                  D = mt(S, "gantt_resource_row"),
                  A = D.querySelector(".gantt_resource_amount_input");
                if ((D.setAttribute("data-checked", E.checked), E.checked)) {
                  T.nodeName.toLowerCase() === "select" &&
                    t.callEvent("onResourcesSelectActivated", [{ target: T }]);
                  var I = C,
                    M = b.default_value;
                  b.options.forEach(function (L) {
                    L.key == I && L.default_value && (M = L.default_value);
                  }),
                    A &&
                      !A.value &&
                      M !== void 0 &&
                      ((A.value = M), k(b, this)),
                    A.select ? A.select() : A.focus && A.focus();
                } else
                  e.resourcesValues[b.id] && delete e.resourcesValues[b.id][C];
              } else
                (S.target.type !== "text" &&
                  S.target.nodeName.toLowerCase() !== "select") ||
                  (E.parentNode.parentNode, (T = S.target), k(b, this));
            }
            function k(S, T) {
              var E = r(),
                C = T.querySelectorAll(E);
              e.resourcesValues[S.id] = e.resourcesValues[S.id] || {};
              for (var D = 0; D < C.length; D++) {
                var A = C[D].getAttribute("data-item-id"),
                  I = C[D].getAttribute("data-assignment-id");
                C[D].disabled
                  ? delete e.resourcesValues[S.id][A]
                  : (e.resourcesValues[S.id][A] = { value: C[D].value, id: I });
              }
            }
            (w = m),
              (x = 100),
              ($ = !1),
              (m = function () {
                $ ||
                  (w.apply(null, arguments),
                  ($ = !0),
                  setTimeout(function () {
                    $ = !1;
                  }, x));
              }),
              o(b).container.addEventListener("keyup", m),
              o(b).container.addEventListener("input", m, !0),
              o(b).container.addEventListener("change", m, !0),
              s(b).addEventListener("input", p),
              s(b).addEventListener("change", p),
              t.attachEvent("onResourcesSelectActivated", t.bind(p, s(b))),
              (e.eventsInitialized[b.id] = !0);
            var w, x, $;
          })(l, c, u, this),
          st(u.options, function (y, v) {
            u.unassigned_value != y.key &&
              ((h = (function (b, g, m) {
                var p = {};
                if (g) {
                  var k;
                  Lt(g)
                    ? (k = fe(g, function (w) {
                        return w.resource_id == m.key;
                      }))
                    : g.resource_id == m.key && (k = g),
                    k && ((p.value = k.value), (p.id = k.id));
                }
                return (
                  e.resourcesValues[b.id] &&
                    e.resourcesValues[b.id][m.key] &&
                    ((p.value = e.resourcesValues[b.id][m.key].value),
                    (p.id = e.resourcesValues[b.id][m.key].id)),
                  p
                );
              })(u, d, y)),
              (f += [
                "<label class='gantt_resource_row' data-item-id='" +
                  y.key +
                  "' data-checked=" +
                  (h.value ? "true" : "false") +
                  ">",
                "<input class='gantt_resource_toggle' type='checkbox'",
                h.value ? " checked='checked'" : "",
                "><div class='gantt_resource_cell gantt_resource_cell_checkbox'><span class='matherial_checkbox_icon'></span></div>",
                "<div class='gantt_resource_cell gantt_resource_cell_label'>",
                y.label,
                "</div>",
                "<div class='gantt_resource_cell gantt_resource_cell_value'>",
                a(y, h.value, !h.value, h.id),
                "</div>",
                "<div class='gantt_resource_cell gantt_resource_cell_unit'>",
                y.unit,
                "</div>",
                "</label>",
              ].join("")));
          }),
          (_.innerHTML = f),
          (_.style.zoom = "1"),
          (_._offsetSizes = _.offsetHeight),
          (_.style.zoom = ""),
          t._center_lightbox(t.getLightbox());
      }),
      (i.prototype.get_value = function (l, d, c) {
        for (
          var u = s(c),
            h = [],
            _ = r(!0),
            f = r(!1),
            y = o(c),
            v = t.copy(e.resourcesValues[c.id]) || {},
            b = u.querySelectorAll(_),
            g = u.querySelectorAll(f),
            m = 0;
          m < g.length;
          m++
        )
          delete v[g[m].getAttribute("data-item-id")];
        for (m = 0; m < b.length; m++) {
          var p = b[m].getAttribute("data-assignment-id"),
            k = b[m].getAttribute("data-item-id"),
            w = b[m].value.trim();
          w !== "" &&
            w !== "0" &&
            (delete v[k],
            (h[h.length] = { resource_id: k, value: w }),
            p && (h[h.length - 1] = { ...h[h.length - 1], id: p }));
        }
        if (y.filterApplied)
          for (var x in v)
            h[h.length] = { resource_id: x, value: v[x].value, id: v[x].id };
        return h;
      }),
      (i.prototype.focus = function (l) {
        t._focus(l.querySelector(".gantt_resources"));
      }),
      i
    );
  }
  function Br(t) {
    var n = (function () {
        const g = pt();
        function m() {
          return g.apply(this, arguments) || this;
        }
        return (
          W(m, g),
          (m.prototype.render = function (p) {
            let k = p.height ? `${p.height}px` : "";
            return `<div class='gantt_cal_ltext gantt_cal_template gantt_section_${
              p.name
            }' ${k ? `style='height:${k};'` : ""}></div>`;
          }),
          (m.prototype.set_value = function (p, k) {
            p.innerHTML = k || "";
          }),
          (m.prototype.get_value = function (p) {
            return p.innerHTML || "";
          }),
          (m.prototype.focus = function () {}),
          m
        );
      })(),
      e = (function (g) {
        const m = pt();
        function p() {
          return m.apply(this, arguments) || this;
        }
        return (
          W(p, m),
          (p.prototype.render = function (k) {
            const w = (k.height || "130") + "px",
              x = k.placeholder ? `placeholder='${k.placeholder}'` : "";
            return `<div class='gantt_cal_ltext gantt_section_${k.name}' style='height:${w};' ${x}><textarea></textarea></div>`;
          }),
          (p.prototype.set_value = function (k, w) {
            g.form_blocks.textarea._get_input(k).value = w || "";
          }),
          (p.prototype.get_value = function (k) {
            return g.form_blocks.textarea._get_input(k).value;
          }),
          (p.prototype.focus = function (k) {
            var w = g.form_blocks.textarea._get_input(k);
            g._focus(w, !0);
          }),
          (p.prototype._get_input = function (k) {
            return k.querySelector("textarea");
          }),
          p
        );
      })(t),
      i = (function (g) {
        const m = pt();
        function p() {
          return m.apply(this, arguments) || this;
        }
        return (
          W(p, m),
          (p.prototype.render = function (k) {
            var w = g.form_blocks.getTimePicker.call(this, k);
            let x = "gantt_section_time";
            k.name !== "time" && (x += " gantt_section_" + k.name);
            var $ =
              "<div style='padding-top:0px;font-size:inherit;text-align:center;' class='" +
              x +
              "'>";
            return (
              ($ += w),
              k.single_date
                ? ((w = g.form_blocks.getTimePicker.call(this, k, !0)),
                  ($ += "<span></span>"))
                : ($ +=
                    "<span class='gantt_section_time_spacer'> &nbsp;&ndash;&nbsp; </span>"),
              ($ += w) + "</div>"
            );
          }),
          (p.prototype.set_value = function (k, w, x, $) {
            var S = $,
              T = k.getElementsByTagName("select"),
              E = $._time_format_order;
            if (S.auto_end_date)
              for (
                var C = function () {
                    (I = new Date(
                      T[E[2]].value,
                      T[E[1]].value,
                      T[E[0]].value,
                      0,
                      0
                    )),
                      (M = g.calculateEndDate({
                        start_date: I,
                        duration: 1,
                        task: x,
                      })),
                      g.form_blocks._fill_lightbox_select(T, E.size, M, E, S);
                  },
                  D = 0;
                D < 4;
                D++
              )
                T[D].onchange = C;
            var A = g._resolve_default_mapping($);
            typeof A == "string" && (A = { start_date: A });
            var I = x[A.start_date] || new Date(),
              M =
                x[A.end_date] ||
                g.calculateEndDate({ start_date: I, duration: 1, task: x });
            g.form_blocks._fill_lightbox_select(T, 0, I, E, S),
              g.form_blocks._fill_lightbox_select(T, E.size, M, E, S);
          }),
          (p.prototype.get_value = function (k, w, x) {
            var $,
              S = k.getElementsByTagName("select"),
              T = x._time_format_order;
            return (
              ($ = g.form_blocks.getTimePickerValue(S, x)),
              typeof g._resolve_default_mapping(x) == "string"
                ? $
                : {
                    start_date: $,
                    end_date: (function (E, C, D) {
                      var A = g.form_blocks.getTimePickerValue(E, x, C.size);
                      return A <= D && (x.autofix_end !== !1 || x.single_date)
                        ? g.date.add(D, g._get_timepicker_step(), "minute")
                        : A;
                    })(S, T, $),
                  }
            );
          }),
          (p.prototype.focus = function (k) {
            g._focus(k.getElementsByTagName("select")[0]);
          }),
          p
        );
      })(t),
      a = Ze(t),
      r = (function (g) {
        var m = pt();
        function p() {
          return m.apply(this, arguments) || this;
        }
        return (
          W(p, m),
          (p.prototype.render = function (k) {
            const w = k.height ? `height:${k.height}px;` : "";
            let x = `<div class='gantt_cal_ltext gantt_cal_lcheckbox gantt_section_${
              k.name
            }' ${w ? `style='${w}'` : ""}>`;
            if (k.options && k.options.length)
              for (var $ = 0; $ < k.options.length; $++)
                x +=
                  "<label><input type='checkbox' value='" +
                  k.options[$].key +
                  "' name='" +
                  k.name +
                  "'>" +
                  k.options[$].label +
                  "</label>";
            else
              (k.single_value = !0),
                (x +=
                  "<label><input type='checkbox' name='" +
                  k.name +
                  "'></label>");
            return (x += "</div>"), x;
          }),
          (p.prototype.set_value = function (k, w, x, $) {
            var S = Array.prototype.slice.call(
              k.querySelectorAll("input[type=checkbox]")
            );
            !k._dhx_onchange &&
              $.onchange &&
              ((k.onchange = $.onchange), (k._dhx_onchange = !0)),
              $.single_value
                ? (S[0].checked = !!w)
                : st(S, function (T) {
                    T.checked = !!w && w.indexOf(T.value) >= 0;
                  });
          }),
          (p.prototype.get_value = function (k, w, x) {
            return x.single_value
              ? k.querySelector("input[type=checkbox]").checked
              : (function ($, S) {
                  if ($.map) return $.map(S);
                  for (var T = $.slice(), E = [], C = 0; C < T.length; C++)
                    E.push(S(T[C], C));
                  return E;
                })(
                  Array.prototype.slice.call(
                    k.querySelectorAll("input[type=checkbox]:checked")
                  ),
                  function ($) {
                    return $.value;
                  }
                );
          }),
          (p.prototype.focus = function (k) {
            g._focus(k.querySelector("input[type=checkbox]"));
          }),
          p
        );
      })(t),
      s = (function (g) {
        const m = pt();
        function p() {
          return m.apply(this, arguments) || this;
        }
        return (
          W(p, m),
          (p.prototype.render = function (k) {
            const w = k.height ? `${k.height}px` : "";
            let x = `<div class='gantt_cal_ltext gantt_cal_lradio gantt_section_${
              k.name
            }' ${w ? `style='height:${w};'` : ""}>`;
            if (k.options && k.options.length)
              for (var $ = 0; $ < k.options.length; $++)
                x +=
                  "<label><input type='radio' value='" +
                  k.options[$].key +
                  "' name='" +
                  k.name +
                  "'>" +
                  k.options[$].label +
                  "</label>";
            return (x += "</div>"), x;
          }),
          (p.prototype.set_value = function (k, w, x, $) {
            var S;
            $.options &&
              $.options.length &&
              (S =
                k.querySelector("input[type=radio][value='" + w + "']") ||
                k.querySelector(
                  "input[type=radio][value='" + $.default_value + "']"
                )) &&
              (!k._dhx_onchange &&
                $.onchange &&
                ((k.onchange = $.onchange), (k._dhx_onchange = !0)),
              (S.checked = !0));
          }),
          (p.prototype.get_value = function (k, w) {
            var x = k.querySelector("input[type=radio]:checked");
            return x ? x.value : "";
          }),
          (p.prototype.focus = function (k) {
            g._focus(k.querySelector("input[type=radio]"));
          }),
          p
        );
      })(t),
      o = (function (g) {
        var m = pt();
        function p() {
          return m.apply(this, arguments) || this;
        }
        function k($) {
          return $.formatter || new oe();
        }
        function w($, S) {
          var T = $.getElementsByTagName("select"),
            E = S._time_format_order,
            C = 0,
            D = 0;
          if (g.defined(E[3])) {
            var A = T[E[3]],
              I = parseInt(A.value, 10);
            isNaN(I) &&
              A.hasAttribute("data-value") &&
              (I = parseInt(A.getAttribute("data-value"), 10)),
              (C = Math.floor(I / 60)),
              (D = I % 60);
          }
          return new Date(T[E[2]].value, T[E[1]].value, T[E[0]].value, C, D);
        }
        function x($, S) {
          var T = $.getElementsByTagName("input")[1];
          return (
            ((T = k(S).parse(T.value)) && !window.isNaN(T)) || (T = 1),
            T < 0 && (T *= -1),
            T
          );
        }
        return (
          W(p, m),
          (p.prototype.render = function ($) {
            var S =
                "<div class='gantt_time_selects'>" +
                g.form_blocks.getTimePicker.call(this, $) +
                "</div>",
              T = " " + g.locale.labels[g.config.duration_unit + "s"] + " ",
              E = $.single_date ? " style='display:none'" : "",
              C = $.readonly ? " disabled='disabled'" : "",
              D = g._waiAria.lightboxDurationInputAttrString($),
              A = "gantt_duration_value";
            $.formatter && ((T = ""), (A += " gantt_duration_value_formatted"));
            var I =
              "<div class='gantt_duration' " +
              E +
              "><div class='gantt_duration_inputs'><input type='button' class='gantt_duration_dec' value=''" +
              C +
              "><input type='text' value='5days' class='" +
              A +
              "'" +
              C +
              " " +
              D +
              "><input type='button' class='gantt_duration_inc' value='+'" +
              C +
              "></div><div class='gantt_duration_end_date'>" +
              T +
              "<span></span></div></div></div>";
            let M = "gantt_section_time gantt_section_duration";
            return (
              $.name !== "time" && (M += " gantt_section_" + $.name),
              "<div style='padding-top:0px;font-size:inherit;' class='" +
                M +
                "'>" +
                S +
                " " +
                I +
                "</div>"
            );
          }),
          (p.prototype.set_value = function ($, S, T, E) {
            var C,
              D,
              A,
              I,
              M = $.getElementsByTagName("select"),
              L = $.getElementsByTagName("input"),
              N = L[1],
              P = [L[0], L[2]],
              R = $.getElementsByTagName("span")[0],
              B = E._time_format_order;
            function H() {
              var G = w.call(g, $, E),
                j = x.call(g, $, E),
                _t = g.calculateEndDate({
                  start_date: G,
                  duration: j,
                  task: T,
                }),
                yt = g.templates.task_end_date || g.templates.task_date;
              R.innerHTML = yt(_t);
            }
            function F(G) {
              var j = N.value;
              (j = k(E).parse(j)),
                window.isNaN(j) && (j = 0),
                (j += G) < 1 && (j = 1),
                (N.value = k(E).format(j)),
                H();
            }
            (P[0].onclick = g.bind(function () {
              F(-1 * g.config.duration_step);
            }, this)),
              (P[1].onclick = g.bind(function () {
                F(1 * g.config.duration_step);
              }, this)),
              (M[0].onchange = H),
              (M[1].onchange = H),
              (M[2].onchange = H),
              M[3] && (M[3].onchange = H),
              (N.onkeydown = g.bind(function (G) {
                var j;
                return (j =
                  (G = G || window.event).charCode || G.keyCode || G.which) ==
                  g.constants.KEY_CODES.DOWN
                  ? (F(-1 * g.config.duration_step), !1)
                  : j == g.constants.KEY_CODES.UP
                  ? (F(1 * g.config.duration_step), !1)
                  : void window.setTimeout(H, 1);
              }, this)),
              (N.onchange = g.bind(H, this)),
              typeof (C = g._resolve_default_mapping(E)) == "string" &&
                (C = { start_date: C }),
              (D = T[C.start_date] || new Date()),
              (A =
                T[C.end_date] ||
                g.calculateEndDate({ start_date: D, duration: 1, task: T })),
              (I =
                Math.round(T[C.duration]) ||
                g.calculateDuration({ start_date: D, end_date: A, task: T })),
              (I = k(E).format(I)),
              g.form_blocks._fill_lightbox_select(M, 0, D, B, E),
              (N.value = I),
              H();
          }),
          (p.prototype.get_value = function ($, S, T) {
            var E = w($, T),
              C = x($, T),
              D = g.calculateEndDate({ start_date: E, duration: C, task: S });
            return typeof g._resolve_default_mapping(T) == "string"
              ? E
              : { start_date: E, end_date: D, duration: C };
          }),
          (p.prototype.focus = function ($) {
            g._focus($.getElementsByTagName("select")[0]);
          }),
          p
        );
      })(t),
      l = Hr(t),
      d = Or(t),
      c = (function (g) {
        var m = pt();
        function p() {
          return m.apply(this, arguments) || this;
        }
        function k(x) {
          return (
            !x ||
            x === g.config.constraint_types.ASAP ||
            x === g.config.constraint_types.ALAP
          );
        }
        function w(x, $) {
          for (var S = k($), T = 0; T < x.length; T++) x[T].disabled = S;
        }
        return (
          W(p, m),
          (p.prototype.render = function (x) {
            const $ = x.height ? `height:${x.height}px;` : "";
            let S = `<div class='gantt_cal_ltext gantt_section_${x.name}' ${
              $ ? `style='${$}'` : ""
            }>`;
            var T = [];
            for (var E in g.config.constraint_types)
              T.push({
                key: g.config.constraint_types[E],
                label: g.locale.labels[g.config.constraint_types[E]],
              });
            return (
              (x.options = x.options || T),
              (S +=
                "<span data-constraint-type-select>" +
                se.getHtmlSelect(x.options, [
                  { key: "data-type", value: "constraint-type" },
                ]) +
                "</span>"),
              (S +=
                "<label data-constraint-time-select>" +
                (g.locale.labels.constraint_date || "Constraint date") +
                ": " +
                g.form_blocks.getTimePicker.call(this, x) +
                "</label>"),
              (S += "</div>"),
              S
            );
          }),
          (p.prototype.set_value = function (x, $, S, T) {
            var E = x.querySelector("[data-constraint-type-select] select"),
              C = x.querySelectorAll("[data-constraint-time-select] select"),
              D = T._time_format_order,
              A = g._resolve_default_mapping(T);
            E._eventsInitialized ||
              (E.addEventListener("change", function (L) {
                w(C, L.target.value);
              }),
              (E._eventsInitialized = !0));
            var I = S[A.constraint_date] || new Date();
            g.form_blocks._fill_lightbox_select(C, 0, I, D, T);
            var M = S[A.constraint_type] || g.getConstraintType(S);
            (E.value = M), w(C, M);
          }),
          (p.prototype.get_value = function (x, $, S) {
            var T = x.querySelector("[data-constraint-type-select] select"),
              E = x.querySelectorAll("[data-constraint-time-select] select"),
              C = T.value,
              D = null;
            return (
              k(C) || (D = g.form_blocks.getTimePickerValue(E, S)),
              { constraint_type: C, constraint_date: D }
            );
          }),
          (p.prototype.focus = function (x) {
            g._focus(x.querySelector("select"));
          }),
          p
        );
      })(t),
      u = (function (g) {
        const m = Ze(g);
        function p() {
          return m.apply(this, arguments) || this;
        }
        return (
          W(p, m),
          (p.prototype.render = function (k) {
            var w = g.config.types,
              x = g.locale.labels,
              $ = [],
              S =
                k.filter ||
                function (C, D) {
                  return !w.placeholder || D !== w.placeholder;
                };
            for (var T in w)
              !S(T, w[T]) == 0 && $.push({ key: w[T], label: x["type_" + T] });
            k.options = $;
            var E = k.onchange;
            return (
              (k.onchange = function () {
                (g._lightbox_current_type = this.value),
                  g.changeLightboxType(this.value),
                  typeof E == "function" && E.apply(this, arguments);
              }),
              m.prototype.render.apply(this, arguments)
            );
          }),
          p
        );
      })(t),
      h = (function (g) {
        var m = pt();
        function p() {
          return m.apply(this, arguments) || this;
        }
        function k(S) {
          return S.formatter || new oe();
        }
        function w(S, T, E, C) {
          const D =
            "<div class='gantt_time_selects'>" +
            g.form_blocks.getTimePicker.call(g, C) +
            "</div>";
          let A = " " + g.locale.labels[g.config.duration_unit + "s"] + " ";
          const I = C.single_date ? " style='display:none'" : "",
            M = C.readonly ? " disabled='disabled'" : "",
            L = g._waiAria.lightboxDurationInputAttrString(C),
            N = g.locale.labels.baselines_remove_button;
          let P = "gantt_duration_value";
          C.formatter && ((A = ""), (P += " gantt_duration_value_formatted"));
          const R =
              "<div class='gantt_duration' " +
              I +
              "><div class='gantt_duration_inputs'><input type='button' class='gantt_duration_dec' value=''" +
              M +
              "><input type='text' value='5days' class='" +
              P +
              "'" +
              M +
              " " +
              L +
              "><input type='button' class='gantt_duration_inc' value='+'" +
              M +
              "></div><div class='gantt_duration_end_date'>" +
              A +
              "<span></span></div></div></div>",
            B = `<div><div class='baseline_delete_button gantt_custom_button'>${N}</div></div>`,
            H = document.createElement("div");
          (H.className = "gantt_section_time gantt_section_duration"),
            H.setAttribute("data-baseline-id", T.id),
            (H.innerHTML = D + R + B + "<br>"),
            S.appendChild(H);
          var F,
            G,
            j,
            _t = H.getElementsByTagName("select"),
            yt = H.getElementsByTagName("input"),
            q = yt[1],
            At = [yt[0], yt[2]],
            Yt = H.getElementsByTagName("span")[0],
            Mt = C._time_format_order;
          function wt() {
            var bt = x.call(g, H, C),
              Z = $.call(g, H, C),
              Fr = g.calculateEndDate({ start_date: bt, duration: Z, task: E }),
              Wr = g.templates.task_end_date || g.templates.task_date;
            Yt.innerHTML = Wr(Fr);
          }
          function ge(bt) {
            var Z = q.value;
            (Z = k(C).parse(Z)),
              window.isNaN(Z) && (Z = 0),
              (Z += bt) < 1 && (Z = 1),
              (q.value = k(C).format(Z)),
              wt();
          }
          (H.querySelector(".baseline_delete_button").onclick = function (bt) {
            const Z = H.parentNode;
            (H.innerHTML = ""),
              H.remove(),
              Z.innerHTML === "" &&
                (Z.innerHTML = g.locale.labels.baselines_section_placeholder);
          }),
            (At[0].onclick = g.bind(function () {
              ge(-1 * g.config.duration_step);
            }, g)),
            (At[1].onclick = g.bind(function () {
              ge(1 * g.config.duration_step);
            }, g)),
            (_t[0].onchange = wt),
            (_t[1].onchange = wt),
            (_t[2].onchange = wt),
            _t[3] && (_t[3].onchange = wt),
            (q.onkeydown = g.bind(function (bt) {
              var Z;
              return (Z =
                (bt = bt || window.event).charCode || bt.keyCode || bt.which) ==
                g.constants.KEY_CODES.DOWN
                ? (ge(-1 * g.config.duration_step), !1)
                : Z == g.constants.KEY_CODES.UP
                ? (ge(1 * g.config.duration_step), !1)
                : void window.setTimeout(wt, 1);
            }, g)),
            (q.onchange = g.bind(wt, g)),
            g._resolve_default_mapping(C),
            (F = T.start_date || new Date()),
            (G =
              T.end_date ||
              g.calculateEndDate({ start_date: F, duration: 1, task: E })),
            (j = g.calculateDuration({ start_date: F, end_date: G, task: E })),
            (j = k(C).format(j)),
            g.form_blocks._fill_lightbox_select(_t, 0, F, Mt, C),
            (q.value = j),
            wt();
        }
        function x(S, T) {
          var E = S.getElementsByTagName("select"),
            C = T._time_format_order,
            D = 0,
            A = 0;
          if (g.defined(C[3])) {
            var I = E[C[3]],
              M = parseInt(I.value, 10);
            isNaN(M) &&
              I.hasAttribute("data-value") &&
              (M = parseInt(I.getAttribute("data-value"), 10)),
              (D = Math.floor(M / 60)),
              (A = M % 60);
          }
          return new Date(E[C[2]].value, E[C[1]].value, E[C[0]].value, D, A);
        }
        function $(S, T) {
          var E = S.getElementsByTagName("input")[1];
          return (
            ((E = k(T).parse(E.value)) && !window.isNaN(E)) || (E = 1),
            E < 0 && (E *= -1),
            E
          );
        }
        return (
          W(p, m),
          (p.prototype.render = function (S) {
            return `<div style='height: ${
              S.height || 100
            }px; padding-top:0px; font-size:inherit;' class='gantt_section_baselines'></div>`;
          }),
          (p.prototype.set_value = function (S, T, E, C) {
            E.baselines
              ? ((S.innerHTML = ""),
                E.baselines.forEach((D) => {
                  w(S, D, E, C);
                }))
              : (S.innerHTML = g.locale.labels.baselines_section_placeholder);
          }),
          (p.prototype.get_value = function (S, T, E) {
            const C = [];
            return (
              S.querySelectorAll("[data-baseline-id]").forEach((D) => {
                const A = D.dataset.baselineId;
                let I,
                  M = g.getDatastore("baselines").getItem(A);
                (I = M
                  ? g.copy(M)
                  : { id: g.uid(), task_id: T.id, text: "Baseline 1" }),
                  (I.start_date = x(D, E)),
                  (I.duration = $(D, E)),
                  (I.end_date = g.calculateEndDate({
                    start_date: I.start_date,
                    duration: I.duration,
                    task: T,
                  })),
                  C.push(I);
              }),
              C
            );
          }),
          (p.prototype.button_click = function (S, T, E, C) {
            if (
              g.callEvent("onSectionButton", [g._lightbox_id, E]) !== !1 &&
              (T.closest(".gantt_custom_button.gantt_remove_baselines") &&
                (C.innerHTML = g.locale.labels.baselines_section_placeholder),
              T.closest(".gantt_custom_button.gantt_add_baselines"))
            ) {
              C.innerHTML == g.locale.labels.baselines_section_placeholder &&
                (C.innerHTML = "");
              const D = g.getTask(g._lightbox_id);
              w(
                C,
                {
                  id: g.uid(),
                  task_id: D.id,
                  start_date: D.start_date,
                  end_date: D.end_date,
                },
                D,
                g._get_typed_lightbox_config()[S]
              );
            }
          }),
          (p.prototype.focus = function (S) {
            g._focus(S.getElementsByTagName("select")[0]);
          }),
          p
        );
      })(t);
    (t._lightbox_methods = {}),
      (t._lightbox_template =
        "<div class='gantt_cal_ltitle'><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='gantt_title'></span></div><div class='gantt_cal_larea'></div>"),
      (t._lightbox_template = `<div class='gantt_cal_ltitle'><div class="dhx_cal_ltitle_descr"><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='dhx_title'></span>
</div>
<div class="gantt_cal_ltitle_controls">
	<a class="gantt_cal_ltitle_close_btn dhx_gantt_icon dhx_gantt_icon_close"></a>

</div></div><div class='gantt_cal_larea'></div>`),
      (t._lightbox_root = t.$root),
      t.$services.getService("state").registerProvider("lightbox", function () {
        return { lightbox: t._lightbox_id };
      }),
      (t.showLightbox = function (g) {
        var m = this.getTask(g);
        if (this.callEvent("onBeforeLightbox", [g])) {
          var p = this.getLightbox(this.getTaskType(m.type));
          this.showCover(p),
            this._fill_lightbox(g, p),
            this._setLbPosition(p),
            this._waiAria.lightboxVisibleAttr(p),
            this.callEvent("onLightbox", [g]);
        } else
          t.isTaskExists(g) &&
            t.getTask(g).$new &&
            this.$data.tasksStore._updateOrder();
      }),
      (t._get_timepicker_step = function () {
        if (this.config.round_dnd_dates) {
          var g;
          if (
            (function (p) {
              var k = p.$ui.getView("timeline");
              return !(!k || !k.isVisible());
            })(this)
          ) {
            var m = t.getScale();
            g = (Jt(m.unit) * m.step) / 60;
          }
          return (!g || g >= 1440) && (g = this.config.time_step), g;
        }
        return this.config.time_step;
      }),
      (t.getLabel = function (g, m) {
        for (
          var p = this._get_typed_lightbox_config(), k = 0;
          k < p.length;
          k++
        )
          if (p[k].map_to == g) {
            for (var w = p[k].options, x = 0; x < w.length; x++)
              if (w[x].key == m) return w[x].label;
          }
        return "";
      }),
      (t.updateCollection = function (g, m) {
        m = m.slice(0);
        var p = t.serverList(g);
        if (!p) return !1;
        p.splice(0, p.length), p.push.apply(p, m || []), t.resetLightbox();
      }),
      (t.getLightboxType = function () {
        return this.getTaskType(this._lightbox_type);
      }),
      (t.getLightbox = function (g) {
        var m,
          p,
          k,
          w,
          x,
          $ = "";
        if (
          (t.config.csp === !0 || t.env.isSalesforce
            ? (t._lightbox_root = t.$root)
            : (t._lightbox_root = document.body),
          g === void 0 && (g = this.getLightboxType()),
          !this._lightbox || this.getLightboxType() != this.getTaskType(g))
        ) {
          (this._lightbox_type = this.getTaskType(g)),
            (m = document.createElement("div")),
            ($ = "gantt_cal_light"),
            (p = this._is_lightbox_timepicker()),
            t.config.wide_form && ($ += " gantt_cal_light_wide"),
            p && ($ += " gantt_cal_light_full"),
            (m.className = $),
            (m.style.visibility = "hidden"),
            (k = this._lightbox_template),
            (k += "<div class='gantt_cal_lcontrols'>"),
            (k += y(this.config.buttons_left)),
            (k += "<div class='gantt_cal_lcontrols_push_right'></div>"),
            (k += y(this.config.buttons_right)),
            (k += "</div>"),
            (m.innerHTML = k),
            t._waiAria.lightboxAttr(m),
            t.config.drag_lightbox &&
              ((m.firstChild.onmousedown = t._ready_to_dnd),
              (m.firstChild.ontouchstart = function (T) {
                t._ready_to_dnd(T.touches[0]);
              }),
              (m.firstChild.onselectstart = function () {
                return !1;
              }),
              (m.firstChild.style.cursor = "pointer"),
              t._init_dnd_events()),
            this._lightbox && this.resetLightbox(),
            _(),
            this._cover.insertBefore(m, this._cover.firstChild),
            (this._lightbox = m),
            (w = this._get_typed_lightbox_config(g)),
            (k = this._render_sections(w));
          var S = (x = m.querySelector("div.gantt_cal_larea")).style.overflow;
          (x.style.overflow = "hidden"),
            (x.innerHTML = k),
            (function (T) {
              var E, C, D, A, I, M;
              for (M = 0; M < T.length; M++)
                (E = T[M]),
                  (D = t._lightbox_root.querySelector("#" + E.id)),
                  E.id &&
                    D &&
                    ((C = D.querySelector("label")),
                    (A = D.nextSibling) &&
                      (I = A.querySelector("input, select, textarea")) &&
                      ((I.id = I.id || "input_" + t.uid()),
                      (E.inputId = I.id),
                      C.setAttribute("for", E.inputId)));
            })(w),
            (x.style.overflow = S),
            this._init_lightbox_events(this),
            (m.style.display = "none"),
            (m.style.visibility = "visible");
        }
        return this._lightbox;
      }),
      (t._render_sections = function (g) {
        for (var m = "", p = 0; p < g.length; p++) {
          var k = this.form_blocks[g[p].type];
          if (k) {
            g[p].id = "area_" + this.uid();
            var w = g[p].hidden ? " style='display:none'" : "",
              x = "";
            g[p].button &&
              (x =
                "<div class='gantt_custom_button' data-index='" +
                p +
                "'><div class='gantt_custom_button_" +
                g[p].button +
                "'></div><div class='gantt_custom_button_label'>" +
                this.locale.labels["button_" + g[p].button] +
                "</div></div>"),
              g[p].type == "baselines" &&
                (x =
                  "<div class='gantt_custom_button gantt_remove_baselines' data-index='" +
                  p +
                  "'><div class='gantt_custom_button_delete_baselines'></div><div class='gantt_custom_button_label'>" +
                  this.locale.labels.baselines_remove_all_button +
                  "</div></div><div class='gantt_custom_button gantt_add_baselines' data-index='" +
                  p +
                  "'><div class='gantt_custom_button_add_baseline'></div><div class='gantt_custom_button_label'>" +
                  this.locale.labels.baselines_add_button +
                  "</div></div>"),
              this.config.wide_form &&
                (m += "<div class='gantt_wrap_section' " + w + ">"),
              (m +=
                "<div id='" +
                g[p].id +
                "' class='gantt_cal_lsection'><label>" +
                x +
                (g[p].label ||
                  this.locale.labels["section_" + g[p].name] ||
                  g[p].name) +
                "</label></div>" +
                k.render.call(this, g[p])),
              (m += "</div>");
          }
        }
        return m;
      }),
      (t._center_lightbox = function (g) {
        t._setLbPosition(g);
      }),
      (t._setLbPosition = function (g) {
        if (!g) return;
        const m = t._lightbox_root || t.$root;
        (g.style.top =
          Math.max(m.offsetHeight / 2 - g.offsetHeight / 2, 0) + "px"),
          (g.style.left =
            Math.max(m.offsetWidth / 2 - g.offsetWidth / 2, 0) + "px");
      }),
      (t.showCover = function (g) {
        g && ((g.style.display = "block"), this._setLbPosition(g)),
          _(),
          (this._cover.style.display = "");
      });
    const _ = function () {
      t._cover ||
        ((t._cover = document.createElement("div")),
        (t._cover.className = "gantt_cal_cover"),
        (t._cover.style.display = "none"),
        t.event(t._cover, "mousemove", t._move_while_dnd),
        t.event(t._cover, "mouseup", t._finish_dnd),
        (t._lightbox_root || t.$root).appendChild(t._cover));
    };
    function f(g) {
      for (var m in this.config.types) if (this.config.types[m] == g) return m;
      return "task";
    }
    function y(g, m) {
      var p,
        k,
        w = "";
      for (k = 0; k < g.length; k++)
        (p = t.config._migrate_buttons[g[k]]
          ? t.config._migrate_buttons[g[k]]
          : g[k]),
          (w +=
            "<div " +
            t._waiAria.lightboxButtonAttrString(p) +
            " class='gantt_btn_set gantt_left_btn_set " +
            p +
            "_set'><div dhx_button='1' data-dhx-button='1' class='" +
            p +
            "'></div><div>" +
            t.locale.labels[p] +
            "</div></div>");
      return w;
    }
    function v(g) {
      var m, p;
      return g.time_format
        ? g.time_format
        : ((p = ["%d", "%m", "%Y"]),
          Jt((m = t.getScale()) ? m.unit : t.config.duration_unit) <
            Jt("day") && p.push("%H:%i"),
          p);
    }
    function b(g, m, p) {
      var k,
        w,
        x,
        $,
        S,
        T,
        E = "";
      switch (p.timeFormat[m]) {
        case "%Y":
          for (
            g._time_format_order[2] = m,
              g._time_format_order.size++,
              g.year_range &&
                (isNaN(g.year_range)
                  ? g.year_range.push &&
                    ((x = g.year_range[0]), ($ = g.year_range[1]))
                  : (k = g.year_range)),
              k = k || 10,
              w = w || Math.floor(k / 2),
              x = x || p.date.getFullYear() - w,
              $ = $ || t.getState().max_date.getFullYear() + w,
              S = x;
            S <= $;
            S++
          )
            E += "<option value='" + S + "'>" + S + "</option>";
          break;
        case "%m":
          for (
            g._time_format_order[1] = m, g._time_format_order.size++, S = 0;
            S < 12;
            S++
          )
            E +=
              "<option value='" +
              S +
              "'>" +
              t.locale.date.month_full[S] +
              "</option>";
          break;
        case "%d":
          for (
            g._time_format_order[0] = m, g._time_format_order.size++, S = 1;
            S < 32;
            S++
          )
            E += "<option value='" + S + "'>" + S + "</option>";
          break;
        case "%H:%i":
          for (
            g._time_format_order[3] = m,
              g._time_format_order.size++,
              S = p.first,
              T = p.date.getDate(),
              g._time_values = [];
            S < p.last;

          )
            (E +=
              "<option value='" +
              S +
              "'>" +
              t.templates.time_picker(p.date) +
              "</option>"),
              g._time_values.push(S),
              p.date.setTime(
                p.date.valueOf() + 60 * t._get_timepicker_step() * 1e3
              ),
              (S =
                24 * (p.date.getDate() != T ? 1 : 0) * 60 +
                60 * p.date.getHours() +
                p.date.getMinutes());
      }
      return E;
    }
    (t._init_lightbox_events = function () {
      (t.lightbox_events = {}),
        (t.lightbox_events.gantt_save_btn = function () {
          t._save_lightbox();
        }),
        (t.lightbox_events.gantt_delete_btn = function () {
          (t._lightbox_current_type = null),
            t.callEvent("onLightboxDelete", [t._lightbox_id]) &&
              (t.isTaskExists(t._lightbox_id)
                ? t.$click.buttons.delete(t._lightbox_id)
                : t.hideLightbox());
        }),
        (t.lightbox_events.gantt_cancel_btn = function () {
          t._cancel_lightbox();
        }),
        (t.lightbox_events.default = function (g, m) {
          if (m.getAttribute("data-dhx-button"))
            t.callEvent("onLightboxButton", [m.className, m, g]);
          else {
            var p,
              k,
              w = it(m);
            if (w.indexOf("gantt_custom_button") != -1)
              if (w.indexOf("gantt_custom_button_") != -1)
                for (
                  p = m.parentNode.getAttribute("data-index"), k = m;
                  k && it(k).indexOf("gantt_cal_lsection") == -1;

                )
                  k = k.parentNode;
              else
                (p = m.getAttribute("data-index")),
                  (k = m.closest(".gantt_cal_lsection")),
                  (m = m.firstChild);
            var x = t._get_typed_lightbox_config();
            p &&
              ((p *= 1),
              t.form_blocks[x[1 * p].type].button_click(
                p,
                m,
                k,
                k.nextSibling
              ));
          }
        }),
        this.event(t.getLightbox(), "click", function (g) {
          g.target.closest(".gantt_cal_ltitle_close_btn") &&
            t._cancel_lightbox();
          var m = Et(g),
            p = it(m);
          return (
            p || (p = it((m = m.previousSibling))),
            m &&
              p &&
              p.indexOf("gantt_btn_set") === 0 &&
              (p = it((m = m.firstChild))),
            !(!m || !p) &&
              (t.defined(t.lightbox_events[m.className])
                ? t.lightbox_events[m.className]
                : t.lightbox_events.default)(g, m)
          );
        }),
        (t.getLightbox().onkeydown = function (g) {
          var m = g || window.event,
            p = g.target || g.srcElement,
            k = it(p).indexOf("gantt_btn_set") > -1;
          switch ((g || m).keyCode) {
            case t.constants.KEY_CODES.SPACE:
              if ((g || m).shiftKey) return;
              k && p.click && p.click();
              break;
            case t.keys.edit_save:
              if ((g || m).shiftKey) return;
              k && p.click ? p.click() : t._save_lightbox();
              break;
            case t.keys.edit_cancel:
              t._cancel_lightbox();
          }
        });
    }),
      (t._cancel_lightbox = function () {
        var g = this.getLightboxValues();
        (t._lightbox_current_type = null),
          this.callEvent("onLightboxCancel", [this._lightbox_id, g.$new]),
          t.isTaskExists(g.id) &&
            g.$new &&
            (this.silent(function () {
              t.$data.tasksStore.removeItem(g.id), t._update_flags(g.id, null);
            }),
            this.refreshData()),
          this.hideLightbox();
      }),
      (t._save_lightbox = function () {
        var g = this.getLightboxValues();
        (t._lightbox_current_type = null),
          this.callEvent("onLightboxSave", [this._lightbox_id, g, !!g.$new]) &&
            ((t.$data.tasksStore._skipTaskRecalculation = "lightbox"),
            g.$new
              ? (delete g.$new,
                this.addTask(g, g.parent, this.getTaskIndex(g.id)))
              : this.isTaskExists(g.id) &&
                (this.mixin(this.getTask(g.id), g, !0),
                this.refreshTask(g.id),
                this.updateTask(g.id)),
            (t.$data.tasksStore._skipTaskRecalculation = !1),
            this.refreshData(),
            this.hideLightbox());
      }),
      (t._resolve_default_mapping = function (g) {
        var m = g.map_to;
        return (
          { time: !0, time_optional: !0, duration: !0, duration_optional: !0 }[
            g.type
          ]
            ? g.map_to == "auto"
              ? (m = {
                  start_date: "start_date",
                  end_date: "end_date",
                  duration: "duration",
                })
              : typeof g.map_to == "string" && (m = { start_date: g.map_to })
            : g.type === "constraint" &&
              ((g.map_to && typeof g.map_to != "string") ||
                (m = {
                  constraint_type: "constraint_type",
                  constraint_date: "constraint_date",
                })),
          m
        );
      }),
      (t.getLightboxValues = function () {
        let g = {};
        t.isTaskExists(this._lightbox_id) &&
          (g = this.mixin({}, this.getTask(this._lightbox_id)));
        const m = [...this._get_typed_lightbox_config()].sort((p, k) =>
          p.name === "time" ? 1 : k.name === "time" ? -1 : 0
        );
        for (let p = 0; p < m.length; p++) {
          let k = t._lightbox_root.querySelector("#" + m[p].id);
          k = k && k.nextSibling;
          let w = this.form_blocks[m[p].type];
          if (!w) continue;
          let x = w.get_value.call(this, k, g, m[p]),
            $ = t._resolve_default_mapping(m[p]);
          if (typeof $ == "string" && $ != "auto") g[$] = x;
          else if (typeof $ == "object")
            for (let S in $) $[S] && (g[$[S]] = x[S]);
        }
        return (
          t._lightbox_current_type && (g.type = t._lightbox_current_type), g
        );
      }),
      (t.hideLightbox = function () {
        var g = this.getLightbox();
        g && (g.style.display = "none"),
          this._waiAria.lightboxHiddenAttr(g),
          (this._lightbox_id = null),
          this.hideCover(g),
          this.resetLightbox(),
          this.callEvent("onAfterLightbox", []);
      }),
      (t.hideCover = function (g) {
        g && (g.style.display = "none"),
          this._cover && this._cover.parentNode.removeChild(this._cover),
          (this._cover = null);
      }),
      (t.resetLightbox = function () {
        t._lightbox && !t._custom_lightbox && t._lightbox.remove(),
          (t._lightbox = null);
      }),
      (t._set_lightbox_values = function (g, m) {
        var p = g,
          k = m.getElementsByTagName("span"),
          w = [];
        t.templates.lightbox_header
          ? (w.push(""),
            w.push(t.templates.lightbox_header(p.start_date, p.end_date, p)),
            (k[1].innerHTML = ""),
            (k[2].innerHTML = t.templates.lightbox_header(
              p.start_date,
              p.end_date,
              p
            )))
          : (w.push(this.templates.task_time(p.start_date, p.end_date, p)),
            w.push(
              String(
                this.templates.task_text(p.start_date, p.end_date, p) || ""
              ).substr(0, 70)
            ),
            (k[1].innerHTML = this.templates.task_time(
              p.start_date,
              p.end_date,
              p
            )),
            (k[2].innerHTML = String(
              this.templates.task_text(p.start_date, p.end_date, p) || ""
            ).substr(0, 70))),
          (k[1].innerHTML = w[0]),
          (k[2].innerHTML = w[1]),
          t._waiAria.lightboxHeader(m, w.join(" "));
        for (
          var x = this._get_typed_lightbox_config(this.getLightboxType()),
            $ = 0;
          $ < x.length;
          $++
        ) {
          var S = x[$];
          if (this.form_blocks[S.type]) {
            var T = t._lightbox_root.querySelector("#" + S.id).nextSibling,
              E = this.form_blocks[S.type],
              C = t._resolve_default_mapping(x[$]),
              D = this.defined(p[C]) ? p[C] : S.default_value;
            E.set_value.call(t, T, D, p, S), S.focus && E.focus.call(t, T);
          }
        }
        t.isTaskExists(g.id) && (t._lightbox_id = g.id);
      }),
      (t._fill_lightbox = function (g, m) {
        var p = this.getTask(g);
        this._set_lightbox_values(p, m);
      }),
      (t.getLightboxSection = function (g) {
        for (
          var m = this._get_typed_lightbox_config(), p = 0;
          p < m.length && m[p].name != g;
          p++
        );
        var k = m[p];
        if (!k) return null;
        this._lightbox || this.getLightbox();
        var w = t._lightbox_root.querySelector("#" + k.id),
          x = w.nextSibling,
          $ = {
            section: k,
            header: w,
            node: x,
            getValue: function (T) {
              return t.form_blocks[k.type].get_value.call(t, x, T || {}, k);
            },
            setValue: function (T, E) {
              return t.form_blocks[k.type].set_value.call(t, x, T, E || {}, k);
            },
          },
          S = this._lightbox_methods["get_" + k.type + "_control"];
        return S ? S($) : $;
      }),
      (t._lightbox_methods.get_template_control = function (g) {
        return (g.control = g.node), g;
      }),
      (t._lightbox_methods.get_select_control = function (g) {
        return (g.control = g.node.getElementsByTagName("select")[0]), g;
      }),
      (t._lightbox_methods.get_textarea_control = function (g) {
        return (g.control = g.node.getElementsByTagName("textarea")[0]), g;
      }),
      (t._lightbox_methods.get_time_control = function (g) {
        return (g.control = g.node.getElementsByTagName("select")), g;
      }),
      (t._init_dnd_events = function () {
        var g = t._lightbox_root;
        this.event(g, "mousemove", t._move_while_dnd),
          this.event(g, "mouseup", t._finish_dnd),
          this.event(g, "touchmove", function (m) {
            t._move_while_dnd(m.touches[0]);
          }),
          this.event(g, "touchend", function (m) {
            t._finish_dnd(m.touches[0]);
          });
      }),
      (t._move_while_dnd = function (g) {
        if (t._dnd_start_lb) {
          document.gantt_unselectable ||
            ((t._lightbox_root.className += " gantt_unselectable"),
            (document.gantt_unselectable = !0));
          var m = t.getLightbox(),
            p = [g.pageX, g.pageY];
          (m.style.top = t._lb_start[1] + p[1] - t._dnd_start_lb[1] + "px"),
            (m.style.left = t._lb_start[0] + p[0] - t._dnd_start_lb[0] + "px");
        }
      }),
      (t._ready_to_dnd = function (g) {
        var m = t.getLightbox();
        (t._lb_start = [m.offsetLeft, m.offsetTop]),
          (t._dnd_start_lb = [g.pageX, g.pageY]);
      }),
      (t._finish_dnd = function () {
        t._lb_start &&
          ((t._lb_start = t._dnd_start_lb = !1),
          (t._lightbox_root.className = t._lightbox_root.className.replace(
            " gantt_unselectable",
            ""
          )),
          (document.gantt_unselectable = !1));
      }),
      (t._focus = function (g, m) {
        if (g && g.focus && !t.config.touch)
          try {
            m && g.select && g.select(), g.focus();
          } catch {}
      }),
      (t.form_blocks = {
        getTimePicker: function (g, m) {
          var p,
            k,
            w,
            x = "",
            $ = this.config,
            S = {
              first: 0,
              last: 1440,
              date: this.date.date_part(new Date(t._min_date.valueOf())),
              timeFormat: v(g),
            };
          for (
            g._time_format_order = { size: 0 },
              t.config.limit_time_select &&
                ((S.first = 60 * $.first_hour),
                (S.last = 60 * $.last_hour + 1),
                S.date.setHours($.first_hour)),
              p = 0;
            p < S.timeFormat.length;
            p++
          )
            p > 0 && (x += " "),
              (k = b(g, p, S)) &&
                ((w = t._waiAria.lightboxSelectAttrString(S.timeFormat[p])),
                (x +=
                  "<select " +
                  (g.readonly ? "disabled='disabled'" : "") +
                  (m ? " style='display:none' " : "") +
                  w +
                  ">" +
                  k +
                  "</select>"));
          return x;
        },
        getTimePickerValue: function (g, m, p) {
          var k,
            w = m._time_format_order,
            x = 0,
            $ = 0,
            S = p || 0;
          return (
            t.defined(w[3]) &&
              ((k = parseInt(g[w[3] + S].value, 10)),
              (x = Math.floor(k / 60)),
              ($ = k % 60)),
            new Date(
              g[w[2] + S].value,
              g[w[1] + S].value,
              g[w[0] + S].value,
              x,
              $
            )
          );
        },
        _fill_lightbox_select: function (g, m, p, k) {
          if (
            ((g[m + k[0]].value = p.getDate()),
            (g[m + k[1]].value = p.getMonth()),
            (g[m + k[2]].value = p.getFullYear()),
            t.defined(k[3]))
          ) {
            var w = 60 * p.getHours() + p.getMinutes();
            w =
              Math.round(w / t._get_timepicker_step()) *
              t._get_timepicker_step();
            var x = g[m + k[3]];
            (x.value = w), x.setAttribute("data-value", w);
          }
        },
        template: new n(),
        textarea: new e(),
        select: new a(),
        time: new i(),
        duration: new o(),
        parent: new l(),
        radio: new s(),
        checkbox: new r(),
        resources: new d(),
        constraint: new c(),
        baselines: new h(),
        typeselect: new u(),
      }),
      (t._is_lightbox_timepicker = function () {
        for (
          var g = this._get_typed_lightbox_config(), m = 0;
          m < g.length;
          m++
        )
          if (g[m].name == "time" && g[m].type == "time") return !0;
        return !1;
      }),
      (t._delete_task_confirm = function ({
        task: g,
        message: m,
        title: p,
        callback: k,
        ok: w,
      }) {
        t._simple_confirm(m, p, k, w);
      }),
      (t._delete_link_confirm = function ({
        link: g,
        message: m,
        title: p,
        callback: k,
        ok: w,
      }) {
        t._simple_confirm(m, p, k, w);
      }),
      (t._simple_confirm = function (g, m, p, k) {
        if (!g) return p();
        var w = { text: g };
        m && (w.title = m),
          k && (w.ok = k),
          p &&
            (w.callback = function (x) {
              x && p();
            }),
          t.confirm(w);
      }),
      (t._get_typed_lightbox_config = function (g) {
        g === void 0 && (g = this.getLightboxType());
        var m = f.call(this, g);
        return t.config.lightbox[m + "_sections"]
          ? t.config.lightbox[m + "_sections"]
          : t.config.lightbox.sections;
      }),
      (t._silent_redraw_lightbox = function (g) {
        var m = this.getLightboxType();
        if (this.getState().lightbox) {
          var p = this.getState().lightbox,
            k = this.getLightboxValues(),
            w = this.copy(this.getTask(p));
          this.resetLightbox();
          var x = this.mixin(w, k, !0),
            $ = this.getLightbox(g || void 0);
          this._set_lightbox_values(x, $), this.showCover($);
        } else this.resetLightbox(), this.getLightbox(g || void 0);
        this.callEvent("onLightboxChange", [m, this.getLightboxType()]);
      });
  }
  function zr(t) {
    if (!kt.isNode) {
      t.utils = { arrayFind: fe, dom: gn };
      var n = Se();
      (t.event = n.attach),
        (t.eventRemove = n.detach),
        (t._eventRemoveAll = n.detachAll),
        (t._createDomEventScope = n.extend),
        O(t, Oa(t));
      var e = Mr.init(t);
      (t.$ui = e.factory),
        (t.$ui.layers = e.render),
        (t.$mouseEvents = e.mouseEvents),
        t.$services.setService("mouseEvents", function () {
          return t.$mouseEvents;
        }),
        t.mixin(t, e.layersApi),
        t.$services.setService("layers", function () {
          return e.layersService;
        }),
        t.mixin(
          t,
          (function () {
            function i(u) {
              return u.$ui.getView("timeline");
            }
            function a(u) {
              return u.$ui.getView("grid");
            }
            function r(u) {
              var h = i(u);
              if (h && !h.$config.hidden) return h;
              var _ = a(u);
              return _ && !_.$config.hidden ? _ : null;
            }
            function s(u) {
              var h = null,
                _ = !1;
              return (
                [
                  ".gantt_drag_marker.gantt_grid_resize_area",
                  ".gantt_drag_marker .gantt_row.gantt_row_task",
                  ".gantt_drag_marker.gantt_grid_dnd_marker",
                ].forEach(function (f) {
                  _ = _ || !!document.querySelector(f);
                }),
                (h = _ ? a(u) : r(u)) ? l(u, h, "scrollY") : null
              );
            }
            function o(u) {
              var h = r(u);
              return h && h.id != "grid" ? l(u, h, "scrollX") : null;
            }
            function l(u, h, _) {
              var f = h.$config[_];
              return u.$ui.getView(f);
            }
            var d = "DEFAULT_VALUE";
            function c(u, h, _, f) {
              var y = u(this);
              return y && y.isVisible() ? y[h].apply(y, _) : f ? f() : d;
            }
            return {
              getColumnIndex: function (u) {
                var h = c.call(this, a, "getColumnIndex", [u]);
                return h === d ? 0 : h;
              },
              dateFromPos: function (u) {
                var h = c.call(
                  this,
                  i,
                  "dateFromPos",
                  Array.prototype.slice.call(arguments)
                );
                return h === d ? this.getState().min_date : h;
              },
              posFromDate: function (u) {
                var h = c.call(this, i, "posFromDate", [u]);
                return h === d ? 0 : h;
              },
              getRowTop: function (u) {
                var h = this,
                  _ = c.call(h, i, "getRowTop", [u], function () {
                    return c.call(h, a, "getRowTop", [u]);
                  });
                return _ === d ? 0 : _;
              },
              getTaskTop: function (u) {
                var h = this,
                  _ = c.call(h, i, "getItemTop", [u], function () {
                    return c.call(h, a, "getItemTop", [u]);
                  });
                return _ === d ? 0 : _;
              },
              getTaskPosition: function (u, h, _) {
                var f = c.call(this, i, "getItemPosition", [u, h, _]);
                return f === d
                  ? {
                      left: 0,
                      top: this.getTaskTop(u.id),
                      height: this.getTaskBarHeight(u.id),
                      width: 0,
                    }
                  : f;
              },
              getTaskBarHeight: function (u, h) {
                var _ = this,
                  f = c.call(_, i, "getBarHeight", [u, h], function () {
                    return c.call(_, a, "getItemHeight", [u]);
                  });
                return f === d ? 0 : f;
              },
              getTaskHeight: function (u) {
                var h = this,
                  _ = c.call(h, i, "getItemHeight", [u], function () {
                    return c.call(h, a, "getItemHeight", [u]);
                  });
                return _ === d ? 0 : _;
              },
              columnIndexByDate: function (u) {
                var h = c.call(this, i, "columnIndexByDate", [u]);
                return h === d ? 0 : h;
              },
              roundTaskDates: function () {
                c.call(this, i, "roundTaskDates", []);
              },
              getScale: function () {
                var u = c.call(this, i, "getScale", []);
                return u === d ? null : u;
              },
              getTaskNode: function (u) {
                var h = i(this);
                if (h && h.isVisible()) {
                  var _ = h._taskRenderer.rendered[u];
                  if (!_) {
                    var f = h.$config.item_attribute;
                    _ = h.$task_bars.querySelector("[" + f + "='" + u + "']");
                  }
                  return _ || null;
                }
                return null;
              },
              getLinkNode: function (u) {
                var h = i(this);
                return h.isVisible() ? h._linkRenderer.rendered[u] : null;
              },
              scrollTo: function (u, h) {
                var _ = s(this),
                  f = o(this),
                  y = { position: 0 },
                  v = { position: 0 };
                _ && (v = _.getScrollState()), f && (y = f.getScrollState());
                var b = f && 1 * u == u,
                  g = _ && 1 * h == h;
                if (b && g)
                  for (
                    var m = _._getLinkedViews(),
                      p = f._getLinkedViews(),
                      k = [],
                      w = 0;
                    w < m.length;
                    w++
                  )
                    for (var x = 0; x < p.length; x++)
                      m[w].$config.id &&
                        p[x].$config.id &&
                        m[w].$config.id === p[x].$config.id &&
                        k.push(m[w].$config.id);
                b &&
                  (k &&
                    k.forEach(
                      function (T) {
                        this.$ui.getView(T).$config.$skipSmartRenderOnScroll =
                          !0;
                      }.bind(this)
                    ),
                  f.scroll(u),
                  k &&
                    k.forEach(
                      function (T) {
                        this.$ui.getView(T).$config.$skipSmartRenderOnScroll =
                          !1;
                      }.bind(this)
                    )),
                  g && _.scroll(h);
                var $ = { position: 0 },
                  S = { position: 0 };
                _ && ($ = _.getScrollState()),
                  f && (S = f.getScrollState()),
                  this.callEvent("onGanttScroll", [
                    y.position,
                    v.position,
                    S.position,
                    $.position,
                  ]);
              },
              showDate: function (u) {
                var h = this.posFromDate(u),
                  _ = Math.max(h - this.config.task_scroll_offset, 0);
                this.scrollTo(_);
              },
              showTask: function (u) {
                var h = this.getTaskPosition(this.getTask(u)),
                  _ = h.left;
                this.config.rtl && (_ = h.left + h.width);
                var f,
                  y = Math.max(_ - this.config.task_scroll_offset, 0),
                  v = this._scroll_state().y;
                (f = v ? h.top - (v - this.getTaskBarHeight(u)) / 2 : h.top),
                  this.scrollTo(y, f);
                var b = a(this),
                  g = i(this);
                b &&
                  g &&
                  b.$config.scrollY != g.$config.scrollY &&
                  l(this, b, "scrollY").scrollTo(null, f);
              },
              _scroll_state: function () {
                var u = {
                    x: !1,
                    y: !1,
                    x_pos: 0,
                    y_pos: 0,
                    scroll_size: this.config.scroll_size + 1,
                    x_inner: 0,
                    y_inner: 0,
                  },
                  h = s(this),
                  _ = o(this);
                if (_) {
                  var f = _.getScrollState();
                  f.visible && ((u.x = f.size), (u.x_inner = f.scrollSize)),
                    (u.x_pos = f.position || 0);
                }
                if (h) {
                  var y = h.getScrollState();
                  y.visible && ((u.y = y.size), (u.y_inner = y.scrollSize)),
                    (u.y_pos = y.position || 0);
                }
                return u;
              },
              getScrollState: function () {
                var u = this._scroll_state();
                return {
                  x: u.x_pos,
                  y: u.y_pos,
                  inner_width: u.x,
                  inner_height: u.y,
                  width: u.x_inner,
                  height: u.y_inner,
                };
              },
              getLayoutView: function (u) {
                return this.$ui.getView(u);
              },
              scrollLayoutCell: function (u, h, _) {
                const f = this.$ui.getView(u);
                if (!f) return !1;
                if (h !== null) {
                  const y = this.$ui.getView(f.$config.scrollX);
                  y && y.scrollTo(h, null);
                }
                if (_ !== null) {
                  const y = this.$ui.getView(f.$config.scrollY);
                  y && y.scrollTo(null, _);
                }
              },
            };
          })()
        ),
        (function (i) {
          i.resetSkin ||
            ((i.resetSkin = function () {
              (this.skin = ""), Je(!0, this);
            }),
            (i.skins = {}),
            i.attachEvent("onGanttLayoutReady", function () {
              Je(!1, this), r();
            })),
            (i._addThemeClass = function () {
              document.documentElement.setAttribute("data-gantt-theme", i.skin);
            }),
            (i.setSkin = function (s) {
              const o = this.skin !== s;
              (this.skin = s),
                i._addThemeClass(),
                r(),
                i.$root && (Je(!o, i), this.render());
            });
          let a = null;
          function r() {
            const s = i.$root;
            a && clearInterval(a),
              s &&
                (a = setInterval(() => {
                  const o =
                    getComputedStyle(s).getPropertyValue("--dhx-gantt-theme");
                  o && o !== i.skin && i.setSkin(o);
                }, 100));
          }
          i.attachEvent("onDestroy", function () {
            clearInterval(a);
          });
        })(t),
        (function (i) {
          i.skins.skyblue = {
            config: {
              grid_width: 370,
              row_height: 27,
              bar_height_padding: 4,
              scale_height: 27,
              link_line_width: 1,
              link_arrow_size: 8,
              link_radius: 2,
              lightbox_additional_height: 75,
            },
            _second_column_width: 95,
            _third_column_width: 80,
          };
        })(t),
        (function (i) {
          i.skins.dark = {
            config: {
              grid_width: 390,
              row_height: 36,
              scale_height: 36,
              link_line_width: 2,
              link_arrow_size: 12,
              bar_height_padding: 9,
              lightbox_additional_height: 75,
            },
            _second_column_width: 100,
            _third_column_width: 70,
          };
        })(t),
        (function (i) {
          i.skins.meadow = {
            config: {
              grid_width: 380,
              row_height: 27,
              scale_height: 30,
              link_line_width: 2,
              link_arrow_size: 10,
              bar_height_padding: 4,
              lightbox_additional_height: 72,
            },
            _second_column_width: 95,
            _third_column_width: 80,
          };
        })(t),
        (function (i) {
          i.skins.terrace = {
            config: {
              grid_width: 390,
              row_height: 36,
              scale_height: 36,
              link_line_width: 2,
              link_arrow_size: 12,
              bar_height_padding: 9,
              lightbox_additional_height: 75,
            },
            _second_column_width: 100,
            _third_column_width: 70,
          };
        })(t),
        (function (i) {
          i.skins.broadway = {
            config: {
              grid_width: 390,
              row_height: 35,
              scale_height: 35,
              link_line_width: 1,
              link_arrow_size: 9,
              bar_height_padding: 4,
              lightbox_additional_height: 86,
            },
            _second_column_width: 100,
            _third_column_width: 80,
            _lightbox_template:
              "<div class='gantt_cal_ltitle'><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='gantt_title'></span><div class='gantt_cancel_btn'></div></div><div class='gantt_cal_larea'></div>",
            _config_buttons_left: {},
            _config_buttons_right: {
              gantt_delete_btn: "icon_delete",
              gantt_save_btn: "icon_save",
            },
          };
        })(t),
        (function (i) {
          (i.skins.material = {
            config: {
              grid_width: 411,
              row_height: 34,
              scale_height: 36,
              link_line_width: 2,
              link_arrow_size: 12,
              bar_height_padding: 9,
              lightbox_additional_height: 80,
            },
            _second_column_width: 110,
            _third_column_width: 75,
            _redefine_lightbox_buttons: {
              buttons_left: ["dhx_delete_btn"],
              buttons_right: ["dhx_cancel_btn", "dhx_save_btn"],
            },
          }),
            i.attachEvent("onAfterTaskDrag", function (a) {
              var r = i.getTaskNode(a);
              r &&
                ((r.className += " gantt_drag_animation"),
                setTimeout(function () {
                  var s = r.className.indexOf(" gantt_drag_animation");
                  s > -1 && (r.className = r.className.slice(0, s));
                }, 200));
            });
        })(t),
        (function (i) {
          i.skins.contrast_black = {
            config: {
              grid_width: 390,
              row_height: 35,
              scale_height: 35,
              link_line_width: 2,
              link_arrow_size: 12,
              lightbox_additional_height: 75,
            },
            _second_column_width: 100,
            _third_column_width: 80,
          };
        })(t),
        (function (i) {
          i.skins.contrast_white = {
            config: {
              grid_width: 390,
              row_height: 35,
              scale_height: 35,
              link_line_width: 2,
              link_arrow_size: 12,
              lightbox_additional_height: 75,
            },
            _second_column_width: 100,
            _third_column_width: 80,
          };
        })(t),
        (function (i) {
          i.ext || (i.ext = {});
          for (var a = [Ir, null, null], r = 0; r < a.length; r++)
            a[r] && a[r](i);
          i.ext.zoom = new Pr(i);
        })(t),
        Rr(t),
        Br(t),
        (function (i) {
          (i._extend_to_optional = function (a) {
            var r = a,
              s = {
                render: r.render,
                focus: r.focus,
                set_value: function (o, l, d, c) {
                  var u = i._resolve_default_mapping(c);
                  if (
                    !d[u.start_date] ||
                    (u.start_date == "start_date" &&
                      this._isAllowedUnscheduledTask(d))
                  ) {
                    s.disable(o, c);
                    var h = {};
                    for (var _ in u) h[u[_]] = d[_];
                    return r.set_value.call(i, o, l, h, c);
                  }
                  return s.enable(o, c), r.set_value.call(i, o, l, d, c);
                },
                get_value: function (o, l, d) {
                  return d.disabled
                    ? { start_date: null }
                    : r.get_value.call(i, o, l, d);
                },
                update_block: function (o, l) {
                  if (
                    (i.callEvent("onSectionToggle", [i._lightbox_id, l]),
                    (o.style.display = l.disabled ? "none" : ""),
                    l.button)
                  ) {
                    var d = o.previousSibling.querySelector(
                        ".gantt_custom_button_label"
                      ),
                      c = i.locale.labels,
                      u = l.disabled
                        ? c[l.name + "_enable_button"]
                        : c[l.name + "_disable_button"];
                    d.innerHTML = u;
                  }
                },
                disable: function (o, l) {
                  (l.disabled = !0), s.update_block(o, l);
                },
                enable: function (o, l) {
                  (l.disabled = !1), s.update_block(o, l);
                },
                button_click: function (o, l, d, c) {
                  if (
                    i.callEvent("onSectionButton", [i._lightbox_id, d]) !== !1
                  ) {
                    var u = i._get_typed_lightbox_config()[o];
                    u.disabled ? s.enable(c, u) : s.disable(c, u);
                  }
                },
              };
            return s;
          }),
            (i.form_blocks.duration_optional = i._extend_to_optional(
              i.form_blocks.duration
            )),
            (i.form_blocks.time_optional = i._extend_to_optional(
              i.form_blocks.time
            ));
        })(t),
        (function (i) {
          var a = new RegExp(
              `<(?:.|
)*?>`,
              "gm"
            ),
            r = new RegExp(" +", "gm");
          function s(c) {
            return (c + "").replace(a, " ").replace(r, " ");
          }
          var o = new RegExp("'", "gm");
          function l(c) {
            return (c + "").replace(o, "&#39;");
          }
          for (var d in ((i._waiAria = {
            getAttributeString: function (c) {
              var u = [" "];
              for (var h in c) {
                var _ = l(s(c[h]));
                u.push(h + "='" + _ + "'");
              }
              return u.push(" "), u.join(" ");
            },
            getTimelineCellAttr: function (c) {
              return i._waiAria.getAttributeString({ "aria-label": c });
            },
            _taskCommonAttr: function (c, u) {
              c.start_date &&
                c.end_date &&
                (u.setAttribute(
                  "aria-label",
                  s(i.templates.tooltip_text(c.start_date, c.end_date, c))
                ),
                c.$dataprocessor_class && u.setAttribute("aria-busy", !0));
            },
            setTaskBarAttr: function (c, u) {
              this._taskCommonAttr(c, u),
                u.setAttribute("role", "img"),
                !i.isReadonly(c) &&
                  i.config.drag_move &&
                  (c.id != i.getState("tasksDnd").drag_id
                    ? u.setAttribute("aria-grabbed", !1)
                    : u.setAttribute("aria-grabbed", !0));
            },
            taskRowAttr: function (c, u) {
              this._taskCommonAttr(c, u),
                !i.isReadonly(c) &&
                  i.config.order_branch &&
                  u.setAttribute("aria-grabbed", !1),
                u.setAttribute("role", "row"),
                u.setAttribute(
                  "aria-selected",
                  i.isSelectedTask(c.id) ? "true" : "false"
                ),
                u.setAttribute("aria-level", c.$level + 1 || 1),
                i.hasChild(c.id) &&
                  u.setAttribute("aria-expanded", c.$open ? "true" : "false");
            },
            linkAttr: function (c, u) {
              var h = i.config.links,
                _ = c.type == h.finish_to_start || c.type == h.start_to_start,
                f = c.type == h.start_to_start || c.type == h.start_to_finish,
                y =
                  i.locale.labels.link +
                  " " +
                  i.templates.drag_link(c.source, f, c.target, _);
              u.setAttribute("role", "img"), u.setAttribute("aria-label", s(y));
            },
            gridSeparatorAttr: function (c) {
              c.setAttribute("role", "columnheader");
            },
            rowResizerAttr: function (c) {
              c.setAttribute("role", "row");
            },
            lightboxHiddenAttr: function (c) {
              c.setAttribute("aria-hidden", "true");
            },
            lightboxVisibleAttr: function (c) {
              c.setAttribute("aria-hidden", "false");
            },
            lightboxAttr: function (c) {
              c.setAttribute("role", "dialog"),
                c.setAttribute("aria-hidden", "true"),
                c.firstChild.setAttribute("role", "heading"),
                c.firstChild.setAttribute("aria-level", "1");
            },
            lightboxButtonAttrString: function (c) {
              return this.getAttributeString({
                role: "button",
                "aria-label": i.locale.labels[c],
                tabindex: "0",
              });
            },
            lightboxHeader: function (c, u) {
              c.setAttribute("aria-label", u);
            },
            lightboxSelectAttrString: function (c) {
              var u = "";
              switch (c) {
                case "%Y":
                  u = i.locale.labels.years;
                  break;
                case "%m":
                  u = i.locale.labels.months;
                  break;
                case "%d":
                  u = i.locale.labels.days;
                  break;
                case "%H:%i":
                  u = i.locale.labels.hours + i.locale.labels.minutes;
              }
              return i._waiAria.getAttributeString({ "aria-label": u });
            },
            lightboxDurationInputAttrString: function (c) {
              return this.getAttributeString({
                "aria-label": i.locale.labels.column_duration,
                "aria-valuemin": "0",
                role: "spinbutton",
              });
            },
            inlineEditorAttr: function (c) {
              c.setAttribute("role", "row");
            },
            gridAttrString: function () {
              return [
                " role='treegrid'",
                i.config.multiselect
                  ? "aria-multiselectable='true'"
                  : "aria-multiselectable='false'",
                " ",
              ].join(" ");
            },
            gridScaleRowAttrString: function () {
              return "role='row'";
            },
            gridScaleCellAttrString: function (c, u) {
              var h = "";
              if (c.name == "add")
                h = this.getAttributeString({
                  role: "columnheader",
                  "aria-label": i.locale.labels.new_task,
                });
              else {
                var _ = {
                  role: "columnheader",
                  "aria-label":
                    i.config.external_render &&
                    i.config.external_render.isElement(u)
                      ? ""
                      : u,
                };
                i._sort &&
                  i._sort.name == c.name &&
                  (i._sort.direction == "asc"
                    ? (_["aria-sort"] = "ascending")
                    : (_["aria-sort"] = "descending")),
                  (h = this.getAttributeString(_));
              }
              return h;
            },
            gridDataAttrString: function () {
              return "role='rowgroup'";
            },
            reorderMarkerAttr: function (c) {
              c.setAttribute("role", "grid"),
                c.firstChild.removeAttribute("aria-level"),
                c.firstChild.setAttribute("aria-grabbed", "true");
            },
            gridCellAttrString: function (c, u, h) {
              var _ = { role: "gridcell", "aria-label": u };
              return (
                (c.editor && !i.isReadonly(h)) || (_["aria-readonly"] = !0),
                this.getAttributeString(_)
              );
            },
            gridAddButtonAttrString: function (c) {
              return this.getAttributeString({
                role: "button",
                "aria-label": i.locale.labels.new_task,
              });
            },
            messageButtonAttrString: function (c) {
              return "tabindex='0' role='button' aria-label='" + c + "'";
            },
            messageInfoAttr: function (c) {
              c.setAttribute("role", "alert");
            },
            messageModalAttr: function (c, u) {
              c.setAttribute("role", "dialog"),
                u && c.setAttribute("aria-labelledby", u);
            },
            quickInfoAttr: function (c) {
              c.setAttribute("role", "dialog");
            },
            quickInfoHeaderAttrString: function () {
              return " role='heading' aria-level='1' ";
            },
            quickInfoHeader: function (c, u) {
              c.setAttribute("aria-label", u);
            },
            quickInfoButtonAttrString: function (c) {
              return i._waiAria.getAttributeString({
                role: "button",
                "aria-label": c,
                tabindex: "0",
              });
            },
            tooltipAttr: function (c) {
              c.setAttribute("role", "tooltip");
            },
            tooltipVisibleAttr: function (c) {
              c.setAttribute("aria-hidden", "false");
            },
            tooltipHiddenAttr: function (c) {
              c.setAttribute("aria-hidden", "true");
            },
          }),
          i._waiAria))
            i._waiAria[d] = (function (c) {
              return function () {
                return i.config.wai_aria_attributes
                  ? c.apply(this, arguments)
                  : "";
              };
            })(i._waiAria[d]);
        })(t),
        (t.locate = function (i) {
          var a = Et(i);
          if (dt(a, ".gantt_task_row")) return null;
          var r = arguments[1] || this.config.task_attribute,
            s = Q(a, r);
          return s ? s.getAttribute(r) : null;
        }),
        (t._locate_css = function (i, a, r) {
          return mt(i, a, r);
        }),
        (t._locateHTML = function (i, a) {
          return Q(i, a || this.config.task_attribute);
        });
    }
    t.attachEvent("onParse", function () {
      K(t) ||
        t.attachEvent(
          "onGanttRender",
          function () {
            if (t.config.initial_scroll) {
              var i = t.getTaskByIndex(0),
                a = i ? i.id : t.config.root_id;
              t.isTaskExists(a) &&
                t.$task &&
                t.utils.dom.isChildOf(t.$task, t.$container) &&
                t.showTask(a);
            }
          },
          { once: !0 }
        );
    }),
      t.attachEvent("onBeforeGanttReady", function () {
        this.config.scroll_size || (this.config.scroll_size = on() || 15),
          K(t) ||
            (this._eventRemoveAll(),
            this.$mouseEvents.reset(),
            this.resetLightbox());
      }),
      t.attachEvent("onGanttReady", function () {
        !K(t) &&
          t.config.rtl &&
          t.$layout.getCellsByType("viewCell").forEach(function (i) {
            var a = i.$config.scrollX;
            if (a) {
              var r = t.$ui.getView(a);
              r && r.scrollTo(r.$config.scrollSize, 0);
            }
          });
      }),
      t.attachEvent("onGanttReady", function () {
        if (!K(t)) {
          var i = t.plugins(),
            a = {
              auto_scheduling: t.autoSchedule,
              click_drag: t.ext.clickDrag,
              critical_path: t.isCriticalTask,
              drag_timeline: t.ext.dragTimeline,
              export_api: t.exportToPDF,
              fullscreen: t.ext.fullscreen,
              grouping: t.groupBy,
              keyboard_navigation: t.ext.keyboardNavigation,
              marker: t.addMarker,
              multiselect: t.eachSelectedTask,
              overlay: t.ext.overlay,
              quick_info: t.templates.quick_info_content,
              tooltip: t.ext.tooltips,
              undo: t.undo,
            };
          for (let r in a)
            a[r] &&
              !i[r] &&
              console.warn(`You connected the '${r}' extension via an obsolete file. 
To fix it, you need to remove the obsolete file and connect the extension via the plugins method: https://docs.dhtmlx.com/gantt/api__gantt_plugins.html`);
        }
      });
  }
  function jr(t) {
    var n = {};
    t.$data.tasksStore.attachEvent("onClearAll", function () {
      n = {};
    });
    var e = Te.prototype.hasChild;
    (t.$data.tasksStore.hasChild = function (i) {
      return t.config.branch_loading
        ? !!e.call(this, i) ||
            (!!this.exists(i) &&
              this.getItem(i)[t.config.branch_loading_property])
        : e.call(this, i);
    }),
      t.attachEvent("onTaskOpened", function (i) {
        if (
          t.config.branch_loading &&
          t._load_url &&
          (function (l) {
            return !(
              !t.config.branch_loading ||
              !t._load_url ||
              n[l] ||
              t.getChildren(l).length ||
              !t.hasChild(l)
            );
          })(i)
        ) {
          var a = t._load_url,
            r =
              (a = a.replace(/(\?|&)?parent_id=.+&?/, "")).indexOf("?") >= 0
                ? "&"
                : "?",
            s = t.getScrollState().y || 0,
            o = {
              taskId: i,
              url: a + r + "parent_id=" + encodeURIComponent(i),
            };
          if (t.callEvent("onBeforeBranchLoading", [o]) === !1) return;
          t.load(o.url, this._load_type, function () {
            s && t.scrollTo(null, s), t.callEvent("onAfterBranchLoading", [o]);
          }),
            (n[i] = !0);
        }
      });
  }
  const le = new (class {
      constructor(t, n) {
        (this.plugin = (e) => {
          this._ganttPlugin.push(e),
            J.gantt !== void 0 && J.gantt.getTask && e(J.gantt);
        }),
          (this.getGanttInstance = (e) => {
            const i = this._factoryMethod(this._bundledExtensions);
            for (let a = 0; a < this._ganttPlugin.length; a++)
              this._ganttPlugin[a](i);
            return (
              (i._internal_id = this._seed++),
              e && this._initFromConfig(i, e),
              i
            );
          }),
          (this._initFromConfig = (e, i) => {
            if (i.plugins)
              for (const a in i.plugins)
                this._extensionsManager.getExtension(a) &&
                  e.plugins({ [a]: !0 });
            if (
              (i.config && e.mixin(e.config, i.config, !0),
              i.templates &&
                e.attachEvent(
                  "onTemplatesReady",
                  function () {
                    e.mixin(e.templates, i.templates, !0);
                  },
                  { once: !0 }
                ),
              i.events)
            )
              for (const a in i.events) e.attachEvent(a, i.events[a]);
            i.locale && e.i18n.setLocale(i.locale),
              Array.isArray(i.calendars) &&
                i.calendars.forEach(function (a) {
                  e.addCalendar(a);
                }),
              i.container ? e.init(i.container) : e.init(),
              i.data &&
                (typeof i.data == "string" ? e.load(i.data) : e.parse(i.data));
          }),
          (this._seed = 0),
          (this._ganttPlugin = []),
          (this._factoryMethod = t),
          (this._bundledExtensions = n),
          (this._extensionsManager = new bn(n));
      }
    })(function (t) {
      var n = Ha(t);
      return (
        n.env.isNode ||
          (zr(n),
          (function (e) {
            e.load = function (i, a, r) {
              (this._load_url = i),
                this.assert(arguments.length, "Invalid load arguments");
              var s = "json",
                o = null;
              return (
                arguments.length >= 3
                  ? ((s = a), (o = r))
                  : typeof arguments[1] == "string"
                  ? (s = arguments[1])
                  : typeof arguments[1] == "function" && (o = arguments[1]),
                (this._load_type = s),
                this.callEvent("onLoadStart", [i, s]),
                this.ajax.get(
                  i,
                  e.bind(function (l) {
                    this.on_load(l, s),
                      this.callEvent("onLoadEnd", [i, s]),
                      typeof o == "function" && o.call(this);
                  }, this)
                )
              );
            };
          })(n),
          jr(n)),
        n
      );
    }, bi),
    Qe = le.getGanttInstance();
  (J.gantt = Qe),
    (J.Gantt = le),
    // le.plugin((t) => {
    //   const n = document.location ? document.location.href : ''
    //   if (
    //     n.indexOf('dhtmlx.com/') === -1 &&
    //     n.indexOf('webixcode.com/') === -1 &&
    //     n.indexOf('dhtmlxcode.com/') === -1
    //   ) {
    //     const e = `$_${Date.now()}_validate`
    //     setTimeout(
    //       function () {
    //         t.$destroyed ||
    //           t.message({
    //             type: 'error',
    //             text: 'This version of DHTMLX Gantt is not intended for using outside of dhtmlx.com',
    //             expire: -1,
    //             id: e,
    //           })
    //       },
    //       Math.floor(5e3 * Math.random()) + 1e3,
    //     )
    //   }
    // }),
    (St.Gantt = le),
    (St.default = Qe),
    (St.gantt = Qe),
    Object.defineProperties(St, {
      __esModule: { value: !0 },
      [Symbol.toStringTag]: { value: "Module" },
    });
});
