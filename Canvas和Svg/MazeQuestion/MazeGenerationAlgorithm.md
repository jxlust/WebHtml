[https://en.wikipedia.org/wiki/Maze_generation_algorithm](https://en.wikipedia.org/wiki/Maze_generation_algorithm)

### 1.随机深度优先搜索
使用深度优先搜索的生成器动画
此算法也称为“递归回溯器”算法，是深度优先搜索算法的随机版本。

通常使用堆栈来实现，此方法是使用计算机生成迷宫的最简单方法之一。考虑迷宫的空间是一个很大的牢房网格（例如一个大的棋盘），每个牢房都从四堵墙开始。从随机单元开始，计算机然后选择一个尚未访问的随机相邻单元。计算机将移除两个单元之间的墙并将新单元标记为已访问，然后将其添加到堆栈中以方便回溯。计算机将继续执行此过程，将没有未访问邻居的单元视为死胡同。当到达死角时，它会沿路径回溯，直到到达一个没有人来访的邻居的小室，然后通过访问这个新的，未被人来访的小室（创建一个新的结点）来继续进行路径生成。这个过程一直持续到访问完每个单元为止，使计算机一直回溯到起始单元格。我们可以确定每个单元都已访问。

如上所述，该算法涉及深度递归，这可能会导致某些计算机体系结构上的堆栈溢出问题。通过将回溯信息存储在迷宫自身中，可以将该算法重新排列为循环。通过从任何给定点开始并回溯到起点，这也提供了一种显示解决方案的快速方法。

深度优先搜索生成的迷宫具有较低的分支因子，并且包含许多长廊，因为该算法在回溯之前会沿着每个分支进行尽可能远的探索。

#### 递归执行

迷宫生成的深度优先搜索算法经常使用回溯来实现。这可以用以下递归例程来描述：

1. 给定当前单元格作为参数，
2. 将当前单元格标记为已访问
3. 虽然当前单元格有任何未访问的邻居单元格
    1. 选择一个未访问的邻居
    2. 删除当前单元格和所选单元格之间的墙
    3. 递归调用所选单元格的例程

该区域中的任何初始单元格都会被调用一次。

#### 迭代实现
第一种方法的缺点是递归深度大-在最坏的情况下，例程可能需要在正在处理的区域的每个单元上递归，这在许多环境中可能超过最大递归堆栈深度。作为解决方案，可以使用显式堆栈来实现相同的回溯方法，该堆栈通常可以增长得更大而不会造成损害。

1. 选择初始单元格，将其标记为已访问并将其推入堆栈
2. 当堆栈不为空时
    1. 从堆栈中弹出一个单元格并使其成为当前单元格
    2. 如果当前单元格中有尚未访问过的任何邻居
        1. 将当前单元格推入堆栈
        2. 选择一个未访问的邻居
        3. 删除当前单元格和所选单元格之间的墙
        4. 将所选单元格标记为已访问并将其推入堆栈


### 2.随机Kruskal算法
档案：KruskalGeneratedMaze.webm
使用Kruskal算法生成30 x 20迷宫的动画。
该算法是Kruskal算法的随机版本。

1. 创建所有墙的列表，并为每个单元格创建一个集合，每个仅包含一个单元格。
2. 对于每面墙，以某种随机顺序：
    1. 如果被此墙划分的单元格属于不同的集合：
        1. 拆除当前的墙壁。
        2. 加入以前划分的单元格的集合。

有几种数据结构可用于对单元集进行建模。使用不相交集数据结构的有效实现可以在几乎恒定的摊销时间内执行每个联合并在两组上查找操作（具体来说，{\ displaystyle O（\ alpha（V））}O（\ alpha（V）） 时间; {\ displaystyle \ alpha（x）<5}\ alpha（x）<5 对于任何合理的价值 {\ displaystyle x}X），因此此算法的运行时间基本上与迷宫可用的墙数成正比。

墙壁列表最初是随机的还是从非随机列表中随机选择墙壁无关紧要，这两种方法都一样容易编码。

由于此算法的效果是从具有相等权重边的图生成最小的生成树，因此它倾向于生成很容易解决的规则模式。

### 3.随机普里姆算法
使用Prim's算法生成30 x 20迷宫的动画。
该算法是Prim算法的随机版本。

1. 从充满墙壁的网格开始。
2. 选择一个单元格，将其标记为迷宫的一部分。将单元格的墙添加到墙列表中。
3. 虽然列表中有墙：
    1. 从列表中选择一个随机的墙。如果仅访问墙划分的两个单元之一，则：
        1. 使墙壁成为通道，并将未访问的单元标记为迷宫的一部分。
        2. 将单元格的相邻墙添加到墙列表中。
    2. 从列表中删除墙。

请注意，在具有随机边缘权重的图形上简单运行经典Prim's会产生与Kruskal风格上完全相同的迷宫，因为它们都是最小的生成树算法。相反，此算法引入了样式变化，因为更接近起点的边缘具有较低的有效权重。

修改后的版本
尽管经典的Prim算法保留了一系列边，但是对于迷宫生成，我们可以替代地保留相邻单元的列表。如果随机选择的像元具有将其连接到现有迷宫的多个边，请随机选择这些边之一。与上面的基于边缘的版本相比，它的分支趋向于稍微多一点。

简化版
通过随机选择与已访问过的单元格相邻的单元格，而不是跟踪所有单元格或边缘的权重，可以进一步简化算法。

通常很难找到通往起始单元的道路，而很难找到其他任何地方的道路。
