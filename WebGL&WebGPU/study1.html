<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="reset.css" />
    <style>
      .container {
        width: 100vw;
        height: 100vh;
        display: block;
        background-color: #f8f8f8;
        display: grid;
        place-items: center;
      }
      #app {
        width: 600px;
        height: 600px;
        background-color: #000;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <canvas id="app"></canvas>
    </div>
  </body>

  <script>
    function main() {
      const canvas = document.getElementById("app");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        console.error("浏览器不支持WebGL！");
        return;
      }
      // 设置清空颜色（黑色）并清空画布
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      // 3. 定义顶点数据
      const vertices = new Float32Array([
        // 顶点1
        0.0, 0.5,
        // 顶点2
        -0.5, -0.5,
        // 顶点3
        0.5, -0.5,
        // 4
        0.0, 1.0,
      ]);

      // 4. 编写着色器
      // 顶点着色器
      const vertexShaderSource = `
          attribute vec2 a_position;
          void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
          }`;
      // 片段着色器 输出红色
      const fragmentShaderSource = `
          precision mediump float;
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }`;

      // 5. 编译链接着色器程序
      const createShader = (gl, type, source) => {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        // 错误检查省略，实际需添加！
        var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
          return shader;
        }

        console.log(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
      };

      const vertexShader = createShader(
        gl,
        gl.VERTEX_SHADER,
        vertexShaderSource
      );
      const fragmentShader = createShader(
        gl,
        gl.FRAGMENT_SHADER,
        fragmentShaderSource
      );

      // 5.2 然后我们将这两个着色器 link（链接）到一个 program（着色程序）
      const createProgram = (gl, vertexShader, fragmentShader) => {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        const success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (success) {
          return program;
        }

        console.log(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
      };
      const program = createProgram(gl, vertexShader, fragmentShader);

      // 6.传递顶点数据到GPU

      // 创建缓冲区
      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      // 关联缓冲区与着色器
      const positionLocation = gl.getAttribLocation(program, "a_position");
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(positionLocation);

      gl.useProgram(program);

      // 绘制 从第0个顶点开始，画3个点
      //   gl.drawArrays(gl.TRIANGLES, 0, 4);
      gl.drawArrays(gl.LINE_LOOP, 0, 4);
    }

    window.onload = main;
  </script>
</html>
